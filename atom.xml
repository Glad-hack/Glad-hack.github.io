<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孤独行者</title>
  
  <subtitle>心有不甘，却无以为继</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dream-ak.top/"/>
  <updated>2020-03-11T09:35:35.443Z</updated>
  <id>https://www.dream-ak.top/</id>
  
  <author>
    <name>无向秃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单调栈</title>
    <link href="https://www.dream-ak.top/2020/03/11/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://www.dream-ak.top/2020/03/11/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2020-03-11T08:05:33.000Z</published>
    <updated>2020-03-11T09:35:35.443Z</updated>
    
    <content type="html"><![CDATA[<p>这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！<a id="more"></a></p><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a><a href="https://oi-wiki.org/ds/monotonous-stack/" target="_blank" rel="noopener">单调栈</a></h1><p>不懂请点击上面链接学习，我就不介绍什么是单调栈了。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="http://39.105.62.44/web/problem.php?id=1035" target="_blank" rel="noopener">题目</a></h2><p>可以到上面链接提交测试。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><blockquote><p>已知一个长度为n的数组，在其中找一个长度为m的子序列，规则如下：<br>首先第一个数字尽量大，然后第二个数字尽量大，第三个数字也要尽量大，等等…. </p></blockquote><h2 id="思想和解法"><a href="#思想和解法" class="headerlink" title="思想和解法"></a>思想和解法</h2><p>首先按照题意来，我们先求第一个尽量大的值，为了让他能找到m个数字，我们先求1~n-m+1的最大值，那么这个值就会是第一个值，第二个值就是在第一个值的位置到n-m+2的最大值，依次类推，求出所有。<br>可以发现这是一个暴力解法，复杂度是$O(n^2)$</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>我们利用单调栈实现一个单调不上升栈，那么第一个数就是当栈顶下标到n-m+1时的栈底值。把栈底退出(这个操作用数组模拟吧)，第二个数就是栈顶下标到n-m+2的栈底值，以此类推！</p><p>解释一下：因为单调不上升，那么栈底一定最大，且栈内数字顺序没变！符合题意，当把栈底退出以后第二个值就是栈底的下标到n-m+1的最大值咯。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+5;</span><br><span class="line">int sta[N],a[N];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int l = 0, r = 0;   </span><br><span class="line">        for(i=1;i&lt;=n-m;i++)&#123;</span><br><span class="line">            while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--;</span><br><span class="line">            sta[++r] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=n-m+1;i&lt;=n;i++)&#123;</span><br><span class="line">            while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--;</span><br><span class="line">            sta[++r] = a[i];</span><br><span class="line">            l++;</span><br><span class="line">            printf(&quot;%d%c&quot;,sta[l],l==m?&apos;\n&apos;:&apos; &apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相同题型"><a href="#相同题型" class="headerlink" title="相同题型"></a>相同题型</h2><p><a href="https://nanti.jisuanke.com/t/39614" target="_blank" rel="noopener">双倍快乐</a>,单调栈的大于改小于就完事了，数据很大，卡O(nlogn)!.<br><a href="https://leetcode-cn.com/problems/create-maximum-number/solution/dan-diao-zhan-by-powcai/" target="_blank" rel="noopener">秃头快乐</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Java修饰符</title>
    <link href="https://www.dream-ak.top/2020/03/11/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://www.dream-ak.top/2020/03/11/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2020-03-11T03:03:45.000Z</published>
    <updated>2020-03-11T12:06:49.999Z</updated>
    
    <content type="html"><![CDATA[<p>听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。<a id="more"></a><br>写在前面：本文来自对于<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">这篇文章</a>文章的理解</p><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p>修饰符分为一下两种：</p><ol><li>访问修饰符</li><li>非访问修饰符</li></ol><h2 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h2><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。<br>|修饰符|当前类|同一包|子孙类(同一包)|子孙类(不同包)|其他包|<br>|:—-:|:—-:|:—-:|:—-:|:—-:|:—-:|<br>|public|Y|Y|Y|Y|Y|<br>|protected|Y|Y|Y|Y/N(<a href="https://www.runoob.com/java/java-modifier-types.html#protected-desc" target="_blank" rel="noopener">解释请看</a>)|N|<br>|default|Y|Y|Y|N|N|<br>|private|Y|N|N|N|N|</p><h2 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h2><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><blockquote><p>静态变量：<br>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p><p>静态方法：<br>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p></blockquote><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><blockquote><p>final 变量<br>final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p><p>final 方法<br>父类中的 final 方法可以被子类继承，但是不能被子类重写。<br>声明 final 方法的主要目的是防止该方法的内容被修改。</p></blockquote><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><blockquote><p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p><p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p><p>抽象类可以包含抽象方法和非抽象方法。</p></blockquote><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><blockquote><p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p><p>抽象方法不能被声明成 final 和 static。</p><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p></blockquote><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>transient 修饰符<br>volatile 修饰符<br>synchronized 修饰符</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java对象</title>
    <link href="https://www.dream-ak.top/2020/03/11/Java%E5%AF%B9%E8%B1%A1/"/>
    <id>https://www.dream-ak.top/2020/03/11/Java%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-03-11T02:11:29.000Z</published>
    <updated>2020-03-11T04:35:13.519Z</updated>
    
    <content type="html"><![CDATA[<p>听课<a id="more"></a></p><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="Java面向对象的基本组成"><a href="#Java面向对象的基本组成" class="headerlink" title="Java面向对象的基本组成"></a>Java面向对象的基本组成</h2><ol><li>Java类及类的成员：属性、方法、构造器；代码块、内部类</li><li>面向对象三大特征：封装、继承、多态(抽象)</li><li>关键字：this、super、static、final、abstract、interface、package、import…</li></ol><h2 id="类和对象："><a href="#类和对象：" class="headerlink" title="类和对象："></a>类和对象：</h2><p>类是对一类事物共同特点的统一，而对象就是类的实例。(就像水果和苹果一样)<br>比如：手机需要充电，手机可以打电话，等等都是这个手机就是一个类，华为手机就是一个对象。</p><h3 id="类的代码定义格式"><a href="#类的代码定义格式" class="headerlink" title="类的代码定义格式"></a>类的代码定义格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 [父类名] [implements 接口名] &#123;</span><br><span class="line">    //类体,包括属性和方法</span><br><span class="line">    //属性</span><br><span class="line">    [修饰符] 数据类型 变量名 [ = 值]</span><br><span class="line">    //方法</span><br><span class="line">    [修饰符] [返回值] 方法名([参数类型 参数名1]，[参数类型 参数名2]...)&#123;</span><br><span class="line">        方法体</span><br><span class="line">        return 返回值</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = new 类名();</span><br></pre></td></tr></table></figure><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>懒得开草稿文件了。。。先发布了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听课&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯校赛第九题</title>
    <link href="https://www.dream-ak.top/2020/03/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B9%9D%E9%A2%98/"/>
    <id>https://www.dream-ak.top/2020/03/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B9%9D%E9%A2%98/</id>
    <published>2020-03-10T12:24:09.000Z</published>
    <updated>2020-03-10T13:00:42.768Z</updated>
    
    <content type="html"><![CDATA[<p>去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。<a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/2020/03/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B9%9D%E9%A2%98/1.png" alt="1"><br>是我凭记忆复现的，链接在这里<a href="http://39.105.62.44/web/problem.php?id=1005" target="_blank" rel="noopener">第九题</a></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>数据很小，所以第一想法直接把答案全部按照深度优先搜索跑出来，保存下来，然后再交，O(1)输出！<br>深度优先搜索写法：<br>因为每一个数字只与前两个数字有关，那么我们只要每计算一个答案就把这两个数字的答案记录下来，以后在遇到这两个数字就直接使用就好了。(可以学一下记忆化搜索)</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用vis二维数组来保存前两个数字，如果vis[x][y]为0的话就没有用过，为0直接就加上就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">//#include&lt;windows.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1005;</span><br><span class="line">int vis[N][N],a[N];</span><br><span class="line">FILE *fp1 = fopen(&quot;D://program//code//acm//oj//testin.txt&quot;,&quot;w+&quot;);</span><br><span class="line">FILE *fp2 = fopen(&quot;D://program//code//acm//oj//testout.txt&quot;,&quot;w+&quot;);</span><br><span class="line">int dfs(int x,int y)&#123;</span><br><span class="line">int ans=0;//求前面两个数字为能产生的数列数量</span><br><span class="line">for(int i=1;i&lt;abs(y-x);i++)&#123;</span><br><span class="line">if(vis[y][i]==0)&#123;//没有用过则计算出答案并保存</span><br><span class="line">vis[y][i]=dfs(y,i);//计算呢前前一个数字是i前面第二个数字是y的数列数。</span><br><span class="line">ans=(ans+vis[y][i])%10000;</span><br><span class="line">&#125;</span><br><span class="line">else ans=(ans+vis[y][i])%10000;</span><br><span class="line">&#125;</span><br><span class="line">return ans+1;//返回数列值并加上当前值</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int i,j,k,n,m;</span><br><span class="line">for(i=1;i&lt;=1000;i++)&#123;//计算以i开始的数列数量</span><br><span class="line">int ans=0;</span><br><span class="line">for(j=1;j&lt;=i;j++)&#123;</span><br><span class="line">if(vis[i][j]==0)&#123;</span><br><span class="line">vis[i][j]=dfs(i,j);</span><br><span class="line">ans=(ans+vis[i][j])%10000;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ans=(ans+vis[i][j])%10000;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面时间复杂度为<br>因为一个数字开始的话数量与前两个数字有关所以复杂度为O($n^2$)，n个数字是O($n^3$)<br>打出所有答案后复制到另一个程序输出就好了。</p><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int a[1006]=&#123;1,2,4,7,14,26,53,106,220,452,946,1967,4128,8638,8144,8068,26,8127,3542,3277,3278,7643,5433,5774,8217,4846,687,3097,6887,3556,4840,3454,5378,722,2230,767,1447,1839,4776,7618,7831,6222,5236,7802,5696,1835,1102,9537,1605,1227,3034,2159,1613,6811,3941,6794,5960,4903,75,2158,349,4258,5189,4717,2894,4193,2890,258,2928,6125,2913,1482,8419,7244,1652,3440,2138,9272,4714,3333,3543,8834,6763,9180,1803,4631,6307,9056,3170,8339,6213,1176,3258,272,4257,1893,8020,3682,9531,6961,4145,3086,3455,9057,1346,5768,6907,247,2450,4732,8653,8229,842,3346,9671,7106,3561,4952,9539,1791,6208,6083,8838,7474,6854,198,7300,8219,5912,8884,3976,9650,4821,7317,9720,5572,3834,6326,2281,34,8409,28,445,8155,9846,9944,2504,3954,1639,7243,8502,6926,1609,7449,3769,5695,6683,7531,6275,5827,6184,1982,736,9718,2777,7688,6626,7456,961,5556,7573,6886,4543,3957,2859,4666,9795,305,9052,5350,9827,5445,6970,2599,7566,2848,2987,5179,1537,2392,6375,9621,7376,3301,1357,6545,7838,9390,4284,2631,1814,2566,7666,1110,5694,7595,5000,1290,4735,5994,9401,6475,9012,5877,2867,7912,3509,5505,885,7490,5622,4374,8721,5134,8788,5430,3869,9852,5762,75,5964,262,5565,1599,7525,5388,8612,1143,7938,7580,2953,7901,5629,1456,9852,5216,965,3739,7879,1212,9029,9263,9609,1926,8151,1997,6298,5125,5715,4864,3852,604,7652,313,6248,4077,3875,3816,7046,9525,3798,6959,9366,2216,4463,6546,6367,614,9477,3176,4098,7162,7535,4696,749,2686,8212,9050,255,1389,287,1086,9414,9897,2293,31,9121,4682,7084,8951,834,1051,2236,3712,6426,8642,185,785,8162,6015,658,8923,5741,2551,7629,2095,8882,7695,5629,8684,5116,6362,7701,9441,9403,1108,4395,5688,9466,953,9191,4967,7236,6020,3465,8165,872,4530,3353,7859,1422,1504,6366,126,1246,1530,1777,8970,4590,2195,6920,9086,689,2163,6035,4961,2055,7699,4121,3971,1824,3707,4405,854,6088,6971,1679,1779,7097,5696,2449,2104,3264,796,8595,6183,26,5597,7295,5926,9039,4550,9601,5959,3244,7451,5641,2343,6587,3755,4361,3890,446,8187,1979,7000,7094,8658,1647,6090,8332,4407,4570,2340,3057,5029,5424,2736,4844,2771,5782,5912,3745,2504,2782,7247,1393,5403,7175,9903,1723,7600,7021,4566,9778,5188,46,8542,7915,5043,4983,519,480,8199,1141,73,9316,6248,966,3218,6614,6974,5078,9775,7263,6263,7267,1947,5357,286,674,3876,1985,4731,1850,512,1493,5310,5443,4183,5963,8642,1389,6320,4264,9565,7348,4378,6192,1300,3393,4794,8323,6063,9651,9368,7899,9053,4933,5140,5604,9114,9299,7603,2485,884,7313,4139,9883,1405,9843,7419,1483,2031,8610,4150,3313,6257,3790,1688,994,1357,9660,583,5735,1548,7156,9678,8047,3617,9611,7966,7764,5177,7716,4206,7985,6989,6318,5854,8292,9639,687,370,3252,7104,5813,758,8219,3809,2506,3605,9340,3559,4118,4757,8229,4258,944,1596,4940,622,5832,1270,6948,1744,1125,7895,9348,7601,7426,1975,9611,3722,4143,4979,7904,3221,3817,5755,1798,6549,3463,3190,201,6894,6209,3488,670,7643,7020,6164,5583,5036,6309,8644,7961,3465,7795,1486,4535,3111,5252,4049,4253,7515,1517,6148,2438,1296,8826,7924,7761,9126,6951,7110,7549,1170,8533,793,1633,6451,6261,5887,8694,6447,8993,6398,1289,2925,2362,3935,6744,1358,1743,3937,9942,3696,1601,8295,3086,2595,9554,8566,1465,2109,3474,3950,9216,8948,2020,3536,943,4934,8377,6171,1243,3525,259,3001,4205,4548,4754,2365,8630,4690,7872,5131,3995,2672,728,6532,9785,9379,5865,4774,6660,3721,4451,9085,4771,8008,857,9737,5630,4040,3106,5997,4152,8542,3992,3294,5064,2656,5247,635,1521,3026,1502,9396,2171,7188,2425,9758,2640,8648,9454,274,9471,8972,9301,911,6023,4155,126,7802,2948,5675,6313,69,1374,9925,3685,6901,432,1884,4803,8173,9638,3626,695,4286,3836,8670,8834,1444,5187,6281,2482,8801,7656,9066,5138,5160,9857,906,5235,7243,5281,5103,5826,5023,3637,5607,1204,5697,3422,1192,8753,6087,2083,3256,8201,9853,1886,3953,4732,7351,6387,9148,2299,4843,3891,3572,874,9873,1235,7323,8860,3439,113,5132,6521,1234,7427,4062,1342,2480,641,8802,9788,5336,3649,1301,3268,749,1628,9202,2689,3284,9170,5252,1577,1705,5640,2185,2252,4943,271,5117,8699,2743,8221,2119,3851,701,2740,4247,7037,9764,4445,5848,6135,6166,5328,2584,1131,3005,8817,2783,7749,6112,5567,9688,2549,7929,8650,60,1896,3998,7345,3352,8990,1143,873,1191,5821,9485,5249,3086,8016,9319,4139,3566,8871,7528,7873,4117,1085,7064,8222,5947,4447,1326,5206,12,9703,5711,3951,219,6966,3168,2372,9603,9092,1904,1010,2704,2106,7568,3410,296,6825,9781,637,4465,7953,6861,2142,2035,9743,1921,3051,7424,7112,7676,5245,9531,2284,4498,6423,6977,3106,1367,5696,2003,1291,3025,76,3147,9094,4580,5097,7390,8637,5853,359,3153,4957,6635,5721,3353,2266,3481,7432,3020,7330,1172,5285,1525,2928,5331,8856,2163,5169,1465,4439,1876,7446,2192,5577,726,6599,352,3645,7733,8331,5447,8017,5017,7287,6602,7248,6323,4195,9617,2263,4013,450,4073,6131,3569,9019,1858,9827,8118,4972,7422,9666,5760,9213,2817,7952,3948,8683,3645,6402,3264,1919,9276,2519,190,766,8940,3413,2644,8048,83,9724,7009,3777,9663,2483,5752,4578,8951,5902,2170,9967,894,8556,6049,7254,2746,8962,8317,6848,767,7907,1028,9458,6881,4978,6717,8210,3835,1064,7434,746,9449&#125;;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int x;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;x)==1)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,a[x-1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的小结"><a href="#我的小结" class="headerlink" title="我的小结"></a>我的小结</h2><p>emmmm，手机浸水，一边比赛一边晾手机果然写出bug了，第7题血亏！还是不能飘啊。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维" scheme="https://www.dream-ak.top/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>数据库操作</title>
    <link href="https://www.dream-ak.top/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.dream-ak.top/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-10T01:35:16.000Z</published>
    <updated>2020-03-10T13:05:21.718Z</updated>
    
    <content type="html"><![CDATA[<p>最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令<a id="more"></a></p><h1 id="数据库常用命令"><a href="#数据库常用命令" class="headerlink" title="数据库常用命令"></a>数据库常用命令</h1><h2 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h2><ol><li>mysql -h 主机地址 -u 用户名 -p 用户密码<br>如果是本地登录则不需要-h的主机地址<br>如下是Linux服务器打开方式，本地登录没有h<img src="/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/登录.png" alt="登录"><br>windows打开方式：<br>先要进入如图这个目录，不进入的话该命令会无效的，我就不细说，大家应该都是一个目录里面。<br><img src="/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/windows.png" alt="1"><h2 id="退出MySQL"><a href="#退出MySQL" class="headerlink" title="退出MySQL"></a>退出MySQL</h2>输入exit然后回车就完事了<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2>退出MySQL以后在同一个目录使用如下命令</li><li>mysqlsdmin -u root -p密码 password<br>-p密码那里是连起来的，直接回车如图<br><img src="/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/修改密码.png" alt="1"><h2 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h2>首先写在前面：</li><li>对于一个数据库操作命令都是以一个英文分号”;”结束。</li></ol><p>如果你输入命令错误，可以选择先输入一个分号，让他执行错误命令，重新输入。</p><h3 id="库的命令"><a href="#库的命令" class="headerlink" title="库的命令"></a>库的命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">create database name</td><td style="text-align:center">创建数据库</td></tr><tr><td style="text-align:center">use database name</td><td style="text-align:center">选择数据库</td></tr><tr><td style="text-align:center">show databases</td><td style="text-align:center">显示所有数据库</td></tr><tr><td style="text-align:center">drop database name</td><td style="text-align:center">直接删除数据库，不提醒</td></tr></tbody></table></div><p>具体操作如下：<img src="/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/base.png" alt="操作"></p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>这个由于太多我只做简单常用介绍，如想详细了解，<a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">点击</a>。</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字节长度</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">4字节</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">bigint</td><td style="text-align:center">8字节</td><td style="text-align:center">整数</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8字节</td><td style="text-align:center">双精度浮点型</td></tr><tr><td style="text-align:center">date</td><td style="text-align:center">3字节</td><td style="text-align:center">日期值(格式：YYYY:MM:DD)</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">3字节</td><td style="text-align:center">时间值(HH:MM:SS)</td></tr><tr><td style="text-align:center">year</td><td style="text-align:center">1字节</td><td style="text-align:center">年份值(YYYY)</td></tr><tr><td style="text-align:center">datetime</td><td style="text-align:center">8</td><td style="text-align:center">混合日期和时间值(YYYY:MM::DD HH:MM:SS)</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">0-255字节</td><td style="text-align:center">定长字符串</td></tr><tr><td style="text-align:center">varchar</td><td style="text-align:center">0-65535字节</td><td style="text-align:center">变长字符串</td></tr></tbody></table></div><h3 id="表的命令"><a href="#表的命令" class="headerlink" title="表的命令"></a>表的命令</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">create table name(变量 数据类型)</td><td style="text-align:center">创建表</td></tr><tr><td style="text-align:center">drop table name</td><td style="text-align:center">删除表</td></tr><tr><td style="text-align:center">show tables</td><td style="text-align:center">查看当前选定数据库包含表格</td></tr><tr><td style="text-align:center">insert into name(变量名) values (变量值)</td><td style="text-align:center">在name表格插入数据</td></tr><tr><td style="text-align:center">select (变量名或者*) from name</td><td style="text-align:center">从name表格中查看变量名的所有数据(*代表查看所有数据)</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://www.dream-ak.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>python文件操作</title>
    <link href="https://www.dream-ak.top/2020/03/06/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.dream-ak.top/2020/03/06/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-06T01:41:54.000Z</published>
    <updated>2020-03-07T08:06:19.632Z</updated>
    
    <content type="html"><![CDATA[<p>最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。<a id="more"></a></p><h1 id="文件的一些函数"><a href="#文件的一些函数" class="headerlink" title="文件的一些函数"></a>文件的一些函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">参数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><strong>os.getcwd()</strong></td><td style="text-align:center">无参数</td><td style="text-align:center">返回当前工作目录</td></tr><tr><td style="text-align:center"><strong>os.chdir()</strong></td><td style="text-align:center">地址</td><td style="text-align:center">修改当前工作目录到指定文件地址</td></tr><tr><td style="text-align:center"><strong>os.listdir()</strong></td><td style="text-align:center">地址</td><td style="text-align:center">查看当前目录下所有文件</td></tr><tr><td style="text-align:center"><strong>os.makedirs()</strong></td><td style="text-align:center">新建文件夹名称</td><td style="text-align:center">新建文件夹</td></tr><tr><td style="text-align:center"><strong>os.remove(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">删除文件</td></tr><tr><td style="text-align:center"><strong>os.rmdir(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">删除空目录，非空目录报错</td></tr><tr><td style="text-align:center"><strong>os.path.join()</strong></td><td style="text-align:center">要添加的文件路径(字符串)</td><td style="text-align:center">构建一个在所有系统都能运行的文件路径</td></tr><tr><td style="text-align:center"><strong>os.path.abspath()</strong></td><td style="text-align:center">路径(可以为相对路径’..’，’.’)</td><td style="text-align:center">返回绝对路径</td></tr><tr><td style="text-align:center"><strong>os.path.relpath(path,start)</strong></td><td style="text-align:center">start：一个路径，path：路径</td><td style="text-align:center">返回从start到path的相对路径，没有start参数时默认当前工作目录</td></tr><tr><td style="text-align:center"><strong>os.path.dirname()</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回最后一个斜杠以前的所有字符串</td></tr><tr><td style="text-align:center"><strong>os.path.basename()</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回最后一个斜杠以后的字符串</td></tr><tr><td style="text-align:center"><strong>os.path.getsize(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回该路径下指定文件的字节数</td></tr><tr><td style="text-align:center"><strong>os.path.exists(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回bool值表示路径是否存在</td></tr><tr><td style="text-align:center"><strong>os.path.isdir(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回bool值表示路径是否存在且为目录</td></tr><tr><td style="text-align:center"><strong>os.path.isfile(path)</strong></td><td style="text-align:center">路径</td><td style="text-align:center">返回bool值表示路径是否存在且为文件</td></tr><tr><td style="text-align:center"><strong>f = open(path,x)</strong></td><td style="text-align:center">文件路径,x为赋予权限</td><td style="text-align:center">打开文件，且f为文件引用<warn></warn></td></tr><tr><td style="text-align:center"><strong>f.read()</strong></td><td style="text-align:center">无参数</td><td style="text-align:center">返回一个字符串表示文件内容</td></tr><tr><td style="text-align:center"><strong>f.readline</strong></td><td style="text-align:center">无参数</td><td style="text-align:center">返回一个list表示文件每一行</td></tr><tr><td style="text-align:center"><strong>f.close</strong></td><td style="text-align:center">无参数</td><td style="text-align:center">关闭文件</td></tr></tbody></table></div><h2 id="作死之旅"><a href="#作死之旅" class="headerlink" title="作死之旅"></a>作死之旅</h2><p>这是我对于py做的第一个小脚本，使用了类与对象，各种文件操作，学习了一波迭代器，生成器，和异常处理，差不多是对于py的一次小应用了。</p><p>对于这个脚本的话我这里功能是：</p><ol><li>能删除指定后缀文件，只要后缀相同一定删除，无情^-^</li><li>能像linux一样操作但是操作指令不同，支持绝对路径与相对路径的输入</li><li>可以随时查看当前目录的文件</li><li>随时退出</li></ol><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ol><li>递归遍历判断是否为目录</li><li>用os.path.abspath把相对路径转成绝对路径</li><li>os.listdir</li><li>break</li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>我感觉这个删除脚本十分好用，反正我喜欢，还增加了我对于异常处理的能力，其实是学习了一下，对于迭代器的使用，（一开始不想要递归，毕竟它代价有点大，就学了一下，发现我用不上，菜了）对于文件命令的操作，字符串的处理方式也得到了锻炼，对于py的脚本以后就要开始写其他的了（例如excel操作）</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">class Flie(object):</span><br><span class="line">    def list(self):</span><br><span class="line">        print(&quot;当前工作目录：&quot;+os.getcwd())</span><br><span class="line">        file = os.listdir(os.getcwd())</span><br><span class="line">        print(&apos;\n&apos;.join(file))</span><br><span class="line">        pass</span><br><span class="line">    def goto(self, path):</span><br><span class="line">        os.chdir(path)</span><br><span class="line">        pass</span><br><span class="line">    def pathname(self,name):</span><br><span class="line">        print(&quot;请输入你将要进入的文件目录&quot;)</span><br><span class="line">        names = name.split(&quot;\\&quot;)</span><br><span class="line">        x = &apos;\\&apos;.join(names)</span><br><span class="line">        pathnames = os.path.join(x)</span><br><span class="line">        if os.path.isdir(pathnames):</span><br><span class="line">            return pathnames</span><br><span class="line">            pass</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;不存在该目录，请重新尝试^-^&quot;)</span><br><span class="line">        pass</span><br><span class="line">    def erease(self, pathnam,format):</span><br><span class="line">        #os.chdir(pathname)</span><br><span class="line">        pathname=os.path.abspath(pathnam)</span><br><span class="line">        for i in os.listdir(pathname):</span><br><span class="line">            print(pathname)</span><br><span class="line">            pathname1 = os.path.join(pathname,i)</span><br><span class="line">            if os.path.isdir(pathname1):</span><br><span class="line">                self.erease(pathname1,format)</span><br><span class="line">            else:</span><br><span class="line">                file1 = i.split(&apos;.&apos;)</span><br><span class="line">                if file1[-1]==format:</span><br><span class="line">                    try:</span><br><span class="line">                        os.remove(pathname1)</span><br><span class="line">                    except FileNotFoundError as identifier:</span><br><span class="line">                        print(&quot;当前错误删除路径&quot;+os.path.join(os.getcwd(),pathname1))</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;准备完毕，请输入：&quot;)</span><br><span class="line">    os.chdir(&apos;C:\\&apos;)</span><br><span class="line">    print(os.getcwd())</span><br><span class="line">    x = Flie()</span><br><span class="line">    flag  = True</span><br><span class="line">    while flag:</span><br><span class="line">        operate = input().split()</span><br><span class="line">        op = operate[0]</span><br><span class="line">        if op == &quot;goto&quot;:</span><br><span class="line">            name = x.pathname(str(operate[1]))</span><br><span class="line">            try:</span><br><span class="line">                x.goto(name)</span><br><span class="line">            except TypeError as identifier:</span><br><span class="line">                continue</span><br><span class="line">        elif op == &quot;del&quot;:</span><br><span class="line">            name = x.pathname(str(operate[1]))</span><br><span class="line">            print(os.path.getsize(name))</span><br><span class="line">            x.erease(name,operate[2])</span><br><span class="line">            pass</span><br><span class="line">        elif op == &quot;cls&quot;:</span><br><span class="line">            os.system(&apos;cls&apos;)</span><br><span class="line">            print(&quot;当前文件位置：&quot;+os.getcwd())</span><br><span class="line">        elif op == &quot;list&quot;:</span><br><span class="line">            x.list()</span><br><span class="line">        elif op == &quot;help&quot;:</span><br><span class="line">            print(&quot;goto + path：表示进入路径&quot;)</span><br><span class="line">            print(&quot;del + path + str：表示删除该路径下某个特定的文件后缀&quot;)</span><br><span class="line">            print(&quot;cls：清屏&quot;)</span><br><span class="line">            print(&quot;list：打印整个目录下文件&quot;)</span><br><span class="line">            print(&quot;quit：程序退出&quot;)</span><br><span class="line">        elif op == &quot;quit&quot;:</span><br><span class="line">            break</span><br><span class="line">        else :</span><br><span class="line">            print(&quot;输入格式错误，请输入正确格式或输入help寻求帮助&quot;)</span><br><span class="line">            pass</span><br></pre></td></tr></table></figure><p>有漏洞可以提出来，我已经成功的删除了我刷题时产生的所有exe文件了，嘿嘿嘿。有个缺陷是有可能进不了文件而报错，我是没有去弄这个异常的，有大佬经过时可否提点我一下？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="true" scheme="https://www.dream-ak.top/categories/true/"/>
    
    
      <category term="python文件操作" scheme="https://www.dream-ak.top/tags/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>最短路径图</title>
    <link href="https://www.dream-ak.top/2020/03/04/1320B/"/>
    <id>https://www.dream-ak.top/2020/03/04/1320B/</id>
    <published>2020-03-04T10:46:38.000Z</published>
    <updated>2020-03-04T14:22:30.815Z</updated>
    
    <content type="html"><![CDATA[<p>题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://codeforces.ml/contest/1320/problem/B" target="_blank" rel="noopener">题目链接</a></h1><h2 id="思路和解法"><a href="#思路和解法" class="headerlink" title="思路和解法"></a>思路和解法</h2><blockquote><p>首先其余点到达定点的最短路怎么求:<br>我们直接反向建图，求定点到每个点的最短路就是该点到达定点的最短路。<br>最短路径保存<br>我给一个思想类似于求最短路的条数的板子，直接套上最短路条数板子，把记录最短路条数的数组改为记录这一个点的上一个点(原图的下一个节点)就好了。</p></blockquote><p>如果不会最短路条数的板子，<a href="https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/">看这里</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=2e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[N],ed1[N];</span><br><span class="line">int head[N],tot,a[N],vis[N],flag[N],dis[N],head1[N],tot1;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    ed[tot].w=1;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void add1(int u,int v)&#123;</span><br><span class="line">    ed1[++tot1].pre=head1[u];</span><br><span class="line">    ed1[tot1].id=v;</span><br><span class="line">    head1[u]=tot1;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">void dij(int x)&#123;</span><br><span class="line">    memset(dis,0x3f,sizeof dis);</span><br><span class="line">    dis[x]=0;</span><br><span class="line">    q.push(make_pair(0,x));</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int u=q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[u]) continue;</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=head[u];~i;i=ed[i].pre)&#123;</span><br><span class="line">            int v=ed[i].id,w=1;</span><br><span class="line">            if(dis[v]&gt;dis[u]+1)&#123;</span><br><span class="line">                head1[v]=-1;//清空该节点的下一个节点</span><br><span class="line">                add1(v,u);//建最短路图</span><br><span class="line">                dis[v]=dis[u]+1;</span><br><span class="line">                q.push(make_pair(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">            else if(dis[v]==dis[u]+1) add1(v,u);//建最短路图</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        memset(head,-1,sizeof head);</span><br><span class="line">        memset(head1,-1,sizeof head1);</span><br><span class="line">        memset(vis,0,sizeof vis);</span><br><span class="line">        tot=1;</span><br><span class="line">        tot1=1;</span><br><span class="line">        for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            add(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        int len;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;len);</span><br><span class="line">        for(i=1;i&lt;=len;i++) scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">        dij(a[len]);</span><br><span class="line">        int mi=0,ma=0;</span><br><span class="line">        for(i=1;i&lt;len;i++)&#123;</span><br><span class="line">            int flag1=1;</span><br><span class="line">            mi++;</span><br><span class="line">            for(j=head1[a[i]];~j;j=ed1[j].pre)&#123;</span><br><span class="line">                //printf(&quot;%dvvvv\n&quot;,ed[j].id);</span><br><span class="line">                if(ed1[j].id==a[i+1]) mi--;</span><br><span class="line">                else if(flag1) ma++,flag1=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;//统计答案</span><br><span class="line">        printf(&quot;%d %d\n&quot;,mi,ma);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>交互1305D</title>
    <link href="https://www.dream-ak.top/2020/03/04/1305D/"/>
    <id>https://www.dream-ak.top/2020/03/04/1305D/</id>
    <published>2020-03-04T10:41:03.000Z</published>
    <updated>2020-03-04T14:22:27.833Z</updated>
    
    <content type="html"><![CDATA[<p>第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。<br>每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://codeforces.ml/contest/1305/problem/D" target="_blank" rel="noopener">题目链接</a></h1><h2 id="思想和题解"><a href="#思想和题解" class="headerlink" title="思想和题解"></a>思想和题解</h2><p>正解：<br>每一次提问叶子节点，求出它们的LCA(w)。</p><ol><li>如果w == u或者w == v，则w为树的根。<br>因为相等的话，那么证明两个点在同一条路径上面，且两点的度都为1，而$u \rightarrow v$ 本身就要消耗一个度，所以w是没有父节点的，w直接为根节点。</li><li>不相等则把该点从图上删掉且把该点的父节点的度减一<br>不相等，证明两点不在同一路径，那么他们存在祖先节点，则这两点删掉(不是根留他何用)然后父节点度减一原因是因为他的一个子节点删掉了，父节点度肯定减一呗。</li></ol><p>上面的度可以理解为可能为根节点的父节点个数(仅限此题可以这样理解，具体情况，具体分析)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot,w;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].id=v;</span><br><span class="line">    ed[tot].pre=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">int vis[N];//表示可能为根节点的父节点个数，直接说是度了。</span><br><span class="line">void dfs(int x)&#123;</span><br><span class="line">   // printf(&quot;%d\n&quot;,head[x]);</span><br><span class="line">    for(int i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        vis[ed[i].id]--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int t,n,m,i,j,k;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)==1)&#123;</span><br><span class="line">        for(i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            add(u,v);</span><br><span class="line">            add(v,u);</span><br><span class="line">            vis[u]++,vis[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">        int u=0,v=0;</span><br><span class="line">        for(j=1;j&lt;=n/2;j++)&#123;</span><br><span class="line">            //printf(&quot;%d\n&quot;,j);</span><br><span class="line">            for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                if(vis[i]==1&amp;&amp;u==0)&#123;</span><br><span class="line">                    u=i;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(vis[i]==1)&#123;</span><br><span class="line">                    v=i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;? %d %d\n&quot;,u,v);</span><br><span class="line">            fflush(stdout);</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">            if(w==u||w==v)&#123;</span><br><span class="line">                printf(&quot;! %d\n&quot;,w);</span><br><span class="line">                fflush(stdout);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                vis[u]=-1,vis[v]=-1;//-1表示删除该点</span><br><span class="line">                dfs(u);</span><br><span class="line">                dfs(v);</span><br><span class="line">                u=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(vis[i]&gt;=0)&#123;</span><br><span class="line">                printf(&quot;! %d\n&quot;,i);</span><br><span class="line">                fflush(stdout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。&lt;br&gt;每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>求等差数列的值</title>
    <link href="https://www.dream-ak.top/2020/03/02/%E6%B1%82%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E7%9A%84%E5%80%BC/"/>
    <id>https://www.dream-ak.top/2020/03/02/%E6%B1%82%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E7%9A%84%E5%80%BC/</id>
    <published>2020-03-02T12:09:21.000Z</published>
    <updated>2020-03-02T12:31:39.413Z</updated>
    
    <content type="html"><![CDATA[<p>在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/" target="_blank" rel="noopener">题目链接</a></h1><p>对于这个题目的限制来看，他成功的把迭代方法给禁了！</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>利用公差为1和短路的原理递归答案<br>递归的话，很容易想，唯独就是不允许if来特判结束条件，在这里我们可以看到，最后一个值是0，那么我们就可以发现，</p><blockquote><p>如果为0的话，返回0，<br>不是0的话就继续递归</p></blockquote><p>那么我们就可以看到我们可以用短路，把后面不是0的部分用短路解决！<br>如果前面是0则短路后面部分，让它不运行。否则就运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def sumNums(self, n: int) -&gt; int:</span><br><span class="line">        return n and n+self.sumNums(n-1)</span><br></pre></td></tr></table></figure><br>由于if 和while被禁了。。。快速加无法实现，pow函数与**不知道实现方法就不写了（如果里面有乘法或除法就丢脸了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://www.dream-ak.top/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://www.dream-ak.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java程序基础</title>
    <link href="https://www.dream-ak.top/2020/03/02/java/"/>
    <id>https://www.dream-ak.top/2020/03/02/java/</id>
    <published>2020-03-02T02:28:49.000Z</published>
    <updated>2020-03-02T04:40:25.328Z</updated>
    
    <content type="html"><![CDATA[<p>突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。<br><a id="more"></a></p><h1 id="Java程序基础"><a href="#Java程序基础" class="headerlink" title="Java程序基础"></a>Java程序基础</h1><h2 id="基本单位-Class"><a href="#基本单位-Class" class="headerlink" title="基本单位:Class"></a>基本单位:Class</h2><p>首先对于Java来说他的基本单位是$Class$而不像C语言基本单位是函数！<br>对于每一个类他的定义一般是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Hello&#123;</span><br><span class="line">    public static void main()&#123;//方法名是main()</span><br><span class="line">        system.out.println()//system.out.print+line整行输出的意思</span><br><span class="line">        //单行注释</span><br><span class="line">        /*</span><br><span class="line">        多行注释</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里的public是访问修饰符，表示Class公开</p><h3 id="Class的命名规则"><a href="#Class的命名规则" class="headerlink" title="Class的命名规则"></a>Class的命名规则</h3><p>Class的命名规则与py的Class一样，使用大驼峰规则：</p><blockquote><p>Hello<br>NoteBook<br>VRPlayer</p></blockquote><h3 id="方法的命名规则"><a href="#方法的命名规则" class="headerlink" title="方法的命名规则"></a>方法的命名规则</h3><p>方法名命名规则是小驼峰：</p><blockquote><p>main<br>goodMorning<br>playVR</p></blockquote><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ol><li>直接与C语言相比，Java的int没有变化，long long变成long，用法不变</li><li>java整数运算没有误差，与C语言没有什么变化</li><li>java浮点数运算有误差，在比较的时候需要表示在一个容错值之中！</li><li>java布尔运算的变量名为boolean，且逻辑运算和三元运算符也有相同用法</li><li>java字符中和C语言字符差不多，但是由于用的Unicode编码，所以空间占两个字节，显示Unicode编码直接将char放到int就好了，由编码转Unicode编码则加上’\u’</li><li>java字符串中和py的string用法相似，都是不可变变量且多行输出用法一样system.out.print(“””…”””);</li><li>java数组操作，对于定义一个int[] ns= new int[5]；这样就是定义一个ns数组，可以用ns.length获取数组长度</li></ol><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><ol><li>从数组下标从0到lenth-1挨个访问</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">        for (int i=0; i&lt;ns.length; i++) &#123;</span><br><span class="line">            int n = ns[i];</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>用for each迭代答案</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] ns = &#123; 1, 4, 9, 16, 25 &#125;;</span><br><span class="line">        for (int n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>Arrays.sort(数组名称)按升序排序</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>对于java来说，以main函数为程序入口，main(string[] args)这里的string[]是传入命令行参数的入口<br>来看代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for (String arg : args) &#123;</span><br><span class="line">            if (&quot;-version&quot;.equals(arg)) &#123;</span><br><span class="line">                System.out.println(&quot;v 1.0&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>操作方法：<br>首先我们先编译</p><ol><li>javac 待编译文件</li><li>java 文件名 传入参数</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>两数相加</title>
    <link href="https://www.dream-ak.top/2020/03/01/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>https://www.dream-ak.top/2020/03/01/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</id>
    <published>2020-03-01T03:43:51.000Z</published>
    <updated>2020-03-02T03:48:34.320Z</updated>
    
    <content type="html"><![CDATA[<p>第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！<br><a id="more"></a><br>对于这一题，说实在的没有啥算法可言，就是暴力模拟，我第一次了解py的链表，感觉还是值得一刷，就写了一下，解法就过了，没说的，竖式相加，逢十进位<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># Definition for singly-linked list.定义单链表的意思</span><br><span class="line"># class ListNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.next = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:</span><br><span class="line">        key=0</span><br><span class="line">        pre = ListNode(0)</span><br><span class="line">        ans = pre</span><br><span class="line">        while l1!=None and l2!=None:</span><br><span class="line">           x = ((l1.val+l2.val+key)%10)</span><br><span class="line">           cur = ListNode(x)</span><br><span class="line">           pre.next=cur</span><br><span class="line">           pre=cur</span><br><span class="line">           key = (l1.val+l2.val+key)//10</span><br><span class="line">           l1,l2=l1.next,l2.next</span><br><span class="line">        while(l1!=None):</span><br><span class="line">            x = ((l1.val+key)%10)</span><br><span class="line">            key = (l1.val+key)//10</span><br><span class="line">            cur = ListNode(x)</span><br><span class="line">            pre.next=cur</span><br><span class="line">            pre=cur</span><br><span class="line">            l1=l1.next</span><br><span class="line">        while(l2!=None):</span><br><span class="line">            x = ((l2.val+key)%10)</span><br><span class="line">            key = (l2.val+key)//10</span><br><span class="line">            cur = ListNode(x)</span><br><span class="line">            pre.next=cur</span><br><span class="line">            pre=cur</span><br><span class="line">            l2=l2.next</span><br><span class="line">        if key!=0:</span><br><span class="line">            cur = ListNode(key)</span><br><span class="line">            pre.next=cur</span><br><span class="line">        return ans.next</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="leetcode" scheme="https://www.dream-ak.top/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="https://www.dream-ak.top/2020/02/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>https://www.dream-ak.top/2020/02/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</id>
    <published>2020-02-29T14:22:23.000Z</published>
    <updated>2020-02-29T15:08:11.588Z</updated>
    
    <content type="html"><![CDATA[<p>leetcode计划开始了，以后每天刷1道力扣题打卡，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。<br><a id="more"></a></p><h1 id="第一题：两数之和"><a href="#第一题：两数之和" class="headerlink" title="第一题：两数之和"></a>第一题：两数之和</h1><p>题意：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>对于这个题目，因为简单，所以这里提供的解法有如下几种</p><ol><li>暴力$O(n*n)$<br>每一次枚举一个i然后从i开始往后找另一个值与之相加为x的数字，找到则直接返回下标。</li><li>字典映射<br>对于每一个数字由于只有两个$(x,y)$数字，那么我们假设其中一个数字为$x$，则另一个数字一定是$target-x$<br>通过这个特性，我们可以选择建立一个dict{x:i},x为差值，i为下标，我们每一次假设一个x时则查看前面是否出现过target-x，出现了直接返回就好了，没出现则加入字典。时间复杂度$O(n*log_2n)$字典的查询自带$log_2$<br>32ms<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        num=&#123;&#125;</span><br><span class="line">        pos=0</span><br><span class="line">        for i in nums:</span><br><span class="line">            x = target - i</span><br><span class="line">            if num.get(x,-1)!=-1:</span><br><span class="line">                return [num[x],pos]</span><br><span class="line">            num[i]=pos</span><br><span class="line">            pos+=1</span><br></pre></td></tr></table></figure></li><li>二分<br>建立一个$list$存储大小与下标，然后对大小从小到大排序，接下来用二分查找向后查找$target-x$时间复杂度$n*log_2 n$<br>54ms<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:</span><br><span class="line">        lenth=len(nums)</span><br><span class="line">        a=[[nums[pos],pos] for pos in range(0,lenth,1)]</span><br><span class="line">        b = sorted(a,key=lambda x: x[0])</span><br><span class="line">        for i in range(0,lenth,1):</span><br><span class="line">            x = target-b[i][0]</span><br><span class="line">            l , r = i+1,len(b)-1</span><br><span class="line">            while(l&lt;r):</span><br><span class="line">                mid=(l+r)//2</span><br><span class="line">                if b[mid][0]&gt;=x:</span><br><span class="line">                    r=mid</span><br><span class="line">                elif b[mid][0]&lt;x:</span><br><span class="line">                    l=mid+1</span><br><span class="line">            if b[l][0]==x:</span><br><span class="line">                x = [b[i][1],b[l][1]]</span><br><span class="line">                y=sorted(x)</span><br><span class="line">                return y</span><br></pre></td></tr></table></figure><h2 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h2>对于这一题，我的个人总结是用python实现了一次二分同时学会了排序<br>sorted函数带三个参数：</li><li>要排序数组</li><li>排序方式，是一个函数<br>写法key=一个函数，这里是lambda x:x[0]按照第一个值排序</li><li>reverse反转，让她从小到大与从大到小之间变化</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode计划开始了，以后每天刷1道力扣题打卡，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="https://www.dream-ak.top/categories/leetcode/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>最短路和次短路的数量</title>
    <link href="https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/"/>
    <id>https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/</id>
    <published>2020-02-29T09:54:30.000Z</published>
    <updated>2020-03-02T04:40:41.801Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=3463" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少<a id="more"></a></p><h2 id="思想和解法"><a href="#思想和解法" class="headerlink" title="思想和解法"></a>思想和解法</h2><p>首先看到这个题目，我们第一时间就会想到最短路径数量，直接就暴力跑迪杰斯特拉然后统计一下就完事了，最多加个次短路而已，我们就按照次短路生成的方式，跑迪杰斯特拉，然后记录到达每个点的最短路数量和次短路数量。</p><ol><li>优化最短路时就把当前次短路的数量赋值给最短路，</li><li>通过次短路优化次短路时就把前一个点的次短路数量赋值给下一个点的数量</li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>想法很简单，但是这题如果大量使用空间则会爆优先队列，因此我们要注意对优先队列进行节省空间，对于每一个点能让它少入队，则少让他入队。<br>把优化最短路时最短路和次短路的这两次入队归为一次，就会节省很多空间！所以写法再次修改为如下，分为4个步骤：</p><ol><li>优化最短路</li><li>等于最短路</li><li>优化次短路</li><li>等于次短路<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],dis[N],dis2[N],tot=0,num1[N],num2[N];</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(head,-1,sizeof head);</span><br><span class="line">    memset(dis,0x3f,sizeof dis);</span><br><span class="line">    memset(dis2,0x3f,sizeof dis2);</span><br><span class="line">    memset(num1,0,sizeof num1);</span><br><span class="line">    memset(num2,0,sizeof num2);</span><br><span class="line">    tot=2;</span><br><span class="line">&#125;</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">    ed[++tot].id=v;</span><br><span class="line">    ed[tot].pre=head[u];</span><br><span class="line">    ed[tot].w=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">void dij(int x)&#123;</span><br><span class="line">    dis[x]=0;</span><br><span class="line">    num1[x]=1;</span><br><span class="line">    q.push(make_pair(0,x));</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int x=q.top().second,w = -q.top().first;</span><br><span class="line">        //printf(&quot;%d %d\n&quot;,x,w);</span><br><span class="line">        q.pop();</span><br><span class="line">        int cnt;</span><br><span class="line">        if(w&gt;dis2[x]) continue;</span><br><span class="line">        if(w == dis[x]) cnt=num1[x];</span><br><span class="line">        else if(w==dis2[x]) cnt=num2[x];</span><br><span class="line">        for(int i=head[x];~i;i=ed[i].pre)&#123;</span><br><span class="line">            int v = ed[i].id,s=ed[i].w;</span><br><span class="line">            int cost = w + s,d=cnt;</span><br><span class="line">            if(dis[v]&gt;cost)&#123;</span><br><span class="line">                dis2[v]=dis[v];</span><br><span class="line">                num2[v]=num1[v];</span><br><span class="line">                dis[v]=cost;</span><br><span class="line">                num1[v]=d;</span><br><span class="line">                //swap(dis[v],cost);</span><br><span class="line">                //swap(d,num1[v]);</span><br><span class="line">                q.push(make_pair(-dis[v],v));</span><br><span class="line">                //printf(&quot;%d %d sss\n&quot;,v,num1[v]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(dis[v]==cost)&#123;</span><br><span class="line">                num1[v]+=d;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(dis2[v]==cost)&#123;</span><br><span class="line">                num2[v]+=d;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(dis2[v]&gt;cost)&#123;</span><br><span class="line">                dis2[v]=cost;</span><br><span class="line">                num2[v]=d;</span><br><span class="line">                q.push(make_pair(-cost,v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k,t;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;t)==1)&#123;</span><br><span class="line">        while(t--)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">            init();</span><br><span class="line">            for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                int u,v,w;</span><br><span class="line">                scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">                add(u,v,w);</span><br><span class="line">            &#125;</span><br><span class="line">            int p,q;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;p,&amp;q);</span><br><span class="line">            dij(p);</span><br><span class="line">            int ans=num1[q];</span><br><span class="line">            if(dis[q]==dis2[q]-1) ans+=num2[q];</span><br><span class="line">            printf(&quot;%d\n&quot;,ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://poj.org/problem?id=3463&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h2&gt;&lt;p&gt;给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>poj3694-tarjan</title>
    <link href="https://www.dream-ak.top/2020/02/29/poj3694-tarjan/"/>
    <id>https://www.dream-ak.top/2020/02/29/poj3694-tarjan/</id>
    <published>2020-02-29T09:28:47.000Z</published>
    <updated>2020-03-02T03:55:29.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=3694" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个连通图，问每一次加边以后还有多少条桥！<a id="more"></a></p><h2 id="思想和解法"><a href="#思想和解法" class="headerlink" title="思想和解法"></a>思想和解法</h2><p>很明显把连通图缩点成$DAG$图，(对DAG图操作)然后每一次加边后$DAG$图里强连通分量继续缩点！桥的数量就是加边前的数量减去缩掉的边的数量。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="问题1：缩点"><a href="#问题1：缩点" class="headerlink" title="问题1：缩点"></a>问题1：缩点</h3><p>想法很简单，操作异想天开，如果用染色法对图进行缩点，最坏情况就是一棵N个结点的树，N-1条边每一次添加一条邻边，复杂度卡到$(1+n)* \frac{n}{2}$。所以采用并查集动态缩点！</p><h3 id="问题2：路径"><a href="#问题2：路径" class="headerlink" title="问题2：路径"></a>问题2：路径</h3><p>路径寻找也是一个问题，我们已经$tarjan$缩过一次点了，我们接下来是新建一个图继续跑$tarjan$离线$LCA$吗？<br>注意对于tarjan的LCA算法精髓在于哪里？他那么写的原因是经过了tarjan算法以后每个节点其实都有一个时间戳！而两个点$<u,v>$之间的$LCA$他们有一个共同的特点，那就是:</u,v></p><blockquote><p>$LCA$的左子树上的所有点的时间戳都小于右子树的时间戳！</p></blockquote><p>根据这个特点我们可以直接用记录当前点的父节点然后爬到$LCA$上去。<br>看下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void lca(int x,int y)&#123;</span><br><span class="line">    if(dfn[x]&lt;dfn[y]) swap(x,y);</span><br><span class="line">    if(get(x)==get(y)) return ;</span><br><span class="line">    while(dfn[x]&gt;dfn[y])&#123;</span><br><span class="line">        if(join(x,pre[x])) edge--;//缩点成功则桥减一</span><br><span class="line">        x=get(pre[x]);//爬向缩点后的父节点</span><br><span class="line">    &#125;</span><br><span class="line">    while(x!=y)&#123;</span><br><span class="line">        if(join(y,pre[y])) edge--;//缩点成功则桥减一</span><br><span class="line">        y=get(pre[y]);//爬向缩点后的父节点</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>282ms<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],pre[N],fa[N],dfn[N],low[N],sta[N];</span><br><span class="line">int tot=0,edge=0,tim=0;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">int vis[N];</span><br><span class="line">int get(int x)&#123;</span><br><span class="line">    if(fa[x]!=x) return fa[x]=get(fa[x]);</span><br><span class="line">    else return x;</span><br><span class="line">&#125;</span><br><span class="line">bool join(int x,int y</span><br><span class="line">)&#123;</span><br><span class="line">    int p=get(x),q=get(y);</span><br><span class="line">    if(p!=q)&#123;</span><br><span class="line">        fa[p]=q;//指向父节点</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line">int num=1;</span><br><span class="line">void tarjan(int x,int fath)&#123;</span><br><span class="line">    low[x]=dfn[x]=++tim;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    int flag=1;</span><br><span class="line">    for(int i=head[x];~i;i=ed[i].pre)&#123;</span><br><span class="line">        int v=ed[i].id;</span><br><span class="line">        if(v==fath&amp;&amp;flag) &#123;flag=0;continue;&#125;</span><br><span class="line">        if(!vis[v])&#123;</span><br><span class="line">            pre[v]=x;</span><br><span class="line">            tarjan(v,x);</span><br><span class="line">            low[x]=min(low[v],low[x]);</span><br><span class="line">            if(low[v]&gt;dfn[x])&#123;</span><br><span class="line">                edge++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                join(v,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void lca(int x,int y)&#123;</span><br><span class="line">    if(dfn[x]&lt;dfn[y]) swap(x,y);</span><br><span class="line">    if(get(x)==get(y)) return ;</span><br><span class="line">    while(dfn[x]&gt;dfn[y])&#123;</span><br><span class="line">        if(join(x,pre[x])) edge--;</span><br><span class="line">        x=get(pre[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    while(x!=y)&#123;</span><br><span class="line">        if(join(y,pre[y])) edge--;</span><br><span class="line">        y=get(pre[y]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">        for(i=1;i&lt;=n;i++) head[i]=-1,vis[i]=0,dfn[i]=0;</span><br><span class="line">        tim=edge=tot=0;</span><br><span class="line">        int u,v;</span><br><span class="line">        for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            add(u,v);</span><br><span class="line">            add(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(1,1);</span><br><span class="line">        pre[1]=1;</span><br><span class="line">        int q;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        printf(&quot;Case %d:\n&quot;,num++);</span><br><span class="line">        for(i=1;i&lt;=q;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            lca(u,v);</span><br><span class="line">            printf(&quot;%d\n&quot;,edge);</span><br><span class="line">        &#125;</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://poj.org/problem?id=3694&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题意&lt;/h2&gt;&lt;p&gt;给一个连通图，问每一次加边以后还有多少条桥！&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>poj2763,tarjan</title>
    <link href="https://www.dream-ak.top/2020/02/29/poj2763-tarjan/"/>
    <id>https://www.dream-ak.top/2020/02/29/poj2763-tarjan/</id>
    <published>2020-02-29T08:44:56.000Z</published>
    <updated>2020-02-29T09:26:55.068Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=3728" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问<a id="more"></a></p><h2 id="思想与解法"><a href="#思想与解法" class="headerlink" title="思想与解法"></a>思想与解法</h2><ol><li>首先最暴力的想法就是去找到路径然后判断，找路径的办法就是先找到$LCA$然后暴力就完事了，很明显时间复杂度$O(N*Q)$绝对$tle$</li><li>我们思考得到最大利润的方式，首先对于$u \rightarrow v$可以分解为$u \rightarrow LCA \rightarrow v$<br>那么最大利润将会如下三条路径中产生：<br>1.$u \rightarrow LCA$<br>2.$LCA \rightarrow v$<br>3.$u \rightarrow v$<br>这时候可能有很多人会想为什么要把路径3分为路径1与路径2，明显路径3包含1和2啊。<blockquote><p>在这里解释一下，如果只观察路径3的话，那么答案就是路径上最大的权值减最小权值，但是，无法记录访问顺序！但是这样分开以后以LCA为参考，获得每个点到$LCA$路径的最大利润，如果$u \rightarrow v$的最大利润不在点到$LCA$的路径而是穿过路径的时，那么商人一定在$u \rightarrow LCA$进货，在$LCA \rightarrow v$出售。直接记录两个路径中的最大最小值然后计算就好了</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>根据分析我们需要四个数组！一个储存路径1的最大利润$up$，一个储存路径2的最大利润$down$，第三个储存路径的最大值$ma$，第四个存储最小值$mi$。然后并查集，把每一个点并到$LCA$上并更新所有数据。最后统计答案，据说卡vector。。<br>并查集的合并操作</p></blockquote></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int get(int x)&#123;</span><br><span class="line">    if(fa[x]==x) return x;</span><br><span class="line">    int root = fa[x];</span><br><span class="line">    fa[x]=get(fa[x]);</span><br><span class="line">    up[x]=max(up[x],max(up[root],ma[root]-mi[x]));</span><br><span class="line">    down[x]=max(down[x],max(down[root],ma[x]-mi[root]));</span><br><span class="line">    mi[x]=min(mi[x],mi[root]);</span><br><span class="line">    ma[x]=max(ma[x],ma[root]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卡vector我们就是用链式前向星寸询问，继而离线！$add1$函数<br>由于我们要在合并完以后才能得到答案，所以我的办法是每一次计算完$LCA$，用链式前向星保存在$LCA上(add2)！$访问到时在计算ans。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 3e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N],ed1[N];</span><br><span class="line">int head[N],head1[N],tot,tot1,ans[N],fa[N],ma[N],mi[N],vis[N],up[N],down[N],head2[N],tot2=1;</span><br><span class="line">struct NUM&#123;</span><br><span class="line">    int x,y,id,pre;</span><br><span class="line">&#125;num[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void add1(int u,int v)&#123;</span><br><span class="line">    ed1[++tot1].pre=head1[u];</span><br><span class="line">    ed1[tot1].id=v;</span><br><span class="line">    head1[u]=tot1;</span><br><span class="line">&#125;</span><br><span class="line">void add2(int u,int x,int y,int id)&#123;</span><br><span class="line">    num[++tot2].id=id;</span><br><span class="line">    num[tot2].x=x,num[tot2].y=y;</span><br><span class="line">    num[tot2].pre=head2[u];</span><br><span class="line">    head2[u]=tot2;</span><br><span class="line">&#125;</span><br><span class="line">int get(int x)&#123;</span><br><span class="line">    if(fa[x]==x) return x;</span><br><span class="line">    int root = fa[x];</span><br><span class="line">    fa[x]=get(fa[x]);</span><br><span class="line">    up[x]=max(up[x],max(up[root],ma[root]-mi[x]));</span><br><span class="line">    down[x]=max(down[x],max(down[root],ma[x]-mi[root]));</span><br><span class="line">    mi[x]=min(mi[x],mi[root]);</span><br><span class="line">    ma[x]=max(ma[x],ma[root]);</span><br><span class="line">    return fa[x];</span><br><span class="line">&#125;</span><br><span class="line">void LCA(int x)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    int i;</span><br><span class="line">    for(i=head[x];~i;i=ed[i].pre)&#123;</span><br><span class="line">        int v=ed[i].id;</span><br><span class="line">        if(vis[v]) continue;</span><br><span class="line">        else &#123;</span><br><span class="line">            LCA(v);</span><br><span class="line">            fa[v]=x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=head1[x];~i;i=ed1[i].pre)&#123;</span><br><span class="line">        int v=ed1[i].id;</span><br><span class="line">        if(vis[v]) &#123;</span><br><span class="line">            add2(get(v),x,v,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=head2[x];~i;i=num[i].pre)&#123;</span><br><span class="line">        int u = num[i].x,v=num[i].y,d=num[i].id;</span><br><span class="line">        get(u),get(v);</span><br><span class="line">        if(d%2)&#123;</span><br><span class="line">            ans[d]=ans[d^1]=max(up[v],max(down[u],ma[u]-mi[v]));</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            ans[d]=ans[d^1]=max(down[v],max(up[u],ma[v]-mi[u]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    memset(head,-1,sizeof head);</span><br><span class="line">    memset(head1,-1,sizeof head1);</span><br><span class="line">    memset(head2,-1,sizeof head2);</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    tot=tot1=tot2=1;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)==1)&#123;</span><br><span class="line">        int u,v,w;</span><br><span class="line">        init();</span><br><span class="line">        for(i=1;i&lt;=n;i++) fa[i]=i;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;w);</span><br><span class="line">            down[i]=up[i]=0;</span><br><span class="line">            ma[i]=mi[i]=w;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=1;i&lt;n;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            add(u,v);</span><br><span class="line">            add(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        int q;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;q);</span><br><span class="line">        for(i=1;i&lt;=q;i++)&#123;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">            add1(u,v);</span><br><span class="line">            add1(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        LCA(1);</span><br><span class="line">        for(i=2;i&lt;=2*q;i+=2)&#123;</span><br><span class="line">            printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>完美的考察对于并查集，$tarjan$的理解，对于扩展域的使用在这里像极了$dp$，也让我发现自己对于tarjan的不足。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题目链接&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://poj.org/problem?id=3728&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h2&gt;&lt;p&gt;给定一个N个节点的树，1&amp;lt;=N&amp;lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>强连通分量</title>
    <link href="https://www.dream-ak.top/2020/02/28/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>https://www.dream-ak.top/2020/02/28/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</id>
    <published>2020-02-28T15:36:16.000Z</published>
    <updated>2020-02-28T15:59:21.225Z</updated>
    
    <content type="html"><![CDATA[<p>强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。<a id="more"></a></p><h1 id="tarjan算法"><a href="#tarjan算法" class="headerlink" title="tarjan算法"></a>tarjan算法</h1><p>这个算法十分强大，广泛应用于$LCA$，强连通缩点等问题，他的主要思想是给每一个点打上一个时间戳，然后$dfs$去寻找每一个点$u$所能回到的最小时间戳$v$，在这个区间$<u,v>$内的点是一个连通分量，然后进行缩点，这里的缩点有两种方式。</u,v></p><ol><li>通过数组映射缩点，同一个连通分量映射同一个值</li><li>并查集缩点，同一个连通分量指向同一个根</li></ol><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><p>hdu1239<br>求加多少条边使整个图变为强连通图</p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先缩点，把图变成DAG图以后去看如何加最少的边使图变为强连通！<br>很明显，对于入度为0的点必须加一条边使他能到达，出度为0的边也要加边使得到了他的边能回去，要加的最少的边就是$max(入度为0,出度为0)$；</p><h2 id="题解代码"><a href="#题解代码" class="headerlink" title="题解代码"></a>题解代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N =2e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N*2];</span><br><span class="line">int head[N],tot=1;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">int dfn[N],low[N],vis[N],dfp,sta[N],cnt=0,siz=0,col[N],in[N],out[N];</span><br><span class="line">void tarjan(int x)&#123;</span><br><span class="line">    dfn[x]=++dfp;</span><br><span class="line">    low[x]=dfp;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    sta[++cnt]=x;</span><br><span class="line">    for(int i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        int u=ed[i].id;</span><br><span class="line">        if(!dfn[u])&#123;</span><br><span class="line">            tarjan(u);</span><br><span class="line">            low[x]=min(low[u],low[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[u])&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[u]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x]==low[x])&#123;</span><br><span class="line">        col[x]=++siz;</span><br><span class="line">        vis[x]=0;</span><br><span class="line">        while(sta[cnt]!=x)&#123;</span><br><span class="line">            vis[sta[cnt]]=0;</span><br><span class="line">            col[sta[cnt--]]=siz;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k,t;</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;t)==1)&#123;</span><br><span class="line">        while(t--)&#123;</span><br><span class="line">            tot=1;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">            memset(head,0,sizeof head);</span><br><span class="line">            memset(dfn,0,sizeof dfn);</span><br><span class="line">            memset(in,0,sizeof in);</span><br><span class="line">            memset(out,0,sizeof out);</span><br><span class="line">            memset(low,0,sizeof low);</span><br><span class="line">            memset(col,0,sizeof col);</span><br><span class="line">            for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">                int u,v;</span><br><span class="line">                scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">                add(u,v);</span><br><span class="line">            &#125;</span><br><span class="line">            dfp=0,cnt=0,siz=0;</span><br><span class="line">            for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                if(dfn[i]==0)&#123;</span><br><span class="line">                    tarjan(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">                for(j=head[i];j;j=ed[j].pre)&#123;</span><br><span class="line">                    if(col[i]!=col[ed[j].id])&#123;</span><br><span class="line">                        out[col[i]]++;</span><br><span class="line">                        in[col[ed[j].id]]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            int ans1=0,ans2=0;</span><br><span class="line">            for(i=1;i&lt;=siz;i++)&#123;</span><br><span class="line">                if(in[i]==0) ans1++;</span><br><span class="line">                if(out[i]==0) ans2++;</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;%d\n&quot;,max(ans1,ans2)==1?0:max(ans1,ans2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于$tarjan$应该灵活使用并查集对其进行各种点集的合并。<br>对于$DAG$来说我们要注意的是要实现强连通只需要计算$max$(出度0，入度0)；<br>关于tarjan的题目之后还会找几个好题再写几次。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>分层图和次短路</title>
    <link href="https://www.dream-ak.top/2020/02/16/%E5%88%86%E5%B1%82%E5%9B%BE%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF/"/>
    <id>https://www.dream-ak.top/2020/02/16/%E5%88%86%E5%B1%82%E5%9B%BE%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF/</id>
    <published>2020-02-16T14:34:03.000Z</published>
    <updated>2020-02-22T13:30:33.690Z</updated>
    
    <content type="html"><![CDATA[<p>搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。<br><a id="more"></a></p><h1 id="分层图"><a href="#分层图" class="headerlink" title="分层图"></a>分层图</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>分层图是一个最短路的应用，他一般用来计算在一个连通图里面在可以省K条路的情况下，我们能从S到T的最短距离！<br>做法有两种：</p><ol><li>dp</li><li>建分层图</li></ol><p>在这里我只介绍做法2</p><h2 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h2><p>我们建立k层图，两层图之间的边免费，图里面的连通情况一致。<br>解释一下：<br>对于k层图，如果由S走到T的话，不管是到达哪一个点，他最多经过K次免费！在这个图上面跑迪杰斯特拉，最后找最小值就好了</p><p>讲的抽象，在这里我推荐<a href="https://blog.csdn.net/qq_40736036/article/details/85041838" target="_blank" rel="noopener">推荐一篇博客</a></p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>空间占用太大，跑了两个题目差不多都是$40M$左右，dp版本会低一些，但时间复杂度不变。<br>计算边的数组大小：</p><blockquote><p>一条边要往连向下一层图同时还要连向本层图，所以一条边实际上要有$(k*2)$条边</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://www.luogu.org/problemnew/show/P4568" target="_blank" rel="noopener">题目地址</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int N = 5e5+5;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[N*10];</span><br><span class="line">int head[N],tot=1,dis[N];</span><br><span class="line">bool vis[N];</span><br><span class="line">int s,t;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    ed[tot].w=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dij()&#123;</span><br><span class="line">    memset(dis,0x3f,sizeof dis);</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    dis[s]=0;</span><br><span class="line">    q.push(make_pair(0,s));</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int u=q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[u]) continue;</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        //printf(&quot;%dsss\n&quot;,u);</span><br><span class="line">        for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">            int v=ed[i].id,w=ed[i].w;</span><br><span class="line">            //printf(&quot;%d %d\n&quot;,u,v);</span><br><span class="line">            if(dis[v]&gt;dis[u]+w)&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                q.push(make_pair(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k)==3)&#123;</span><br><span class="line">        s=1,t=n;</span><br><span class="line">        for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            int u,v,w;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">            for(j=1;j&lt;=k;j++)&#123;</span><br><span class="line">                add(u+j*n,v+j*n,w);</span><br><span class="line">                add(v+j*n,u+j*n,w);</span><br><span class="line">                add(u+j*n-n,v+j*n,0);</span><br><span class="line">                add(v+j*n-n,u+j*n,0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dij();</span><br><span class="line">        int ans=2e9+9;</span><br><span class="line">        for(i=0;i&lt;=k;i++)&#123;</span><br><span class="line">            ans=min(ans,dis[t+i*n]);</span><br><span class="line">            //printf(&quot;%d\n&quot;,dis[t+i*n]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="次短路"><a href="#次短路" class="headerlink" title="次短路"></a>次短路</h1><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ol><li>通过最短路来求</li><li>通过K短路来求</li></ol><p>在这里我只讲通过最短路来求得解法<br>我们得到次短路的过程分为两种</p><ol><li>最短路更新得来得来,在更新dis[u]时，原来的$dis[u]$将会是次短路</li><li>次短路自身延申得来,在次短路$dis2[u]+min(u \rightarrow v)$,借此更新最短路</li></ol><p>对于这两种情况来看，1与最短路有关，2的更新方式也与迪杰斯特拉很像！所以我们这里就直接跑最短路！用优先队列维护两条路径，最短路和次短路，每一次取里面最短的。<strong>无论是最短路上的点，还是次短路上的点，因为次短路影响不了最短路，而最短路影响次短路本身就是需要的</strong></p><h2 id="题目：POJ3255"><a href="#题目：POJ3255" class="headerlink" title="题目：POJ3255"></a>题目：POJ3255</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">struct ED</span><br><span class="line">&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot=1,dis[N],dis2[N],n,m;</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    ed[tot].w=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dij(int x)&#123;</span><br><span class="line">    memset(dis,0x3f,sizeof dis);</span><br><span class="line">    memset(dis2,0x3f,sizeof dis2);</span><br><span class="line">    dis[x]=0;</span><br><span class="line">    q.push(make_pair(-dis[x],x));</span><br><span class="line">    while(q.size())&#123;</span><br><span class="line">        int u=q.top().second,w=-q.top().first;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(dis2[u]&lt;w) continue;//这里是剪枝，看注释一。</span><br><span class="line">        for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">            int v=ed[i].id,d=w+ed[i].w;</span><br><span class="line">            if(d&lt;dis[v])&#123;</span><br><span class="line">                swap(d,dis[v]);//这里只能是交换，因为dis[v]还要给次短路用</span><br><span class="line">                q.push(make_pair(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">            if(d&lt;dis2[v]&amp;&amp;d&gt;dis[v])&#123;</span><br><span class="line">                dis2[v]=d;</span><br><span class="line">                q.push(make_pair(-dis2[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,dis2[n]);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int i,j,k;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123;</span><br><span class="line">        memset(head,0,sizeof head);</span><br><span class="line">        for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">            int u,v,w;</span><br><span class="line">            scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">            add(u,v,w);</span><br><span class="line">            add(v,u,w);</span><br><span class="line">        &#125;</span><br><span class="line">        dij(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注释一：因为对于次短路的更新，我们会在优先队列里面增加一些无用边，就像最短路时的vis数组一样的性质，把那些多余的边全部去掉，而这里只需要路径长度小于等于次短路的，所以大于的直接continue！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>双调欧几里得旅行商问题</title>
    <link href="https://www.dream-ak.top/2020/02/11/%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <id>https://www.dream-ak.top/2020/02/11/%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-11T15:37:49.000Z</published>
    <updated>2020-02-12T05:31:41.933Z</updated>
    
    <content type="html"><![CDATA[<p>刷最短路刷着刷着怎么老遇神题，太玄学了，tcl<a id="more"></a></p><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2224" target="_blank" rel="noopener">题目链接</a></h2><p>题意，给予n个点的坐标，要求从第1个点走到第n个点然后再走回来且去的时候点的序号单调递增，回来的时候单调递减！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><del>说句实在的我第一眼居然是弗洛伊德然后掉坑底怕都没爬出来</del>。<br>正解是$dp$,怎么$dp$呢</p><ol><li>我们假设$dp[i][j]$中$i$为从第i个点回到1号点，$j$为从1号点回到$j$号点，而$dp[i][j]$则是这个过程的最短距离。</li><li>按着这个定义来看，$dp[i][j]=dp[j][i]$。解释一下：我们对于这个问题来说$i \rightarrow 1 \rightarrow j \Leftrightarrow j \rightarrow 1 \rightarrow i$</li><li>那么首先假设$i&lt;j$的dp方程：<blockquote><ol><li>$i=j$  时则有$dp[i][j]=dp[i-1][j]+dis(i-1,j)$<br>解释：<script type="math/tex">i \rightarrow 1 \rightarrow j \Leftrightarrow i \rightarrow (i-1) \rightarrow 1 \rightarrow j</script></li><li>$i+1 &lt; j $时，则有$dp[i][j]=dp[i][j-1]$<br>解释：<script type="math/tex">i < j(i只能连小于i的边) \Rightarrow (j-1) \rightarrow j</script></li><li>$i+1=j$则$dp[i][j]=min(dp[i][j],dp[k][j-1]+dis(k,j))(k=1,2···,j-2 $<br>解释：因为这个时候就是相当于在路径$k \rightarrow 1 \rightarrow i$中加一条边$j\rightarrow k$则会得到$j\rightarrow 1 \rightarrow i$<br>且$k!=j-1$因为$(j-1) \rightarrow 1 \rightarrow (j-1) \rightarrow j$一定不会是最短路径，因为$j-1$点重复一次的话，假设是$x \rightarrow j-1 \rightarrow j$的长度按照三角形边长来看会发现$x\rightarrow j$的边长一定小于等于前一条边。</li></ol></blockquote></li></ol><p>由上三种状态可以发现我们要得到$dp[i][j]$首先就要知道$dp[i][j-1]$和$dp[i-1][j]$那么我们可以先对$j$进行遍历得到$dp[i][j-1]$，然后再从小到大遍历$i$就会得到$dp[i][j]$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 300;</span><br><span class="line">double dp[N][N];</span><br><span class="line">struct ed&#123;</span><br><span class="line">    double x,y;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line">double dis(int i,int j)&#123;</span><br><span class="line">    return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    while (scanf(&quot;%d&quot;,&amp;n)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            scanf(&quot;%lf %lf&quot;,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[1][2]=dis(1,2);</span><br><span class="line">        for(j=3;j&lt;=n;j++)&#123;</span><br><span class="line">            for(i=1;i&lt;j-1;i++) dp[i][j]=dp[i][j-1]+dis(j,j-1);</span><br><span class="line">            dp[j-1][j]=2e9+9;</span><br><span class="line">            for(i=1;i&lt;j-1;i++) dp[j-1][j]=min(dp[j-1][j],dp[i][j-1]+dis(i,j));</span><br><span class="line">            dp[j][j]=dp[j-1][j]+dis(j-1,j);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%.2lf\n&quot;,dp[n][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;刷最短路刷着刷着怎么老遇神题，太玄学了，tcl&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>差分约束系统复习</title>
    <link href="https://www.dream-ak.top/2020/02/09/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.dream-ak.top/2020/02/09/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-02-09T15:08:02.000Z</published>
    <updated>2020-02-10T03:34:32.817Z</updated>
    
    <content type="html"><![CDATA[<ol><li>spfa对于模拟队列时，队列数组要开的尽量大！</li><li>spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。<a id="more"></a>来个板子：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bool spfa(int t)&#123;</span><br><span class="line">    int l=1,r=0;</span><br><span class="line">    que[++r]=0;</span><br><span class="line">    dis[0]=0;</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int u=que[l++];</span><br><span class="line">        int i;</span><br><span class="line">        vis[u]=0;</span><br><span class="line">        for(i=head[u];~i;i=ed[i].pre)&#123;</span><br><span class="line">            int v=ed[i].id,w=ed[i].w;</span><br><span class="line">            if(dis[u]+w&gt;=dis[v])&#123;</span><br><span class="line">                dis[v]=dis[u]+w;</span><br><span class="line">                if(num[v]&gt;t) return false;</span><br><span class="line">                if(vis[v]==0) que[++r]=v,vis[v]=1,num[v]++;//(num在这里重点注意);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;spfa对于模拟队列时，队列数组要开的尽量大！&lt;/li&gt;
&lt;li&gt;spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>扩展域</title>
    <link href="https://www.dream-ak.top/2020/02/09/%E6%89%A9%E5%B1%95%E5%9F%9F/"/>
    <id>https://www.dream-ak.top/2020/02/09/%E6%89%A9%E5%B1%95%E5%9F%9F/</id>
    <published>2020-02-09T11:07:38.000Z</published>
    <updated>2020-02-10T03:34:07.113Z</updated>
    
    <content type="html"><![CDATA[<p>看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！<br><a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="http://poj.org/problem?id=1733" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>题意明显就是给$[l,r]$中有奇数个1还是偶数个1，然后看它第一次在哪里自相矛盾了，输出第一次自相矛盾的位置！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>首先离散化</strong>这个我就不说了，你们百度一下什么原理。<br>假设$[l,r]$中奇数个1表示为1，偶数个1表示为0。那么我们每一次合并$(l-1,r]$这个区间，这样就可以把所有数据都联系起来。<br>合并并查集：<br>如何合并？我们<br>那么我们就可以通过</p><ol><li>$x \rightarrow root1$(根节点)的值$d[x]$</li><li>$y \rightarrow root2$(根节点)的值$d[y]$</li></ol><p>得出$root1 \rightarrow root2$的值。<br>假设$root1$和$root2$相同则判断一下去看这组数据是否正确。<br>判断方法：</p><blockquote><p>$x \rightarrow root1 = d[x]$<br>  $y \rightarrow root1 = d[y]$<br>  $x \rightarrow y = x \rightarrow root1 \rightarrow y = d[x]$^$d[y]$</p></blockquote><p>不同则是：</p><blockquote><p>$root1 \rightarrow root2$的值是 $d[x]$ ^ $d[y]$ ^ $n$（$n$为$x \rightarrow y$）这个就会得到关系的值</p><p>解释<br>$x \rightarrow y = n$<br>$x \rightarrow root1 = d[x]$<br>$y \rightarrow root2 = d[y]$<br>则$root1 \rightarrow root2 = root1 \rightarrow x \rightarrow y\rightarrow root2 = d[x]$ ^ $d[y]$ ^ $n$</p></blockquote><p>怎么压缩路径</p><blockquote><p>$x \rightarrow y = d[x]$<br>$y \rightarrow root = d[y]$<br>那么 $x \rightarrow root = d[x]$^$d[y]$</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 5e3+5;</span><br><span class="line">int fa[2*N],d[2*N];</span><br><span class="line">int get(int x)</span><br><span class="line">&#123;</span><br><span class="line">    if(fa[x]==x)</span><br><span class="line">        return x;</span><br><span class="line">    int root = get(fa[x]);</span><br><span class="line">    d[x]^=d[fa[x]];</span><br><span class="line">    return fa[x] = root;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int l[N],r[N],c[N],a[N*2],b[N*2];</span><br><span class="line">    char s[5];</span><br><span class="line">    int cnt=0;</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d %d %s&quot;,&amp;l[i],&amp;r[i],s);</span><br><span class="line">        if(s[0]==&apos;o&apos;)</span><br><span class="line">            c[i]=1;</span><br><span class="line">        else</span><br><span class="line">            c[i]=0;</span><br><span class="line">        a[++cnt]=--l[i],a[++cnt]=r[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+1+cnt);</span><br><span class="line">    int cnt1=0;</span><br><span class="line">    for(i=1; i&lt;=cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(i==1||a[i]!=a[i-1])</span><br><span class="line">            b[++cnt1]=a[i];</span><br><span class="line">    &#125;//离散化操作，我就不说了</span><br><span class="line">    for(i=0; i&lt;=cnt1; i++)</span><br><span class="line">        fa[i]=i,d[i]=0;//初始化操作</span><br><span class="line">    for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int l1=lower_bound(b+1,b+1+cnt1,l[i])-b;</span><br><span class="line">        int r1=lower_bound(b+1,b+1+cnt1,r[i])-b;</span><br><span class="line">        int fl=get(l1),fr=get(r1);</span><br><span class="line">        if(fl!=fr)//不在同一个集合，不会冲突</span><br><span class="line">        &#123;</span><br><span class="line">            fa[fr]=fl;</span><br><span class="line">            d[fr]=c[i]^d[r1]^d[l1];</span><br><span class="line">        &#125;</span><br><span class="line">        else//在同一个集合，可能冲突！</span><br><span class="line">        &#123;</span><br><span class="line">            if(d[r1]^d[l1]!=c[i])</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%d\n&quot;,i-1);</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,n);//如果全部没错，就输出最后一个答案</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
</feed>
