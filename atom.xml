<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>添砖Java</title>
  
  <subtitle>屡败屡战，终有一胜！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.dream-ak.top/"/>
  <updated>2020-08-06T14:45:28.112Z</updated>
  <id>https://www.dream-ak.top/</id>
  
  <author>
    <name>无向秃</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杭电2020第一场补题</title>
    <link href="https://www.dream-ak.top/2020/07/31/%E6%9D%AD%E7%94%B52020%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98/"/>
    <id>https://www.dream-ak.top/2020/07/31/%E6%9D%AD%E7%94%B52020%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98/</id>
    <published>2020-07-31T03:44:30.000Z</published>
    <updated>2020-08-06T14:45:28.112Z</updated>
    
    <content type="html"><![CDATA[<p>身体不适，这个暑假补题怕是只能尽量了。<a id="more"></a></p><h1 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h1><h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><ol><li>二次剩余，对于$\sqrt5$去进行取模时对$\sqrt5$实数化。</li><li>欧拉降幂($a^b \equiv a^{b\%(mod-1)}\%mod$)</li><li>斐波拉契通项式：$F(n) = \frac{1}{\sqrt5}* (\frac{1+\sqrt5}{2}-\frac{1-\sqrt5}{2})$</li></ol><p>由于这题的化简过程有点复杂，字有点丑，就不发截图了。直接上的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">const int mod = 1e9+9;</span><br><span class="line">const int sqr_5 = 383008016;</span><br><span class="line">const int A = 691504013;//(1+sqr_5)*inv(2)</span><br><span class="line">const int B = 308495997;//(1-sqr_5)*inv(2)</span><br><span class="line">const int A1 = 276601605;//inv(sqr_5)</span><br><span class="line">int noc[N],inoc[N],cura[N],curb[N];</span><br><span class="line">int qpow(int a,int b)&#123;</span><br><span class="line">    int tmp = a,ans = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans = 1ll*ans*tmp%mod; </span><br><span class="line">        &#125;</span><br><span class="line">        tmp=1ll*tmp*tmp%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans%mod;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    noc[0]=1,inoc[0]=1;//noc是阶乘，inoc是结成的逆元。</span><br><span class="line">    int i;</span><br><span class="line">    rep(i,1,N-1)&#123;</span><br><span class="line">        noc[i]=(1ll*noc[i-1]*i)%mod;</span><br><span class="line">        inoc[i]=qpow(noc[i],mod-2)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Com(int n,int m)&#123;</span><br><span class="line">    if(m&gt;n) return 0;</span><br><span class="line">    return (1ll*noc[n]*inoc[m]%mod*inoc[n-m]%mod)%mod;  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,i,j,t=0,k;</span><br><span class="line">    ll n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    init();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld %lld %d&quot;,&amp;n,&amp;c,&amp;k);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int a=qpow(A,c%(mod-1)),b=qpow(B,c%(mod-1));//欧拉降幂</span><br><span class="line">        //printf(&quot;%d %d\n&quot;,a,b);</span><br><span class="line">        cura[0]=curb[0]=1;</span><br><span class="line">        for(i=1;i&lt;=k;i++)&#123;</span><br><span class="line">            cura[i]=1ll*cura[i-1]*a%mod;</span><br><span class="line">            curb[i]=1ll*curb[i-1]*b%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0;i&lt;=k;i++)&#123;</span><br><span class="line">            int q = 1ll*cura[k-i]*curb[i]%mod;//公比</span><br><span class="line">            int tmp=0;</span><br><span class="line">            if(q==1)&#123;</span><br><span class="line">                tmp = n%mod;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tmp = 1ll*q * (qpow(q,(n%(mod-1)))-1)%mod*(qpow(q-1,mod-2))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            //printf(&quot;%d %dssss\n&quot;,q,tmp);</span><br><span class="line">            int flag=1;</span><br><span class="line">            if(i&amp;1) flag=-1;</span><br><span class="line">            ans = (ans+1ll*flag*Com(k,i)%mod*tmp)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,(1ll*(ans%mod+mod)%mod*qpow(A1, k)%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n个机器人，每一个机器人有一个初始位置$s$和加速度$a$，初速度都是0，在0时刻一同往同一个方向出发，问有多少个机器人出现过领先其他所有机器人的时刻。</p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>由题可知：</p><blockquote><p> 机器人的位置$y=\frac{1}{2}at^2+s$</p></blockquote><p>机器人之间超过的话也就是<script type="math/tex">y0>y1\rightarrow \frac{1}{2}a_1t^2+s_1>\frac{1}{2}a_2t^2+s_2</script><br>化简可得：</p><script type="math/tex; mode=display">t^2 > \frac{2(-s_1-(-s_2))}{a_1-a_2}(当且仅当a_1>a_2)</script><p>仔细观察可以发现，这个表达式可以解读为，当只要$\frac{-2s_1}{a_1}&gt;\frac{-2s_2}{a_2}$则$t$有解，可以超越。<br>我们把$-2s$看成$y$轴，$a$看成$x$轴，那么上述算式就是看斜率了，<br>我们先把所有机器人<strong>去重</strong>后按照$a$从小到大排序，接着对于排序后的机器人从第一个开始枚举机器人维护一个斜率单调上升队列(在队列里面表示该机器人能超越已经枚举过的所有机器人)。</p><blockquote><p>维护方法：<br>第一步：保证斜率单调上升，枚举一个机器人后把它的斜率与队列尾部的机器人的斜率。(保证该机器人能超越队列里所有机器人)<br>第二步：每枚举一个机器人时在加入队列尾部时注意它超过队列最后一个时，队列的最后一个有没有超过倒数第二个，如果超过了，队列的最后一个就不能超越所有机器人，也要弹出。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+50;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">pair&lt;ll,ll&gt; a[N];</span><br><span class="line">int q[N],vis[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        rep(i,1,n)&#123;</span><br><span class="line">            scanf(&quot;%lld %lld&quot;,&amp;a[i].second,&amp;a[i].first);</span><br><span class="line">            a[i].second*=(-2);</span><br><span class="line">            vis[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+1,a+1+n);</span><br><span class="line">        rep(i,2,n)&#123;</span><br><span class="line">            if(a[i].first==a[i-1].first&amp;&amp;a[i].second==a[i-1].second) vis[i]=vis[i-1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int tot=0;</span><br><span class="line">        q[++tot]=1;</span><br><span class="line">        rep(i,2,n)&#123;</span><br><span class="line">            if(a[i].first==a[i-1].first) continue;</span><br><span class="line">            while(tot&gt;0&amp;&amp;a[i].second&lt;=a[q[tot]].second) tot--;//第一步：判断斜率单调上升</span><br><span class="line">            while(tot&gt;1)&#123;</span><br><span class="line">                j = q[tot],k = q[tot-1];</span><br><span class="line">                if((a[i].second-a[j].second)*(a[j].first-a[k].first) &lt;= (a[j].second-a[k].second)*(a[i].first-a[j].first)) tot--;//判断最后机器人是否能做leader</span><br><span class="line">                else break;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        rep(i,1,tot) if(!vis[q[i]]) ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1011"><a href="#1011" class="headerlink" title="1011"></a>1011</h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给一个字符串，对于他的任意前缀求一个最小字典序的后缀，用该后缀开始的位置求和。</p><h3 id="补充知识点Lyndon串"><a href="#补充知识点Lyndon串" class="headerlink" title="补充知识点Lyndon串"></a><a href="https://oi-wiki.org/string/lyndon/" target="_blank" rel="noopener">补充知识点Lyndon串</a></h3><blockquote><p>对于该知识点我个人为这是我见过写的最好的，就直接看吧，反正我就看懂了它。</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>学会Lyndon串以后再来看这题！嗯？这不就是板子？直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">char a[N];</span><br><span class="line">int ans = 0,num[N];</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,a+1);</span><br><span class="line">        int len = strlen(a+1);</span><br><span class="line">        i=1;</span><br><span class="line">        while(i&lt;=len)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">            j=i+1,k=i;</span><br><span class="line">            while(j&lt;=len&amp;&amp;a[k]&lt;=a[j])&#123;</span><br><span class="line">                if(a[k]&lt;a[j]) k=i,num[j]=i;//不相等他的Lyndon串就是从i开始</span><br><span class="line">                else num[j]=num[k]+j-k,k++;//相等直接计算他的循环节就好了。</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i&lt;=k)&#123;</span><br><span class="line">                i+=j-k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=0;</span><br><span class="line">        int cur=1;</span><br><span class="line">        rep(i,1,len)&#123;</span><br><span class="line">            //printf(&quot;%dsss\n&quot;,num[i]);</span><br><span class="line">            ans=(1ll*ans+1ll*cur * num[i])%mod;</span><br><span class="line">            cur = 1ll * cur * 1112 %mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_43202683/article/details/107508164" target="_blank" rel="noopener">一个大佬的题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身体不适，这个暑假补题怕是只能尽量了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04安装docker安装酷Q</title>
    <link href="https://www.dream-ak.top/2020/06/06/Ubuntu18%E5%AE%89%E8%A3%85%E9%85%B7Q/"/>
    <id>https://www.dream-ak.top/2020/06/06/Ubuntu18%E5%AE%89%E8%A3%85%E9%85%B7Q/</id>
    <published>2020-06-06T02:20:38.000Z</published>
    <updated>2020-06-14T02:40:39.774Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。<a id="more"></a></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>这里我们首先安装Docker，关于什么是Docker，请点击<a href="https://www.zhihu.com/question/28300645" target="_blank" rel="noopener">知乎问答</a>。关于这里的说法我大致现总结一下，一家之见，如有不足，请私聊点出。<br>这里同样的以集装箱做比喻，我们在Docker上部署的每一个应用都相当于一个集装箱，每个集装箱之间互不影响，这样就解决了关于应用之间的冲突问题，所以我们部署的所有应用都可以使用一艘船(服务器)去进行运输，节省了开支与时间。</p><h2 id="卸载旧docker"><a href="#卸载旧docker" class="headerlink" title="卸载旧docker"></a>卸载旧docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><h2 id="使用存储库安装"><a href="#使用存储库安装" class="headerlink" title="使用存储库安装"></a>使用存储库安装</h2><ol><li><p>更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li></ol><p>9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure></p><h2 id="安装docker引擎"><a href="#安装docker引擎" class="headerlink" title="安装docker引擎"></a>安装docker引擎</h2><ol><li>更新apt程序包索引，并安装最新版本的Docker Engine和容器，或转到下一步以安装特定版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li></ol><h2 id="检验docker是否成功"><a href="#检验docker是否成功" class="headerlink" title="检验docker是否成功"></a>检验docker是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure><h1 id="拉取酷Q镜像"><a href="#拉取酷Q镜像" class="headerlink" title="拉取酷Q镜像"></a>拉取酷Q镜像</h1><h2 id="拉取命令"><a href="#拉取命令" class="headerlink" title="拉取命令"></a>拉取命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull coolq/wine-coolq</span><br></pre></td></tr></table></figure><h2 id="查看是否成功"><a href="#查看是否成功" class="headerlink" title="查看是否成功"></a>查看是否成功</h2><p>镜像名称是：$coolq/wine-coolq$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images   (查看镜像)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 运行命令</span><br></pre></td></tr></table></figure><br>docker run —name=coolq -d -p 9000:9000 -v /home/wt/coolq/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=905584041 coolq/wine-coolq<br>```<br>释义</p><blockquote><p>—name=coolq是将镜像命名为coolq</p><p>9000:9000是开放9000端口</p><p>/home/wt/coolq/coolq-data:/home/user/coolq 宿主机路径：酷q数据文件路径。</p><p>VNC_PASSWD=12345678:网页登陆密码</p><p>COOLQ_ACCOUNT=905584041登陆的qq好</p><p>coolq/wine-coolq 部署的镜像名称</p></blockquote><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>关于docker的报错，今天一共出现三种，如下：</p><ol><li>部署的端口冲突，我们改一下端口就好了</li><li>部署的应用的image已存在，两种修复办法，第一改掉名称，第二先暂停重复的应用<code>(docker stop (container id))</code>然后删除它<code>(docker rm (container id))</code>。</li><li>部署完以后无效，我这里是因为云服务器没有打开部署的端口号，到服务器找到安全组打开端口以后运行流畅。</li></ol><h2 id="部分docker命令"><a href="#部分docker命令" class="headerlink" title="部分docker命令"></a>部分docker命令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">部署</td><td style="text-align:center">docker pull 应用名</td></tr><tr><td style="text-align:center">查看部署状态</td><td style="text-align:center">docker ps -a</td></tr><tr><td style="text-align:center">暂停应用</td><td style="text-align:center">(docker stop (container id))</td></tr><tr><td style="text-align:center">删除已部署应用</td><td style="text-align:center">(docker rm (container id))</td></tr></tbody></table></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看了一下官方部署文档里面的下载命令，说真的，我居然没看懂，所以我要在这里写下来他们的差异。</p><blockquote><p>install与rpm： 关于这两个的差异的话呢，主要体现在对于安装有依赖包的软件，用yum命令特别方便，如果用rpm命令，就必须要先装依赖包再装软件包，而yum命令会直接匹配依赖包然后直接安装。</p><p>dokg与apt-get：dpkg只能安装已经下载到本地机器上的deb包. apt-get能在线下载并安装deb包,能更新系统,<br>且还能自动处理包与包之间的依赖问题,这个是dpkg工具所不具备的。</p><p>apt方式安装<br>apt-get是debian，ubuntu发行版的包管理工具，与红帽中的yum工具非常类似。<br>apt-get命令一般需要root权限执行，所以一般跟着sudo命令例sudo apt-get xxxx<br>apt-get install packagename——安装一个新软件包（参见下文的aptitude）<br>apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）<br>apt-get —purge remove packagename——卸载一个已安装的软件包（删除配置文件）<br>dpkg —force-all —purge packagename ——有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。<br>apt-get autoremove——因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件。<br>apt-get autoclean——定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。<br>apt-get clean——这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。<br>apt-get upgrade——更新所有已安装的软件包<br>apt-get dist-upgrade——将系统升级到新版本<br>apt-cache search string——在软件包列表中搜索字符串<br>apt-cache showpkg pkgs——显示软件包信息。<br>apt-cache stats——查看库里有多少软件<br>apt-cache dumpavail——打印可用软件包列表。<br>apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。<br>apt-cache pkgnames——打印软件包列表中所有软件包的名称</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://blog.csdn.net/qq_38901815/article/details/102978391" target="_blank" rel="noopener">16.04部署酷Q</a></li><li><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">docker官方部署文档</a></li><li><a href="https://blog.csdn.net/zyjustin9/article/details/84536663?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2" target="_blank" rel="noopener">linux的多种安装方式</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Linux" scheme="https://www.dream-ak.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Calendar类</title>
    <link href="https://www.dream-ak.top/2020/06/05/Calenda/"/>
    <id>https://www.dream-ak.top/2020/06/05/Calenda/</id>
    <published>2020-06-05T09:57:34.000Z</published>
    <updated>2020-06-05T12:09:49.185Z</updated>
    
    <content type="html"><![CDATA[<p>自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。<a id="more"></a></p><h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>所述Calendar类是一个抽象类，可以为在某一特定时刻和一组之间的转换的方法calendar fields如YEAR ， MONTH ， DAY_OF_MONTH ， HOUR ，等等，以及用于操纵该日历字段，如获取的日期下个星期。 时间上的瞬间可以用毫秒值表示，该值是从1970年1月1日00:00 00：00.000 GMT（Gregorian）的Epoch的偏移量。 </p><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用默认时区和语言环境获得一个日历</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">// 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1</span><br><span class="line">System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));</span><br><span class="line">System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1));       </span><br><span class="line">System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure><h2 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h2><blockquote><p>统一设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">// 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1</span><br><span class="line">// cal.set(year, month, date, hourOfDay, minute, second);</span><br><span class="line">cal.set(2018, 1, 15, 23, 59, 59);</span><br></pre></td></tr></table></figure><br>单个设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 或者6个字段分别进行设置，由于月份下标从0开始赋值月份要-1</span><br><span class="line">cal.set(Calendar.YEAR, 2018);</span><br><span class="line">cal.set(Calendar.MONTH, Calendar.FEBRUARY);</span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, 15);</span><br><span class="line">cal.set(Calendar.HOUR_OF_DAY, 23);</span><br><span class="line">cal.set(Calendar.MINUTE, 59);</span><br><span class="line">cal.set(Calendar.SECOND, 59);</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure></p><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>使用add方法对某个时间进行修改，如果月份修改后该日子不存在，会将不存在的日期归为当月日历的最后一天。<br>时间修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">System.out.println(cal.getTime());</span><br><span class="line">cal.set(2018, 1, 15, 23, 59, 59);</span><br><span class="line">cal.add(Calendar.SECOND, 1);//加一秒</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure><br>月份修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">cal.set(2018, 1, 31, 8, 0, 0);</span><br><span class="line">System.out.println(cal.getTime());</span><br><span class="line">cal.add(Calendar.MONTH, 1);//变为2018/2/28</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户权限管理</title>
    <link href="https://www.dream-ak.top/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://www.dream-ak.top/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-03T03:45:32.000Z</published>
    <updated>2020-06-03T13:25:40.163Z</updated>
    
    <content type="html"><![CDATA[<p>关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。<a id="more"></a></p><h1 id="档案的基本权限"><a href="#档案的基本权限" class="headerlink" title="档案的基本权限"></a>档案的基本权限</h1><p>这里为表达方便，我把文件和目录统称为档案。</p><h2 id="档案的属性"><a href="#档案的属性" class="headerlink" title="档案的属性"></a>档案的属性</h2><p>对于一个档案我们首先在目录里面使用&lt;<strong>ll</strong>&gt;命令，查看每一个档案的属性，下图是属性的介绍表<br><img src="/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/档案属性.gif" alt="Linux属性"></p><blockquote><p>第一栏是档案的类型权限。<br><img src="/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/档案权限.gif" alt="Linux档案权限"><br>第一个字元代表这个档案是『目录、档案或连结档等等』：</p><blockquote><p>当为[ d ]则是目录。<br>当为[ - ]则是档案。<br>若是[ l ]则表示为连结档(link file)；<br>若是[ b ]则表示为装置档里面的可供储存的周边设备(可随机存取装置)；<br>若是[ c ]则表示为装置档里面的序列埠设备，例如键盘、滑鼠(一次性读取装置)。<br>接下来的字元中，以三个为一组，且均为『rwx』的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>第一组为『档案拥有者可具备的权限』，该档案的拥有者可以读写，但不可执行；<br>第二组为『加入此群组之帐号的权限』；<br>第三组为『非本人且没有加入本群组之其他帐号的权限』。</p></blockquote><p>第二栏是与该文件的连接数<br>每个档案都会将他的权限与属性记录到档案系统的i-node中，不过，我们使用的目录树却是使用档名来记录，因此每个档名就会连结到一个i-node啰！这个属性记录的，就是有多少不同的档名连结到相同的一个i-node号码去就是了。</p><p>第三栏是账户拥有者</p><p>第四栏表示这个档案的所属群组<br>在Linux系统下，你的帐号会加入于一个或多个的群组中。举刚刚我们提到的例子，class1, class2, class3均属于projecta这个群组，假设某个档案所属的群组为projecta，且该档案的权限如图5.2.2所示(-rwxrwx—-) ，则class1, class2, class3三人对于该档案都具有可读、可写、可执行的权限(看群组权限)。但如果是不属于projecta的其他帐号，对于此档案就不具有任何权限了。</p><p>第五栏为这个档案的容量大小，预设单位为bytes；</p><p>第六栏为修改日期<br>这一栏的内容分别为日期(月/日)及时间。如果这个档案被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。如下所示：</p><p>第7栏为文档名称<br>这个栏位就是档名了。比较特殊的是：如果档名之前多一个『 . 』，则代表这个档案为『隐藏档』，例如上表中的.config那一行，该档案就是隐藏档。你可以使用『ls』及『ls -a』这两个指令去感受一下什么是隐藏档啰！</p></blockquote><h2 id="文档的重要性"><a href="#文档的重要性" class="headerlink" title="文档的重要性"></a>文档的重要性</h2><p>与Windows系统不一样的是，在Linux系统当中，每一个档案都多加了很多的属性进来，尤其是群组的概念，这样有什么用途呢？其实，最大的用途是在『资料安全性』上面的。</p><blockquote><p>系统保护的功能：<br>举个简单的例子，在你的系统中，关于系统服务的档案通常只有root才能读写或者是执行，例如/etc/shadow这一个帐号管理的档案，由于该档案记录了你系统中所有帐号的资料，因此是很重要的一个设定档，当然不能让任何人读取(否则密码会被窃取啊)，只有root才能够来读取啰！所以该档案的权限就会成为[ ————— ]啰！咦！所有人都不能使用？没关系，root基本上是不受系统的权限所限制的，所以无论档案权限为何，预设root都可以存取喔！</p><p>团队开发软体或资料共用的功能：<br>此外，如果你有一个软体开发团队，在你的团队中，你希望每个人都可以使用某一些目录下的档案，而非你的团队的其他人则不予以开放呢？以上面的例子来说，testgroup的团队共有三个人，分别是test1, test2, test3，那么我就可以将团队所需的档案权限订为[ -rwxrws—- ]来提供给testgroup的工作团队使用啰！(怎么会有s呢？没关系，这个我们在后续章节再讲给你听！)</p><p>未将权限设定妥当的危害：<br>再举个例子来说，如果你的目录权限没有作好的话，可能造成其他人都可以在你的系统上面乱搞啰！例如本来只有root才能做的开关机、ADSL的拨接程式、新增或删除使用者等等的指令，若被你改成任何人都可以执行的话，那么如果使用者不小心给你重新开机啦！重新拨接啦！等等的！那么你的系统不就会常常莫名其妙的挂掉啰！而且万一你的使用者的密码被其他不明人士取得的话，只要他登入你的系统就可以轻而易举的执行一些root的工作！</p></blockquote><p>可怕吧！因此，在你修改你的linux档案与目录的属性之前，一定要先搞清楚，什么资料是可变的，什么是不可变的！千万注意啰！接下来我们来处理一下档案属性与权限的变更吧！</p><h2 id="改变档案的属性和权限"><a href="#改变档案的属性和权限" class="headerlink" title="改变档案的属性和权限"></a>改变档案的属性和权限</h2><blockquote><p>改变所属群组, chgrp<br>改变一个档案的群组真是很简单的，直接以chgrp来改变即可，咦！这个指令就是change group的缩写嘛！这样就很好记了吧！^_^。不过，请记得，要被改变的群组名称必须要在/etc/group档案内存在才行，否则就会显示错误！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chgrp [-R] dirname/filename ... </span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。</span><br><span class="line">范例： </span><br><span class="line">[root@study ~]# chgrp users initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">-rw-r--r--. 1 root users 1864 May 4 18:01 initial-setup -ks.cfg</span><br><span class="line">[root@study ~]# chgrp testing initial-setup-ks.cfg </span><br><span class="line">chgrp: invalid group: `testing&apos; &lt;==发生错误讯息啰～找不到这个群组名～</span><br></pre></td></tr></table></figure></p><p>改变档案拥有者, chown<br>如何改变一个档案的拥有者呢？很简单呀！既然改变群组是change group，那么改变拥有者就是change owner啰！BINGO！那就是chown这个指令的用途，要注意的是，使用者必须是已经存在系统中的帐号，也就是在/etc/passwd 这个档案中有纪录的使用者名称才能改变。</p></blockquote><p>chown的用途还满多的，他还可以顺便直接修改群组的名称呢！此外，如果要连目录下的所有次目录或档案同时更改档案拥有者的话，直接加上-R的选项即可！我们来看看语法与范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chown [-R]帐号名称档案或目录 </span><br><span class="line">[root@study ~]# chown [-R]帐号名称:群组名称档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更</span><br><span class="line"></span><br><span class="line">范例：将initial-setup-ks.cfg的拥有者改为bin这个帐号： </span><br><span class="line">[root@study ~]# chown bin initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">-rw-r- -r--. 1 bin   users 1864 May 4 18:01 initial-setup-ks.cfg</span><br><span class="line"></span><br><span class="line">范例：将initial-setup-ks.cfg的拥有者与群组改回为root： </span><br><span class="line">[root@study ~]# chown root:root initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">- rw-r--r--. 1 root root 1864 May 4 18:01 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure></p><p>事实上，chown也可以使用『chown user.group file』，亦即在拥有者与群组间加上小数点『 . 』也行！不过很多朋友设定帐号时，喜欢在帐号当中加入小数点(例如vbird.tsai这样的帐号格式)，这就会造成系统的误判了！所以我们比较建议使用冒号『:』来隔开拥有者与群组啦！此外，<strong>chown也能单纯的修改所属群组呢</strong>！例如『chown .sshd initial-setup-ks.cfg』就是修改群组～看到了吗？就是那个小数点的用途！</p><blockquote><p>改变权限, chmod<br>这里只讲一种，另外一种u、g、o、a代名词的自行了解。<br>Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：<br>r:4<br>w:2<br>x:1<br>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—-] 分数则是：<br>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= —- = 0+0+0 = 0<br>所以等一下我们设定权限的变更时，该档案的权限数字就是770啦！变更权限的指令chmod的语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chmod [-R] xyz档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="档案权限介绍"><a href="#档案权限介绍" class="headerlink" title="档案权限介绍"></a>档案权限介绍</h2><p>对于档案的权限这里是两种，分别分为文件的权限和目录的权限</p><ol><li>当是一个文件的时候，『r』就是浏览文件，『w』就是修改文件，『x』就是执行文件</li><li>当该档案是一个目录的时候『r』是查看目录下的所有档案或档案信息，『w』是修改当前目录的文档信息，『x』是是否能进入该目录的权限。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:left">放置档案内容</th></tr></thead><tbody><tr><td style="text-align:center">/bin</td><td style="text-align:left">系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><tr><td style="text-align:center">/boot</td><td style="text-align:left">这个目录主要在放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub2这个开机管理程式，则还会存在/boot/grub2/这个目录喔！</td></tr><tr><td style="text-align:center">/dev</td><td style="text-align:left">在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/loop<em>, / dev/sd</em>等等</td></tr><tr><td style="text-align:center">/etc</td><td style="text-align:left">系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中喔。比较重要的档案有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在/etc/目录下喔：&lt;\br&gt;/etc/opt(必要)：这个目录在放置第三方协力软体/opt的相关设定档/etc/X11/(建议)：与X Window有关的各种设定档都在这里，尤其是xorg.conf这个X Server的设定档。&lt;\br&gt;/etc/sgml/(建议)：与SGML格式有关的各项设定档&lt;\br&gt;/etc/xml/(建议)：与XML格式有关的各项设定档</td></tr><tr><td style="text-align:center">/lib</td><td style="text-align:left">系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。另外FHS还要求底下的目录必须要存在：&lt;\br&gt;/lib/modules/：这个目录主要放置可抽换式的核心相关模组(驱动程式)喔！&lt;\br&gt;/media    media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。</td></tr><tr><td style="text-align:center">/mnt</td><td style="text-align:left">如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</td></tr><tr><td style="text-align:center">/opt</td><td style="text-align:left">这个是给第三方协力软体放置的目录。什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</td></tr><tr><td style="text-align:center">/run</td><td style="text-align:left">早期的FHS 规定系统开机后所产生的各项资讯应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用记忆体来模拟，因此效能上会好很多！</td></tr><tr><td style="text-align:center">/sbin</td><td style="text-align:left">Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他使用者最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</td></tr><tr><td style="text-align:center">/srv</td><td style="text-align:left">srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。常见的服务例如WWW, FTP等等。举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。不过，系统的服务资料如果尚未要提供给网际网路任何人浏览的话，预设还是建议放置到/var/lib 底下即可。</td></tr><tr><td style="text-align:center">/tmp</td><td style="text-align:left">这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除唷！</td></tr></tbody></table></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://linux.vbird.org/linux_basic/0210filepermission.php#table2.1.1" target="_blank" rel="noopener">鸟哥的Linux私房菜</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://www.dream-ak.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.dream-ak.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CCPC Wannafly Winter Camp Day3</title>
    <link href="https://www.dream-ak.top/2020/05/19/DAY3/"/>
    <id>https://www.dream-ak.top/2020/05/19/DAY3/</id>
    <published>2020-05-19T02:35:01.000Z</published>
    <updated>2020-06-03T03:20:17.315Z</updated>
    
    <content type="html"><![CDATA[<p>最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。<a id="more"></a></p><h1 id="G火山哥周游世界"><a href="#G火山哥周游世界" class="headerlink" title="G火山哥周游世界"></a>G火山哥周游世界</h1><p>赛时想到树，但是没有想到是树形dp，主要是这里的根实在太多了，看了题解，原来换根$dp$完全可以解决这种题型，而且常用于解决这些问题。<br>该类题目的特点是：给定一个树形结构，需要以每个节点为根进行一系列统计。完全符合。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>经过$k$个点的最短路径很容易看出来就是从点$s$出发经过所有点后在一个节点上停下来，那么距离就是$dis = sum[s]-dept[s]$其中$sum[s]$表示$s$到经过$k$点后返回原点的距离，而$dept[s]$表示从$s$开始走，能到的$k$个点中最远的那个。<br>问题就分解成了两个子问题。</p><ol><li>从当前点到达k个点后返回自身距离。</li><li>从当前点出发能走到的最远的距离。</li></ol><p>对于这两个问题，我们先看问题1，首先单独考虑一个点,一个点时直接暴力$dfs$就好了。<br>扩展来看多个点。我们在一个点$dfs$时构建了一棵树，考虑父节点(上一棵树的根节点)与子节点的关系，对于父节点来说，他的答案是已知的，而更新到子节点我们也就只要考虑如何更新子节点，子节点维护了子节点下面的所有点的距离，根据父节点我们也就可以更新该节点往上走的所有值，同时判断是否加上一个边$(u \rightarrow v)$。<br>来看更新过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(m-sz[v]==0)&#123;//v上面没有有需要经过的点</span><br><span class="line">dp[v]=dp[u]-ed[i].w;把边权去掉</span><br><span class="line">&#125;</span><br><span class="line">else if(sz[v]==0)&#123;//v下面有需要经过的点</span><br><span class="line">dp[v]=dp[u]+ed[i].w;增加边权</span><br><span class="line">&#125;</span><br><span class="line">else dp[v]=dp[u];//该点是必要点(必须经过)所以边权不变。</span><br></pre></td></tr></table></figure></p><p>子问题2：<br>当前点能到的最远距离。<br>也是首先来看单个点，我们可以知道，对于单个点来说，直接大力$dfs$就好了。<br>接下来，我们来看多个点，我们首先已经处理一个点，考虑以他为父节点，那么父节点最远距离已知，我们将一棵按照两个节点$u \rightarrow v$割成两颗子树，分别以$u$和$v$为父节点。那么当前节点v的能到的$dept=max(v树里面能走到的最远的距离,u树能走到的最远距离+u \rightarrow v)$<br>而$v$树里面最远的距离在第一次$dfs$就可以知道，明显可以发现一个道理，不管根节点在$v$的上面怎么变，他的父节点一直不变，且$v$下面的节点结构也不变！(<del>是你爹终归是爹</del>)。<br>$u$树的最远距离有两种可能</p><ol><li>经过点$v$，那就有点尴尬了，我们考虑一条不经过$v$的次长路径和$u$往上走的最长路径更新最远距离</li><li>不经过点$v$，那直接就是，$u$往上走的最远距离和它往不经过v的最长路径更新最远距离。</li></ol><p>可能会问为什么是不能经过$v$的最长路径，这是$u$树(以$u$为根节点，断掉$u \rightarrow v$)边的树。<br>来看转移方程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//注意，如果上面没有树，就不要去寂寞的更新了。</span><br><span class="line">if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123;</span><br><span class="line">    up[v]=max(up[u],deep1[u])+ed[i].w;</span><br><span class="line">&#125;else if(m-sz[v]!=0)&#123;</span><br><span class="line">    up[v]=max(up[u],deep0[u])+ed[i].w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看全部代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">int pre,to;</span><br><span class="line">ll w;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot=0,vis[N],sz[N],n,m;</span><br><span class="line">ll deep0[N],dp[N],deep1[N],ans[N],dept[N],up[N];</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">ed[++tot].pre=head[u];</span><br><span class="line">ed[tot].to=v;</span><br><span class="line">ed[tot].w=w;</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dfs0(int u,int fa)&#123;</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">int v=ed[i].to;</span><br><span class="line">if(fa==v) continue;</span><br><span class="line">dfs0(v,u);</span><br><span class="line">sz[u]+=sz[v];</span><br><span class="line">if(sz[v])&#123;</span><br><span class="line">dp[u]+=dp[v]+ed[i].w;</span><br><span class="line">if(deep0[v]+ed[i].w&gt;deep0[u])&#123;</span><br><span class="line">vis[u]=v;</span><br><span class="line">deep1[u]=deep0[u];</span><br><span class="line">deep0[u]=ed[i].w+deep0[v];//更新最长路</span><br><span class="line">&#125;else deep1[u]=max(deep1[u],deep0[v]+ed[i].w);//保证了最长路与次长路不在同一个子节点上面</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int u,int fa)&#123;</span><br><span class="line">//printf(&quot;%d %d %d %d\n&quot;,u,dp[u],deep0[u],up[u]);</span><br><span class="line">dept[u]=max(deep0[u],up[u]);</span><br><span class="line">ans[u]=(dp[u]*2-dept[u]);</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">int v=ed[i].to;</span><br><span class="line">if(fa==v) continue;</span><br><span class="line">if(m-sz[v]==0)&#123;</span><br><span class="line">dp[v]=dp[u]-ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">else if(sz[v]==0)&#123;</span><br><span class="line">dp[v]=dp[u]+ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">else dp[v]=dp[u];</span><br><span class="line">if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123;</span><br><span class="line">up[v]=max(up[u],deep1[u])+ed[i].w;</span><br><span class="line">&#125;else if(m-sz[v]!=0)&#123;</span><br><span class="line">up[v]=max(up[u],deep0[u])+ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,t=0;</span><br><span class="line">int u,v,w;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">tot=0;</span><br><span class="line">rep(i,1,n-1)&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line">rep(i,1,m) scanf(&quot;%d&quot;,&amp;u),sz[u]=1;</span><br><span class="line">dfs0(1,1);</span><br><span class="line">dfs1(1,1);</span><br><span class="line">rep(i,1,n)&#123;</span><br><span class="line">printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="无向图定向"><a href="#无向图定向" class="headerlink" title="无向图定向"></a>无向图定向</h1><h2 id="迪尔沃斯定理"><a href="#迪尔沃斯定理" class="headerlink" title="迪尔沃斯定理"></a>迪尔沃斯定理</h2><p>定理指出：<strong>对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目</strong>。<br>具体应用有</p><ol><li>求一个序列的上升子序列的数量，我们可以求其最长下降子序列的长度就是其上升子序列的数量。<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener">题目链接</a></li></ol><p>这一题就当是开了眼，蛮玄乎的。<br>我们暴力枚举每一个点的颜色，注意其一条边之间的两个点颜色不得相同，当颜色使用的最少的时候，就是其最小反链的数目+1，直接输出就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 17+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">int pre,to,w;</span><br><span class="line">&#125;ed[N*2];</span><br><span class="line">int head[N],tot,ans=30,n,m,siz=0,clo[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">ed[++tot].pre=head[u];</span><br><span class="line">ed[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int u,int flag)&#123;</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">if(clo[ed[i].to]==flag) return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int res)&#123;</span><br><span class="line">if(res&gt;ans) return ;</span><br><span class="line">if(u&gt;n)&#123;</span><br><span class="line">ans=min(ans,res);</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">rep(j,1,res)&#123;</span><br><span class="line">if(check(u,j)) continue;</span><br><span class="line">clo[u]=j;</span><br><span class="line">dfs(u+1,res);</span><br><span class="line">&#125;</span><br><span class="line">clo[u]=res+1;</span><br><span class="line">dfs(u+1,res+1);</span><br><span class="line">clo[u]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,t=0;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">ans=m+1;</span><br><span class="line">siz=1,tot=0;</span><br><span class="line">rep(i,1,m)&#123;</span><br><span class="line">int u,v;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">add(v,u);</span><br><span class="line">add(u,v);</span><br><span class="line">&#125;</span><br><span class="line">dfs(1,1);</span><br><span class="line">printf(&quot;%d\n&quot;,ans-1);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/laoguantongxiegogo/p/12490457.html" target="_blank" rel="noopener">迪尔沃斯定理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2020美团杯补题日志</title>
    <link href="https://www.dream-ak.top/2020/05/18/2020%E7%BE%8E%E5%9B%A2%E6%9D%AF%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97/"/>
    <id>https://www.dream-ak.top/2020/05/18/2020%E7%BE%8E%E5%9B%A2%E6%9D%AF%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97/</id>
    <published>2020-05-18T13:14:29.000Z</published>
    <updated>2020-05-18T13:50:27.304Z</updated>
    
    <content type="html"><![CDATA[<p>说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！<del>cf疯狂掉分，感人肺腑:(</del><a id="more"></a></p><h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><p>真的是写题3分钟，debug5小时，人都傻了，秒出思路后居然细节处理出现问题，样例都没过，后面疯狂想到假算法，我真是个睿智。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为在整个字符串里面都不能出现$xxxll$这个子序列，那么我们思考最后的修改后的结果，显然可以知道在每一个位置上其前面不得超过$2$个$x$，多余的$x$我们全部转成$l$，这样操作结果是在该位置以前一定不会有非法串，后面不能超过$1$个$l$，将多余的$l$全部转成$x$。然后枚举每一个位置得到其最小值就是答案了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">char a[N];</span><br><span class="line">int pre[N],nxt[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,i,j,k,t=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,a+1);</span><br><span class="line">int len = strlen(a+1);</span><br><span class="line">rep(i,1,105) pre[i]=0,nxt[i]=0;</span><br><span class="line">rep(i,1,len) pre[i]=pre[i-1]+(a[i]==&apos;x&apos;);</span><br><span class="line">for(i=len;~i;i--) nxt[i]=nxt[i+1]+(a[i]==&apos;l&apos;);</span><br><span class="line">int ans = 1000;</span><br><span class="line">rep(i,1,len)&#123;</span><br><span class="line">ans=min(ans,max(pre[i-1]-2,0)+max(0,nxt[i]-1));</span><br><span class="line">//printf(&quot;%d %d\n&quot;,pre[i],nxt[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>一个交互题，主要是关于$sort$被卡的问题，很玄学！官方解释是sort在数据量很小时自动退化为插入排序，而qsort不会。</p><h2 id="qsort使用方法"><a href="#qsort使用方法" class="headerlink" title="qsort使用方法"></a>qsort使用方法</h2><ol><li>传入数组地址</li><li>传入排序长度</li><li>传入排序元素字节长度</li><li>最重要的一点！cmp函数，格式固定，返回值为int，大于零则表示大于，小于零则表示小于。<br>这里贴一个$qsort$的版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;lcs.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">int cmp(const void *a,const void *b)&#123;//此处格式固定</span><br><span class="line">int num[2]=&#123;*(int *) a ,*(int *)b&#125;;</span><br><span class="line">int flag = get_lcs(2,num);</span><br><span class="line">if(flag&gt;1) flag=1;</span><br><span class="line">else flag=-1;</span><br><span class="line">return -flag;</span><br><span class="line">&#125;</span><br><span class="line">void find_permutation(int n, int res[])&#123;</span><br><span class="line">int i;</span><br><span class="line">rep(i,0,n-1)&#123;</span><br><span class="line">res[i]=i+1;</span><br><span class="line">&#125;</span><br><span class="line">qsort(res,n,sizeof(int),cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！&lt;del&gt;cf疯狂掉分，感人肺腑:(&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>shell入门</title>
    <link href="https://www.dream-ak.top/2020/05/12/shell%E5%85%A5%E9%97%A8/"/>
    <id>https://www.dream-ak.top/2020/05/12/shell%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-12T02:26:45.000Z</published>
    <updated>2020-06-03T03:29:15.150Z</updated>
    
    <content type="html"><![CDATA[<p>最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础<a id="more"></a></p><h1 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p># 是注释号</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量分为永久变量和临时变量<br>临时变量是shell内部定义，用于该shell程序，随shell程序关闭而清理。<br>永久变量是环境变量，不随shell结束而消失。<br>变量定义和python一致，直接定义就好了。<br>$ 访问变量<br>set命令是列出所有变量</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的单引号与双引号<br>单引号不会自动访问变量，而双引号会访问该变量的值。举个例子</p><blockquote><p>定义一个var=’aaa’<br>a=’var’这里a是var<br>a=”var”这里a是aaa </p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">\$*($@)</td><td style="text-align:center">这个程序的所有参数</td></tr><tr><td style="text-align:center">$#</td><td style="text-align:center">几个配置参数</td></tr><tr><td style="text-align:center">$$</td><td style="text-align:center">该程序的PID</td></tr><tr><td style="text-align:center">@!</td><td style="text-align:center">后台的pid值</td></tr></tbody></table></div><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>read 从键盘输入数据</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 输出当前包含的变量</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>shell仅支持整形运算<br>expr 整形运算(仅支持整形运算)<br>+代表加法<br>-代表减法<br>/代表除法<br>*乘法<br>所有运算都要放到反单引号里面才能成功，且<strong>运算符两边必须含有空格，等号两边不得含有空格</strong></p><h2 id="test变量测试语句"><a href="#test变量测试语句" class="headerlink" title="test变量测试语句"></a>test变量测试语句</h2><h3 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test str1=str2</td><td style="text-align:center">是否相等</td></tr><tr><td style="text-align:center">test str1!=str2</td><td style="text-align:center">是否不相等</td></tr><tr><td style="text-align:center">test str1</td><td style="text-align:center">是否为空</td></tr><tr><td style="text-align:center">test -n str1</td><td style="text-align:center">判断是否不为空</td></tr><tr><td style="text-align:center">test -z str1</td><td style="text-align:center">是否为空</td></tr></tbody></table></div><h3 id="数字测试"><a href="#数字测试" class="headerlink" title="数字测试"></a>数字测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test int1 -eq int2</td><td style="text-align:center">是否相等 (equal)</td></tr><tr><td style="text-align:center">test int1 -ge int2 int1</td><td style="text-align:center">是否大于等于int2 (great)</td></tr><tr><td style="text-align:center">test int1 -gt int2 int1</td><td style="text-align:center">是否大于int2 (great than)</td></tr><tr><td style="text-align:center">test int1 -le int2 int1</td><td style="text-align:center">是否小于等于int2 (less)</td></tr><tr><td style="text-align:center">test int1 -lt int2 int1</td><td style="text-align:center">是否小于int2 (less than)</td></tr><tr><td style="text-align:center">test int1 -ne int2 int1</td><td style="text-align:center">不相等int2</td></tr></tbody></table></div><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test -d -file</td><td style="text-align:center">是否为目录</td></tr><tr><td style="text-align:center">test -f file</td><td style="text-align:center">指定文件是否常规文件</td></tr><tr><td style="text-align:center">test -x file</td><td style="text-align:center">指定文件是否可执行</td></tr></tbody></table></div><p>test -r file |指定文件是否可读<br>test -w file |指定文件是否可写<br>test -a/e file |指定文件是否存在<br>test -s file |指定文件大小是否为0</p><ol><li>exit 返回，0为正常<br>流程控制语句<br>if … then … fi<br>其中 -a逻辑与，-o逻辑或<br>循环语句<br>while[逻辑语句]do…done</li></ol></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量<br>书要是定义对系统操作的环境生效的系统默认环境变量如PATH等<br>环境配置文件</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">/etx/profile</td><td style="text-align:center">全局变量</td></tr><tr><td style="text-align:center">/etx/profile.d/*.sh</td><td style="text-align:center">全局变量</td></tr><tr><td style="text-align:center">~/.bash_profile</td><td style="text-align:center">仅对当前用户有效</td></tr><tr><td style="text-align:center">~/.bashrc</td><td style="text-align:center">仅对当前用户有效</td></tr><tr><td style="text-align:center">/etc/bashrc</td><td style="text-align:center">全局变量</td></tr></tbody></table></div><p><img src="/2020/05/12/shell%E5%85%A5%E9%97%A8/启动顺序.png" alt="运行顺序"><br>启动配置文件：source 配置文件或 .配置文件</p><h2 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h2><p>init 6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://www.dream-ak.top/categories/shell/"/>
    
    
      <category term="Linux" scheme="https://www.dream-ak.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机与矩阵快速幂</title>
    <link href="https://www.dream-ak.top/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://www.dream-ak.top/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-05-09T13:09:20.000Z</published>
    <updated>2020-05-10T12:54:46.687Z</updated>
    
    <content type="html"><![CDATA[<p>这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://vjudge.net/problem/POJ-2778" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>首先给我们$x$个字符串，主要是由$A,C,T,G$四个字符组成的长度不超过10的字符串，$x \leq 10$，问由$A,C,G,T$组成的长度为$m$的字符串有多少个合法的(如果该字符串有一个子串和之前的字符串一样，则该字符非法)。$m \leq 2*10^9$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$m$初看很假！这么大怎么弄，不要慌，我们先慢慢来，首先一共有$x$个模式串，我们先对模式串建一个$trie$树，保留他的$tail$节点。如果把一个构造后的字符串a后面加一个字符$v$看成是从$a$这个节点引4条有向路径出去。同时$trie$树里面的$tail$节点都是尾节点，这些节点如果出现在构造后的字符串里面，那么该串也就会出现非法子串。这题意也就抽象成了构造后的字符串里面不得含有非法节点，一共有多少种构造方式。联想到AC自动机fail的性质，它可以$O(n)$的判断字典树里面节点$cur$后面添加一条边v是否会成为非法节点。(通过fail失配节点去寻找以$root \rightarrow fail$是$root \rightarrow cur$的尾串，进而判断是否是非法节点)，也就完成了建边操作。<br>再看一个矩阵定理<br>邻接矩阵$a$ * $a$所代表的含义是从$i$节点经过两步以后能达到$j$的方案数。以此类推$a * a * a$就是三步的意思，证明的话看参考资料吧<br>从一颗字典树来看我们生成一个矩阵，表示从$u \rightarrow v$的方案数，从此观之，我们可以知道如果$mat[u][v]=0$就表示如果在由字典树到$u$的字串后加一个$v$变成了非法串。<br><img src="/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/图形示意.png" alt="图形示意"><br>黑色箭头表示失配指针，线条表示边，从上至下有向边。<br>模式串为$ACG$与$C$时$trie$树如上图我们就可以知道初始矩阵$mat$为：</p><ol><li>2 1 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0</li></ol><p>这里的$mat[0][0]=2$是因为从$0$节点走$G(T)$边会发现trie树里面没有该节点，那么走向$G(T)$后的节点还是一个虚点$0$节点，所以$mat[0][0]$就等于2了。<br>然后直接用上面得到的矩阵开始矩阵快速幂。直接得到$m$步后的矩阵，统计$mat[0]$的和，表示从$0$到任意节点的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 110</span><br><span class="line">#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)</span><br><span class="line">struct kkk&#123;</span><br><span class="line">int son[5],flag,fail;</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line">int cnt,nxt[maxn];</span><br><span class="line">const int mod = 100000;</span><br><span class="line">char aa[maxn];</span><br><span class="line">queue&lt;int &gt;q;</span><br><span class="line">int check(char x)&#123;</span><br><span class="line">    if(x==&apos;A&apos;) return 1;</span><br><span class="line">    if(x==&apos;C&apos;) return 2;</span><br><span class="line">    if(x==&apos;T&apos;) return 3;</span><br><span class="line">    return 4;</span><br><span class="line">&#125;</span><br><span class="line">void insert(char* s)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=check(s[i]);</span><br><span class="line">if(!trie[u].son[v])trie[u].son[v]=++cnt;</span><br><span class="line">u=trie[u].son[v];</span><br><span class="line">&#125;</span><br><span class="line">trie[u].flag=1;</span><br><span class="line">&#125;</span><br><span class="line">void getFail()&#123;</span><br><span class="line">for(int i=1;i&lt;5;i++)trie[0].son[i]=1;</span><br><span class="line">q.push(1);trie[1].fail=0;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int u=q.front();q.pop();</span><br><span class="line">for(int i=1;i&lt;5;i++)&#123;</span><br><span class="line">int v=trie[u].son[i];</span><br><span class="line">int Fail=trie[u].fail;</span><br><span class="line">if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125;</span><br><span class="line">trie[v].fail=trie[Fail].son[i];</span><br><span class="line">            trie[v].flag|=trie[trie[Fail].son[i]].flag;//核心，标记是否为非法节点。</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct mat&#123;</span><br><span class="line">    long long m[maxn][maxn];</span><br><span class="line">&#125;unit,pos;</span><br><span class="line">void init_unit()&#123;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        unit.m[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void builds()&#123;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        int u;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            u = trie[i].son[j];</span><br><span class="line">            if(trie[u].flag||trie[i].flag)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            pos.m[i][u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mat plus1(mat a,mat b)&#123;</span><br><span class="line">    mat ans;</span><br><span class="line">    long long cur;</span><br><span class="line">    rep(i,1,cnt)&#123;</span><br><span class="line">        rep(j,1,cnt)&#123;</span><br><span class="line">            cur = 0;</span><br><span class="line">            rep(k,1,cnt)&#123;</span><br><span class="line">                cur += (1ll*a.m[i][k]*b.m[k][j])%mod;</span><br><span class="line">                cur%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.m[i][j]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void sol(int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    init_unit();</span><br><span class="line">    mat cur = unit;</span><br><span class="line">    builds();</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) cur = plus1(cur,pos);</span><br><span class="line">        pos = plus1(pos,pos);</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ans = (ans+cur.m[1][i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t,x,n;</span><br><span class="line">    memset(trie,0,sizeof trie);</span><br><span class="line">    cnt=1;            //代码实现细节，编号从1开始</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;x);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,aa);</span><br><span class="line">        insert(aa);</span><br><span class="line">    &#125;</span><br><span class="line">    getFail();</span><br><span class="line">    sol(x);</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="瞎说"><a href="#瞎说" class="headerlink" title="瞎说"></a>瞎说</h2><p>这题简直就是开拓视野，写完了之后理清思路写博客还是有点懵，视野开拓的有点猛，我被吓到了。。。同时注意矩阵快速幂需要注意爆栈问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.matrix67.com/blog/archives/276" target="_blank" rel="noopener">矩阵乘法</a><br><a href="https://blog.csdn.net/morgan_xww/article/details/7834801" target="_blank" rel="noopener">正版题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快&lt;/p&gt;
    
    </summary>
    
    
      <category term="字符串" scheme="https://www.dream-ak.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>CCPC Wannafly Winter Camp Day2</title>
    <link href="https://www.dream-ak.top/2020/05/02/Day2/"/>
    <id>https://www.dream-ak.top/2020/05/02/Day2/</id>
    <published>2020-05-02T11:35:21.000Z</published>
    <updated>2020-05-07T15:03:59.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持续更新中，，，"><a href="#持续更新中，，，" class="headerlink" title="持续更新中，，，"></a>持续更新中，，，</h1><p>2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。<a id="more"></a><br>今天队友过来A，我过了C说句实在的A我还是有点懵，但是C我是知道了。先来一个C的题解。</p><h2 id="C博弈"><a href="#C博弈" class="headerlink" title="C博弈"></a>C博弈</h2><p>关于这题呢，求有多少种必胜方案。题目明显是一个$nim$博弈，同时先空的输，因而我们可以知道，<strong>先手必胜也就是先手拿完以后，进入平衡态，剩余数组异或值为0</strong>，那么首先朴素算法。</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>暴力枚举：$CurNor \oplus a_i &lt; a_i$的数量，输出该数量就是答案了。($CurNor$当前的异或值)<br>枚举$i$明显超时。</p><h3 id="bouton定理"><a href="#bouton定理" class="headerlink" title="bouton定理"></a>bouton定理</h3><p>没错，这里又是一个定理。异或和的最高的为1的二进制位，所有这一位是1的y显然都是必胜态，这一位是0的不是必胜态。<br>为啥？<br>如果是必胜态，那么一定存在</p><script type="math/tex; mode=display">CurNor \oplus a_i \leq a_i</script><p>因为$a_i$里面的某一位变成了$0$以后，不管后面数字怎么变都只会变小，所以上式成立。<br>同时如果不是必胜态，那么一定存在<script type="math/tex">CurNor \oplus a_i > a_i</script><br>因为$a_i$里面有一位变成了$1$，不管后面怎么变，都会变大。所以也成立。<br>证毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">ll a[N];</span><br><span class="line">int cnt[N],ans[N];</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        int pos=0;</span><br><span class="line">        rep(j,0,60)&#123;</span><br><span class="line">            if(a[i]&amp;(1ll&lt;&lt;j)) cnt[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum^=a[i];</span><br><span class="line">        if(sum==0)&#123;</span><br><span class="line">            ans[i]=0;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = 0;</span><br><span class="line">        rep(j,0,60)&#123;</span><br><span class="line">            if(sum&amp;(1ll&lt;&lt;j)) pos=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=cnt[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="E树上启发式合并"><a href="#E树上启发式合并" class="headerlink" title="E树上启发式合并"></a>E树上启发式合并</h2><p>普及概念：</p><ol><li>重点： 表示其子节点中子树最大的子结点。</li><li>重边：一个节点的重边是自身节点与重点的连边。</li></ol><p>赛时队友提问：请问有啥好的数据结构能做到在插入是$log$情况下还能二分的吗？本憨批回答，无。我怕不是真憨批。$set$呀！！！错亿，这锅我背了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%lld\n&quot;,(a))</span><br><span class="line">set&lt;int&gt; q[N];</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot=0,sz[N],son[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int u)&#123;</span><br><span class="line">    int x = 0,sum=1;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v =ed[i].id;</span><br><span class="line">        dfs1(v);</span><br><span class="line">        sum+=sz[v];</span><br><span class="line">        if(sz[v]&gt;sz[x]) x=v;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[u]=sum;</span><br><span class="line">    son[u]=x;</span><br><span class="line">&#125;</span><br><span class="line">void query(int u,int x)&#123;</span><br><span class="line">    set&lt;int&gt;:: iterator it = q[u].lower_bound(x);</span><br><span class="line">    if(q[u].empty())&#123;</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(it==q[u].begin())&#123;</span><br><span class="line">        ll r = *it;</span><br><span class="line">        ans[u]+=1ll*(r-x)*(r-x);</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        //printf(&quot;%d %lld l\n&quot;,x,r);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(it==q[u].end())&#123;</span><br><span class="line">        ll l = *--it;</span><br><span class="line">        ans[u]+=1ll*(x-l)*(x-l);</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        //printf(&quot;%d r\n&quot;,x);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r = *it,l=*(--it);</span><br><span class="line">    ans[u]-=(r-l)*(r-l);</span><br><span class="line">    ans[u]+=1ll*(r-x)*(r-x);</span><br><span class="line">    ans[u]+=1ll*(x-l)*(x-l);</span><br><span class="line">    q[u].insert(x);</span><br><span class="line">&#125;</span><br><span class="line">void dfs3(int u,int pos)&#123;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        dfs3(v,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    query(pos,u);</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u)&#123;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        dfs2(v);</span><br><span class="line">    &#125;</span><br><span class="line">    q[u].swap(q[son[u]]);</span><br><span class="line">    ans[u]=ans[son[u]];</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        if(v==son[u]) continue;</span><br><span class="line">        q[v].clear();</span><br><span class="line">        dfs3(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    query(u,u);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    rep(i,2,n)&#123;</span><br><span class="line">        int u;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;u);</span><br><span class="line">        add(u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(1);</span><br><span class="line">    dfs2(1);</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        pt(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写完这个代码，嗯，说句实在的，感觉算法不是很难理解，唯独在于时间复杂度，他是$n*log_n$的，比较难以理解。<br>同时加深set的理解：</p><ol><li>用$q[u]=q[v]$的话时间复杂度是$O(N)$而使用q[u].swap(q[v])就会是$O(1)$，把我t飞了。</li><li>关于$set$的$lower_bound()$返回的是第一个大于等于他的位置，如果查询值是最大的，返回一个迭代器，指向最后一个元素的后一个节点，要把它修回来。。。</li></ol><h2 id="H-欧拉回路"><a href="#H-欧拉回路" class="headerlink" title="H 欧拉回路"></a>H 欧拉回路</h2><p>到底是这题提议玄学还是我憨批，我怎么看了那么久题意，刚刚才懂。。。<br>题意懂了以后就很明显地知道是个构造题，构造一个欧拉路。(比赛的时候题意看偏了，以为是随便整个数字就好了，还一直在想为啥样例为啥最大只能到4，是真够憨的我)。</p><blockquote><p>对于一个欧拉路径存在定理: <strong>一个图里面奇度为$0$时存在欧拉回路，为$2$时存在欧拉路径</strong></p></blockquote><p>所以我们先找到合适的点就好了，当点数时奇数时，每一个点的度数都是偶数，存在欧拉回路，当点数时偶数$x$时，每个点度数都是奇数，最少需要加入$x/2-1$条边变成两个奇度顶点。单调性容易证明，可以直接二分，如果数学可以的话我发现其实可以直接算出来。不过赛时二分也不错，写起来也快。<br>算出最大的顶点后直接跑欧拉路就好了，唯一坑点，注意格式！！！格式错误是$30%$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[2*N];</span><br><span class="line">ll check(int x)&#123;</span><br><span class="line">    if(x%2) return 1ll*x*(x-1)/2;</span><br><span class="line">    else return 1ll*x*(x-1)/2+(x/2)-1;</span><br><span class="line">&#125;</span><br><span class="line">int head[N],tot=0;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].id=v;</span><br><span class="line">    ed[tot].pre=head[u];</span><br><span class="line">    ed[tot].w=1;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">void sol(int x)&#123;</span><br><span class="line">    for(int &amp;i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        if(ed[i].w==0) continue;</span><br><span class="line">        ed[i].w=ed[i^1].w=0;</span><br><span class="line">        sol(v);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,i,j,k,t=0;</span><br><span class="line">    ll n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    ll l=1,r=1.5e9;</span><br><span class="line">    while(l&lt;r)&#123;</span><br><span class="line">        ll mid = ((l+r)+1)/2;</span><br><span class="line">        if(check(mid)&lt;n) l=mid;</span><br><span class="line">        else r = mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    int poi = l;</span><br><span class="line">    if(n&gt;2e6) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,poi);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    tot=1;</span><br><span class="line">    for(i=1;i&lt;=poi;i++)&#123;</span><br><span class="line">        rep(j,i+1,poi)&#123;</span><br><span class="line">            add(i,j),add(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(poi%2==0)&#123;</span><br><span class="line">        for(int i=3;i&lt;=poi;i+=2) add(i,i+1),add(i+1,i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.clear();</span><br><span class="line">    sol(1);</span><br><span class="line">    for(i=ans.size();i&lt;=n;i++)&#123;</span><br><span class="line">        ans.push_back(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,poi);</span><br><span class="line">    rep(i,0,n-1)&#123;</span><br><span class="line">        if(i!=n-1) printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">        else printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="K-AC自动机优化后dp。"><a href="#K-AC自动机优化后dp。" class="headerlink" title="K AC自动机优化后dp。"></a>K AC自动机优化后dp。</h2><p>赛时看着一头雾水，补完以后来瞎逼逼一下，对于这一题，看了一天AC自动机和优化(没办法，tle在93.9了)，真快乐，后来看到一个博主说可以优化fail数组！<br>一共两个优化，可能因为拿到的板子就是$trie$优化后的产物，所以只发现一个$last$优化，说起来网上关于这个优化各说纷纭，我就叫他$last$了，其实应该来说就是剪枝，在得到$fail$数组去查询时，直接跳$fail$数组可能会经过一些没必要的点，那么这些点我们就可以通过$last$优化掉，直接减少跳的次数！(演示代码使用的$trans$数组)<br>至于该题的dp较明显就是$dp[i]=min(dp[i-len(x)]+val[x],dp[i])$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">const int  maxn=5e5+5;</span><br><span class="line">using namespace std;</span><br><span class="line">struct kkk&#123;</span><br><span class="line">int son[26],flag,fail;</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line">int n,cnt,num[maxn],le[maxn],trans[maxn];</span><br><span class="line">long long dp[maxn],inf;</span><br><span class="line">char a[maxn];</span><br><span class="line">queue&lt;int &gt;q;</span><br><span class="line">void insert(char* s,int val)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=s[i]-&apos;a&apos;;</span><br><span class="line">if(!trie[u].son[v])trie[u].son[v]=++cnt;</span><br><span class="line">u=trie[u].son[v];</span><br><span class="line">&#125;</span><br><span class="line">if(trie[u].flag == 0) trie[u].flag=val;</span><br><span class="line">    else trie[u].flag = min(val,trie[u].flag);</span><br><span class="line">    le[u] = len;</span><br><span class="line">&#125;</span><br><span class="line">void getFail()&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)trie[0].son[i]=1;//初始化0的所有儿子都是1</span><br><span class="line">q.push(1);trie[1].fail=0;//将根压入队列</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int u=q.front();q.pop();</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;//遍历所有儿子</span><br><span class="line">int v=trie[u].son[i];//处理u的i儿子的fail，这样就可以不用记父亲了</span><br><span class="line">int Fail=trie[u].fail;//就是fafail，trie[Fail].son[i]就是和v值相同的点</span><br><span class="line">if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125;//不存在该节点，就把父节点的失配节点的该位子节点补充到该节点上来。</span><br><span class="line">trie[v].fail=trie[Fail].son[i];//存在该节点直接把该节点的失配节点设置为父节点的失配节点的该位子节点的值。</span><br><span class="line">q.push(v);//存在实节点才压入队列</span><br><span class="line">            int x = trie[Fail].son[i];</span><br><span class="line">            if(trie[x].flag!=0)&#123;</span><br><span class="line">                trans[v] = x;//利用trans剪枝，假设当前节点是尾节点则此点有效，可以跳到这个点来</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                trans[v]=trans[x];//无效，跳到该点的上一个点去。</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void query(char* s)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=s[i]-&apos;a&apos;;</span><br><span class="line">int k=trie[u].son[v];//跳Fail</span><br><span class="line">while(k&gt;1)&#123;</span><br><span class="line">            dp[i+1]=min(dp[i+1],1ll*dp[i-le[k]+1]+1ll*trie[k].flag);</span><br><span class="line">k=trans[k];//继续跳trans</span><br><span class="line">&#125;</span><br><span class="line">u=trie[u].son[v];//到下一个儿子</span><br><span class="line">&#125;</span><br><span class="line">    if(dp[len]&gt;=inf)&#123;</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,dp[len]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(trie,0,sizeof trie);</span><br><span class="line">    memset(dp,0x3f,sizeof dp);</span><br><span class="line">    memset(le,0,sizeof le);</span><br><span class="line">    inf = dp[0];</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    cnt=1;</span><br><span class="line">    int x;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s %d&quot;,a,&amp;x);</span><br><span class="line">        insert(a,x);</span><br><span class="line">    &#125;</span><br><span class="line">    getFail();</span><br><span class="line">    scanf(&quot;%s&quot;,a);</span><br><span class="line">    query(a);</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;持续更新中，，，&quot;&gt;&lt;a href=&quot;#持续更新中，，，&quot; class=&quot;headerlink&quot; title=&quot;持续更新中，，，&quot;&gt;&lt;/a&gt;持续更新中，，，&lt;/h1&gt;&lt;p&gt;2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>codeforces1343F-set操作</title>
    <link href="https://www.dream-ak.top/2020/04/23/codeforces1343F-set%E6%93%8D%E4%BD%9C/"/>
    <id>https://www.dream-ak.top/2020/04/23/codeforces1343F-set%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-23T11:27:55.000Z</published>
    <updated>2020-04-23T12:42:13.210Z</updated>
    
    <content type="html"><![CDATA[<p>这道F题说句实在的，题意能把人看蒙了，看懂了倒是挺简单的，反正我一开始把题意看难了。<a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://codeforces.ml/contest/1343/problem/F" target="_blank" rel="noopener">题目</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>存在一个长度为$n$的排列$a$，然后给出$n-1$个子排列，其中每个子排列的元素为$[a_l,a_{l+1},…,a_r]$，其中$r$是由$2-n$里面的数字，每一个数字必将出现一次。求原来的排列。</p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>看到这个每一个数字必将出现一次，就可能想到一个问题了，如果我把$r$前面所有的数字全部确定了，那么第$r$个数字也应该确定了！<br>证明：假设当前确定了$1$到$r-1$的数字，那么可以发现如果把确定的数字在子排列中标记的话，那么将会<strong>出现一段子排列刚好只剩下一个数字没有标记，这就是第r个数字</strong>，同时还可以发现，这样的子排列只有一个，因为如果有<strong>两个的话，那么第r个数字就有两个，可是只有一个位置</strong>，很明显冲突了，可用作剪枝。<strong>注意这里只是一个必要条件，它不能充分保证得出的排列一定成立，但是能保证原排列一定符合这个性质</strong>，所以我们还需要判断是否符合条件。其时间复杂度为$n^3*log_2 n$</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>想挺容易的，做起来我真的没想到，$set$这么骚，要不是学了一点面向对象，我差点理解不了。<br>每一个子序列都可以放到一个集合里面，每一次标记都是把这个数字从集合里面删除。判断的时候直接看集合是否相同。<br>介绍几个骚操作：以$set<int> d$为例</int></p><ol><li><code>*d.begin()</code> 为遍历set</li><li><code>set&lt;set&lt;int&gt; &gt; d(q.begin(),q.end())</code> q在这里为<code>vector&lt;set&lt;int&gt; &gt; q</code> ,这个语句的作用是将q这个数组的所有元素存到d这个集合里面。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include&lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        vector&lt;set&lt;int&gt; &gt; q;</span><br><span class="line">        vector&lt;int&gt; ans;</span><br><span class="line">        rep(i,1,n-1)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">            set&lt;int&gt; cur;</span><br><span class="line">            rep(j,1,m)&#123;</span><br><span class="line">                int x;</span><br><span class="line">                scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">                cur.insert(x);</span><br><span class="line">            &#125;</span><br><span class="line">            q.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        rep(i,1,n)&#123;</span><br><span class="line">            ans.clear();</span><br><span class="line">            vector&lt;set&lt;int&gt; &gt; p = q;</span><br><span class="line">            int cur = i;</span><br><span class="line">            ans.push_back(cur);</span><br><span class="line">            rep(j,1,n-1)&#123;</span><br><span class="line">                int pos = 0 , cnt = 0;</span><br><span class="line">                rep(k,0,n-2)&#123;</span><br><span class="line">                    if(p[k].count(cur)) p[k].erase(cur);</span><br><span class="line">                    if(p[k].size()==1) cnt++,pos = *p[k].begin();//遍历set</span><br><span class="line">                &#125;</span><br><span class="line">                if(cnt!=1) break;</span><br><span class="line">                else cur = pos,ans.push_back(cur);</span><br><span class="line">            &#125; </span><br><span class="line">            if(j==n)&#123;</span><br><span class="line">                set&lt;set&lt;int&gt; &gt; d(q.begin(),q.end());//自动把q数组全部放到set里面</span><br><span class="line">                bool ok = true;</span><br><span class="line">                for(int r=1;r&lt;n;r++)&#123;</span><br><span class="line">                    set&lt;int&gt; f;</span><br><span class="line">                    f.clear();</span><br><span class="line">                    bool flag = false;</span><br><span class="line">                    for(int l=r;l&gt;=0;l--)&#123;</span><br><span class="line">                        f.insert(ans[l]);</span><br><span class="line">                        //printf(&quot;%d &quot;,ans[l]);</span><br><span class="line">                        if(d.count(f)) &#123;</span><br><span class="line">                            flag = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                   // printf(&quot;yes%d %d\n&quot;,i,flag);</span><br><span class="line">                    if(!flag) &#123;</span><br><span class="line">                        ok = false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(ok)&#123;</span><br><span class="line">                    for(int l=0;l&lt;n;l++)&#123;</span><br><span class="line">                        printf(&quot;%d &quot;,ans[l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    printf(&quot;\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://codeforces.ml/blog/entry/76352" target="_blank" rel="noopener">cf题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这道F题说句实在的，题意能把人看蒙了，看懂了倒是挺简单的，反正我一开始把题意看难了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>next添加邮箱与qq</title>
    <link href="https://www.dream-ak.top/2020/04/22/next%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1%E4%B8%8Eqq/"/>
    <id>https://www.dream-ak.top/2020/04/22/next%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1%E4%B8%8Eqq/</id>
    <published>2020-04-22T03:37:55.000Z</published>
    <updated>2020-06-06T03:09:59.085Z</updated>
    
    <content type="html"><![CDATA[<p>昨天受大佬启发，感觉还是需要添加一些个人的链接放到博客上面，于是兴冲冲的开始去设置了，最后直接爆炸。<a id="more"></a></p><h1 id="next添加邮箱"><a href="#next添加邮箱" class="headerlink" title="next添加邮箱"></a>next添加邮箱</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们按照普遍方法在$social$里面添加了地址后，部署到$coding$后发现，在邮件和qq前面自动添加了一堆前缀网址(因为已经修好了，所以展示不出来，如果你也出现了这个问题，你会一眼看出来的)，使原本网址无效了，可能是版本原因还是怎么，查了很久，一直出错，最后没办法改了$hexo$的源码，在这里发出来。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>修改文件位置的话，看下这张图片吧，文件放得太深了。<br><img src="/2020/04/22/next%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1%E4%B8%8Eqq/TIM截图20200422120636.png" alt="文件位置"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if theme.social %&#125;</span><br><span class="line">  &lt;div class=&quot;links-of-author motion-element&quot;&gt;</span><br><span class="line">    &#123;%- for name, link in theme.social %&#125;</span><br><span class="line">      &lt;span class=&quot;links-of-author-item&quot;&gt;</span><br><span class="line">      &#123;%- set sidebarURL = link.split(&apos;||&apos;)[0] | trim %&#125;//获取添加的链接</span><br><span class="line">      &#123;%- if theme.social_icons.enable %&#125;</span><br><span class="line">        &#123;%- set sidebarIcon = &apos;&lt;i class=&quot;fa fa-fw fa-&apos; + link.split(&apos;||&apos;)[1] | trim + &apos;&quot;&gt;&lt;/i&gt;&apos; %&#125;//获取添加的小图标</span><br><span class="line">      &#123;%- else %&#125;</span><br><span class="line">        &#123;%- set sidebarIcon = &apos;&apos; %&#125;//没有则为空</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      &#123;%- if theme.social_icons.enable and theme.social_icons.icons_only %&#125;</span><br><span class="line">        &#123;%- set sidebarText = &apos;&apos; %&#125;</span><br><span class="line">      &#123;%- else %&#125;</span><br><span class="line">        &#123;%- set sidebarText = name %&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      &#123;%- if name == &apos;E-Mail&apos; %&#125;//我添加E-Mail的解决办法</span><br><span class="line">      &lt;a href=&quot;&#123;&#123; sidebarURL &#125;&#125;&quot; rel=&quot;alternate&quot; title=&quot;E-Mail&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;/i&gt; E-Mail&lt;/a&gt;</span><br><span class="line">      &#123;%- elif name == &apos;QQ&apos; %&#125;//我添加的QQ解决办法</span><br><span class="line">      &lt;a href=&quot;&#123;&#123; sidebarURL &#125;&#125;&quot; rel=&quot;alternate&quot; title=&quot;QQ&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-fw fa-qq&quot;&gt;&lt;/i&gt;QQ&lt;/a&gt;</span><br><span class="line">      &#123;%- else %&#125;</span><br><span class="line">      &#123;&#123; next_url(sidebarURL, sidebarIcon + sidebarText, &#123;title: name + &apos; → &apos; + sidebarURL&#125;) &#125;&#125;//原本的解决办法，这个貌似只能处理链接为http或https开头的链接</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><br>由于本人对于swig一知半解，为深入学习，对这个的理解写在注释了，注释方法可能错了(用的是C语言的注释法)，注意删除(不是不想写对，实在百度不到他的只是方案，有途径大佬会的话，可以留言或私聊我，欢迎斧正，对了也可以告诉我哦)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天受大佬启发，感觉还是需要添加一些个人的链接放到博客上面，于是兴冲冲的开始去设置了，最后直接爆炸。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="hexo" scheme="https://www.dream-ak.top/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>树的直径</title>
    <link href="https://www.dream-ak.top/2020/04/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/"/>
    <id>https://www.dream-ak.top/2020/04/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</id>
    <published>2020-04-21T09:42:24.000Z</published>
    <updated>2020-04-22T04:29:42.458Z</updated>
    
    <content type="html"><![CDATA[<p>时隔14天，洒家终于有准备开始刷题了，暂时开篇第一个就是树的直径！<a id="more"></a></p><h1 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h1><p>这个时候可能就有朋友问了，什么是树的直径？<br>来看，树的直径就是<strong>树上的最长简单路</strong>。<br>换个说法，就是树上两点之间最长的距离。<br>我这里介绍一个暴力算法，dfs的</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><blockquote><p>首先，我们以任意一点$w$去$dfs$搜出距离根节点最远的点（也可以说是，深度最大的点）任意一个($v$)<br>然后以它做根节点去搜以它为根节点时最大的深度，节点为$u$，此即直径。</p><p>简单证明:<br>如果w在直径上，那么u一定是直径的一个端点。反证：若u不是端点，则从直径另一端点到w再到u的距离比直径更长，与假设矛盾。<br>如果w不在直径上，且w到其距最远点u的路径与直径一定有一交点c，那么由上一个证明可知，u是直径的一个端点。<br>如果w到最远点u的路径与直径没有交点，设直径的两端为S与T，那么(w-&gt;u)&gt;(w-&gt;c)+(c-&gt;T)，推出(w-&gt;u)+(S-&gt;c)+(w-&gt;c)&gt;(S-&gt;c)+(c-&gt;T)=(S-&gt;T)与假设矛盾。<br>因此w到最远点u的路径与直径必有交点。<br>S—————-c—————-T<br>                |<br>                w———u</p></blockquote><p>看个例题<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4612" target="_blank" rel="noopener">warm up</a><br>求在图里面连一条边后最少的割边。<br>由于是割边，我们可以先缩图成DAG图也就是一颗树，然后求其直径(答案就是：桥的数量-直径)，剖去Tarjan缩图，就是个直径板子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">const int M = 2e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed1[M],ed2[M];</span><br><span class="line">int head1[N],head2[N],tot1=0,tot2=0;</span><br><span class="line">void add1(int u,int v)&#123;</span><br><span class="line">    ed1[++tot1].id=v;</span><br><span class="line">    ed1[tot1].pre=head1[u];</span><br><span class="line">    ed1[tot1].w = 1;</span><br><span class="line">    head1[u]= tot1;</span><br><span class="line">&#125;</span><br><span class="line">void add2(int u,int v)&#123;</span><br><span class="line">    ed2[++tot2].id=v;</span><br><span class="line">    ed2[tot2].pre=head2[u];</span><br><span class="line">    head2[u]=tot2;</span><br><span class="line">&#125;</span><br><span class="line">int clo[N],dfn[N],sta[N],low[N],top=0,vis[N],cnt=0,siz=0;</span><br><span class="line">int edge=0;</span><br><span class="line">void tarjan(int x)&#123;</span><br><span class="line">    dfn[x]=++cnt;</span><br><span class="line">    low[x]=cnt;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    sta[++top]=x;</span><br><span class="line">    //printf(&quot;dfs %d %d\n&quot;,x,fa);</span><br><span class="line">    for(int i=head1[x];i;i=ed1[i].pre)&#123;</span><br><span class="line">        int v=ed1[i].id;</span><br><span class="line">        //printf(&quot;dfs %d %d\n&quot;,x,ed1[i].id);</span><br><span class="line">        if(ed1[i].w==0) continue;</span><br><span class="line">        ed1[i].w = 0;</span><br><span class="line">        ed1[i^1].w = 0;</span><br><span class="line">        if(!dfn[v])&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[x]=min(low[x],low[v]);</span><br><span class="line">            if(dfn[x]&lt;low[v]) edge++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(vis[v])&#123;</span><br><span class="line">            low[x]=min(low[x],dfn[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x]==low[x])&#123;</span><br><span class="line">        clo[x]=++siz;</span><br><span class="line">        vis[x]=0;</span><br><span class="line">        int sum=1;</span><br><span class="line">        while(sta[top]!=x)&#123;</span><br><span class="line">            clo[sta[top]]=siz;</span><br><span class="line">            vis[sta[top--]]=0;</span><br><span class="line">            //printf(&quot;%dsss\n&quot;,sta[top+1]);</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[sta[top--]]=0;</span><br><span class="line">        //printf(&quot;sum %d %d %d\n&quot;,sum,x,clo[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ans = 0,pos=0;</span><br><span class="line"></span><br><span class="line">void dfs(int x,int fa)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    dfn[x] = dfn[fa]+1;</span><br><span class="line">    for(int i=head2[x];i;i=ed2[i].pre)&#123;</span><br><span class="line">        if(fa!=ed2[i].id&amp;&amp;vis[ed2[i].id]==0)&#123;</span><br><span class="line">            //printf(&quot;%d %d %d %dsss\n&quot;,ed2[i].id,x,fa,dfn[x]);</span><br><span class="line">            dfs(ed2[i].id,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(dfn[x]&gt;ans)&#123;</span><br><span class="line">        ans = dfn[x];</span><br><span class="line">        pos = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int ReadInt()</span><br><span class="line">&#123;</span><br><span class="line">    char ch = getchar();</span><br><span class="line">    int data = 0;</span><br><span class="line">    while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        data = data*10 + ch-&apos;0&apos;;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;);</span><br><span class="line">        return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    top=cnt=siz=edge=0;</span><br><span class="line">    tot1=tot2=1;</span><br><span class="line">    memset(vis,0,sizeof(vis));</span><br><span class="line">    memset(dfn,0,sizeof(dfn));</span><br><span class="line">    memset(low,0,sizeof(low));</span><br><span class="line">    memset(head2,0,sizeof(head2));</span><br><span class="line">    memset(head1,0,sizeof(head1));</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        if(!n&amp;&amp;!m) break;</span><br><span class="line">        init();</span><br><span class="line">        rep(i,1,m)&#123;</span><br><span class="line">            int u,v;</span><br><span class="line">            u = ReadInt();</span><br><span class="line">            v = ReadInt();</span><br><span class="line">            add1(u,v);</span><br><span class="line">            add1(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        tarjan(1);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">            for(int j=head1[i];j;j=ed1[j].pre)</span><br><span class="line">            &#123;</span><br><span class="line">                int to=ed1[j].id;</span><br><span class="line">                if(clo[to]!=clo[i]) &#123;add2(clo[to],clo[i]);add2(clo[i],clo[to]);&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ans = 0;</span><br><span class="line">        memset(vis,0,sizeof vis);</span><br><span class="line">        dfn[0]=-1;</span><br><span class="line">        dfs(1,0);</span><br><span class="line">        memset(vis,0,sizeof vis);</span><br><span class="line">        dfn[0]=-1;</span><br><span class="line">        dfs(pos,0);</span><br><span class="line">        pt(edge-ans);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多讲一点点，因为下面这个和直径思路差不多</p><h1 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h1><p>何谓树的重心？<br>树的重心：找到一个点，其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。<br>树的重心可以通过简单的两次搜索求出，第一遍搜索求出每个结点的子结点数量son[u]，第二遍搜索找出使max{son[u],n-son[u]-1}最小的结点。<br>实际上这两步操作可以在一次遍历中解决。对结点u的每一个儿子v，递归的处理v，求出son[v]，然后判断是否是结点数最多的子树，处理完所有子结点后，判断u是否为重心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct CenterTree&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int ans;</span><br><span class="line">    int siz;</span><br><span class="line">    int son[maxn];</span><br><span class="line">    void dfs(int u,int pa)&#123;</span><br><span class="line">        son[u]=1;</span><br><span class="line">        int res=0;</span><br><span class="line">        for (int i=head[u];i!=-1;i=edges[i].next)&#123;</span><br><span class="line">            int v=edges[i].to;</span><br><span class="line">            if (v==pa) continue;</span><br><span class="line">            if (vis[v]) continue;</span><br><span class="line">            dfs(v,u);</span><br><span class="line">            son[u]+=son[v];</span><br><span class="line">            res=max(res,son[v]-1);</span><br><span class="line">        &#125;</span><br><span class="line">        res=max(res,n-son[u]);</span><br><span class="line">        if (res&lt;siz)&#123;</span><br><span class="line">            ans=u;</span><br><span class="line">            siz=res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int getCenter(int x)&#123;</span><br><span class="line">        ans=0;</span><br><span class="line">        siz=INF;</span><br><span class="line">        dfs(x,-1);</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Cent;</span><br></pre></td></tr></table></figure></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://oi-wiki.org/graph/tree-centroid/" target="_blank" rel="noopener">oi-wiki</a><br><a href="https://www.cnblogs.com/zinthos/p/3899075.html" target="_blank" rel="noopener">树的直径、树的重心与树的点分治</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔14天，洒家终于有准备开始刷题了，暂时开篇第一个就是树的直径！&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Java连接数据库</title>
    <link href="https://www.dream-ak.top/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://www.dream-ak.top/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-04-07T12:57:27.000Z</published>
    <updated>2020-06-06T03:10:03.867Z</updated>
    
    <content type="html"><![CDATA[<p>用vscode编译Java一直乱码，我还以为是vscode的问题(毕竟vscode的乱码挺多的)。用回了eclipse以后，发现乱换ide是个不好的习惯，那玩意怎么用啊！于是疯狂捣鼓vscode，终于弄好了Java连接数据库且不乱码了。<a id="more"></a></p><h1 id="Java方面报错"><a href="#Java方面报错" class="headerlink" title="Java方面报错"></a>Java方面报错</h1><p>关于Java方面报错，有个很无语的地方，就是你用控制台输入中文，他会输出空格！一个很诡异的错误，不管怎么调编码格式都没用。找了很久最后看到一个大佬的做法。</p><blockquote><p>第一步：<br>首先在launch.json中关于该文件的地方加上$encoding: “GBK”,$之后你就会发现输入输出都不行了，这时候进行第二步！<br><img src="/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/GBK.png" alt="GBK"></p><p>第二步：<br>将launcher.bat文件修改一下，将@chcp.com 65001 &gt; NUL 修改成@chcp.com 936 &gt; NUL。个人建议在被修改语句前加个rem就好了，<del>怕以后出问题</del>，bat的注释符号。<br><img src="/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/launcher.png" alt="launcher.bat"><br><img src="/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/rem.png" alt="rem"></p><p>第三步：<br>再次尝试运行，你就会发现好了，输入中文也不会乱码。</p></blockquote><h1 id="MySQL数据库的编码格式"><a href="#MySQL数据库的编码格式" class="headerlink" title="MySQL数据库的编码格式"></a>MySQL数据库的编码格式</h1><p>看到这里大家都可能明白我强调Java数据库连接且不乱码了。<br><del>我整了两天一直以为是因为他是gdk编码，怎么传怎么错，学了n久的编码与解码。。。秀的我头皮发麻</del><br>就在刚才，我发现数据库的编码格式有点诡异。<br>首先我们查看数据库的编码格式</p><blockquote><p>show variables like ‘character_set_database’;</p></blockquote><p>紧接着查看数据表的编码格式</p><blockquote><p>show create table &lt;表名&gt;;</p></blockquote><p>修改数据表的编码格式</p><blockquote><p>alter database &lt;数据库名&gt; character set utf8;</p></blockquote><p>创建表格时定义编码格式：</p><blockquote><p>create table tb_books (<br>    name varchar(45) not null,<br>    price double not null,<br>    bookCount int not null,<br>    author varchar(45) not null ) default charset = utf8;</p></blockquote><p>注意这里的编码格式要与$Java$传入参数的编码格式一样！不然会出现乱码，玄学乱码！杀手般的存在。</p><p>到了这里大家伙就会发现已经把问题解决的差不多啦。<del>我解决了你们呢？</del></p><p>关于vscode连接数据库的话，按照$eclipse$的教程其实也不会出多大问题，就是在加入外部包时把整个包放$lib$(没有的，可以自己建一个)文件进去后修改$.classpath$文件路径，增加该路径就差不多加入了。<br><img src="/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/导入外部包.png" alt=".classpath"></p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><h2 id="4-20"><a href="#4-20" class="headerlink" title="4.20"></a>4.20</h2><p>昨天发现按照上述导入后还是用不了，检查了各个地方都没有问题，最后发现在Java dependencies这里点击加号把这个包再导一次，就没事了。(白修一天bug，气煞我也)。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/zeug/p/10516915.html" target="_blank" rel="noopener">查看mysql数据库及表编码格式</a><br><a href="http://blog.ixk.me/vscode-java-output-chinese-garbled-problem-solving.html/comment-page-1" target="_blank" rel="noopener">VSCode Java输出中文乱码问题解决</a><br><a href="http://blog.ixk.me/vscode-java-manually-imports-jar-and-source-package.html" target="_blank" rel="noopener">导入jdbc外部包</a><br><a href="https://blog.csdn.net/QingtaiSensei/article/details/105430845" target="_blank" rel="noopener">导入包</a> (按照博主说法，可以直接导入，我还没有尝试直接导入)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用vscode编译Java一直乱码，我还以为是vscode的问题(毕竟vscode的乱码挺多的)。用回了eclipse以后，发现乱换ide是个不好的习惯，那玩意怎么用啊！于是疯狂捣鼓vscode，终于弄好了Java连接数据库且不乱码了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>kmp与exkmp</title>
    <link href="https://www.dream-ak.top/2020/04/03/kmp%E4%B8%8Eexkmp/"/>
    <id>https://www.dream-ak.top/2020/04/03/kmp%E4%B8%8Eexkmp/</id>
    <published>2020-04-03T11:41:54.000Z</published>
    <updated>2020-05-06T15:20:11.368Z</updated>
    
    <content type="html"><![CDATA[<p>思考良久，是时候拾起以前的字符串了，动态规划先放下吧，毕竟人笨，先把部分板子搞定！<a id="more"></a></p><h1 id="复习kmp算法"><a href="#复习kmp算法" class="headerlink" title="复习kmp算法"></a>复习kmp算法</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>该算法一般用来做字符串匹配，比如在$A$串中寻找与$B$相同的子串。</p><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><h3 id="朴素思想"><a href="#朴素思想" class="headerlink" title="朴素思想"></a>朴素思想</h3><p>枚举$A$里面所有长度与$B$相同长度的字符串进行比较，每一个都枚举出来，有的话就一定匹配成功，就会有答案。</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>枚举所有子串，复杂度$O(N*M)$</p><h3 id="kmp匹配思想"><a href="#kmp匹配思想" class="headerlink" title="kmp匹配思想"></a>kmp匹配思想</h3><p>把一个匹配分成两个阶段，我先介绍完两个阶段，最后解释两个阶段的含义以及用途</p><ol><li>第一个阶段，对于$B$字符串我们首先对其单独进行一次处理，形成一个$next[]$数组，同时$next[i]$表示前$i-1$个字符的前缀与后缀的最长匹配。<br>“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；<br>“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</li><li>利用朴素枚举匹配，查看在$A$串中以$i$开始的最长匹配长度$max$(<strong>也就是A中以$i$开始，$B$中以第1个字符开始，能够匹配的最长相同的字符</strong>)。当$max==lenB$($B$字符串的长度)时，那么就可以返回$i$，表示查找成功了。不相等时：那么下一次匹配时$A$的枚举位置就可以直接跳到$(i+len+1)$，$B$的枚举位置就要跳到$len+1$。因为这种情况下$A$串中$i~i+len$与$B$串中$1~len$所包含字符一模一样，就可以直接跳跃</li></ol><h4 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p>不会画图，在这里我直接给出答案$O(N)$，<a href="https://blog.csdn.net/niukai1768/article/details/79579709" target="_blank" rel="noopener">详细解答</a></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="第一阶段："><a href="#第一阶段：" class="headerlink" title="第一阶段："></a>第一阶段：</h5><p>继续定义一个$next$数组表示最长前缀与最长后缀的匹配长度，其中$next[i]$表示从第1个字符到第$i-1$个的最长匹配！<br>这个我们对于这个$next$数组实现，用如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void GetNext(string B, int next[])</span><br><span class="line">&#123;</span><br><span class="line">    int B_len = B.size();</span><br><span class="line">    int i = 0;   // B 的下标</span><br><span class="line">    int j = -1;  </span><br><span class="line">    next[0] = -1;</span><br><span class="line"></span><br><span class="line">    while (i &lt; B_len)</span><br><span class="line">    &#123;</span><br><span class="line">        if (j == -1 || B[i] == B[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;//相同，就可以更新next[i]了</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];//将j跳转至以第j-1个字符的最长匹配值的位置。为什么可以跳转待会解释</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么那里是跳转？先看这个图<br><img src="/2020/04/03/kmp%E4%B8%8Eexkmp/跳转.png" alt="跳转"><br>注意这里变量与上面代码变量完全一致，也就是说假设$j$与$i$在如图所示位置，那么当$B[i]==B[j]$时，$next[i]$直接就是$j$了,因为$next[i-1]=j-1$，而$B[i]==B[j]$所以他直接等于$j$。当$B[i]!=B[j]$时，我们怎么办？看下图<br><img src="/2020/04/03/kmp%E4%B8%8Eexkmp/跳转2.png" alt="跳转2"><br>那么可以发现$next[j]$我们是处理好了的，且$next[j]$表示从$0 \rightarrow j-1$的最长公共前后缀匹配长度，这里前面第一个椭圆表示$0 \rightarrow j-1$的最长公共前缀，第二个最长公共后缀，他俩长一样的。对此我们往后看到$next[j]$要表示的值，也就是后面的两个椭圆与前面两个椭圆是什么关系？应该也要是一样的，理由：<strong>$0 \rightarrow j-1$与 $i-j \rightarrow i-1$是一样的($next[i-1]==j-1$且$a[i-1]==a[j-1]$)</strong>，进而得出这四个椭圆包含的字符串是一样的！所以为了求$next[i]$我们经过上面的关系转换，我们就可以不断的使用$next[j]$划分小椭圆来实现。</p><p>如果你理解了，我就再提一个问题！<strong>求$B$串的最小循环节怎么算？</strong><br>提示：与我这里的椭圆划分有关哦！不过从结论上看不出来。</p><h5 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h5><p>$A$串与$B$串开始匹配<br>先上代码，上面那个都理解了，下面没什么好说的了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int KMP(string A, string B, int next[])</span><br><span class="line">&#123;</span><br><span class="line">    GetNext(B, next);</span><br><span class="line"></span><br><span class="line">    int i = 0;  // A 的下标</span><br><span class="line">    int j = 0;  // B 的下标</span><br><span class="line">    int A_len = A.size();</span><br><span class="line">    int B_len = B.size();</span><br><span class="line"></span><br><span class="line">    while (i &lt; A_len &amp;&amp; B &lt; p_len) // 因为末尾 &apos;\0&apos; 的存在，所以不会越界</span><br><span class="line">    &#123;</span><br><span class="line">        if (j == -1 || A[i] == B[j])  // B 的第一个字符不匹配或 A[i] == B[j]</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            j = next[j];  // 当前字符匹配失败，跳转到B的最长前后匹配字串位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (j == B_len)  // 匹配成功</span><br><span class="line">        return i - j;</span><br><span class="line">    </span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>乍一看以为一模一样，实际上呢？就是不需要更新$next$而已，而且这里的跳转也不是为了划分椭圆而是寻找上一次的最大前后缀匹配，并跳到那个位置。</p><h1 id="扩展EXkmp算法"><a href="#扩展EXkmp算法" class="headerlink" title="扩展EXkmp算法"></a>扩展EXkmp算法</h1><p>这个坑有点大了。。。死在补题上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;思考良久，是时候拾起以前的字符串了，动态规划先放下吧，毕竟人笨，先把部分板子搞定！&lt;/p&gt;
    
    </summary>
    
    
      <category term="字符串" scheme="https://www.dream-ak.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>lcs与lis</title>
    <link href="https://www.dream-ak.top/2020/03/29/lcs%E4%B8%8Elis/"/>
    <id>https://www.dream-ak.top/2020/03/29/lcs%E4%B8%8Elis/</id>
    <published>2020-03-29T14:06:16.000Z</published>
    <updated>2020-03-30T09:59:58.259Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到很多这种lcs与lis得题目，就来写一个关于这种题目的一个总结<br>更新<br>经我仔细思考，之前有以下漏洞：</p><ol><li>二分法$lis$已经把树状数组所有功能全部重合，具体写法写到里面了。<a id="more"></a><h1 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h1>顾名思义，就是求最长上升子序列的最大长度，这样的求法一共有三种！<br>分别介绍一下：<h2 id="n-2-的-dp-写法"><a href="#n-2-的-dp-写法" class="headerlink" title="$n^2$的$dp$写法"></a>$n^2$的$dp$写法</h2>定义$dp[i]$为从第$i$个数字结尾的上升子序列(该上升子序列一定以$a[i]$结尾)的长度。我们每一次枚举一个$j$，往前枚举$i$找到一个比$a[j]$小的最大的$dp[i]$，更新$dp[j]$。<br>换句话说就是找到前面一个比当前值小且以他结尾的最长上升子序列。<br>代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a[MAXN], d[MAXN];</span><br><span class="line">int dp() &#123;</span><br><span class="line">  d[1] = 1;</span><br><span class="line">  int ans = 1;</span><br><span class="line">  for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">    for (int j = 1; j &lt; i; j++)</span><br><span class="line">      if (a[j] &lt; a[i]) &#123;</span><br><span class="line">        d[i] = max(d[i], d[j] + 1);</span><br><span class="line">        ans = max(ans, d[i]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分-贪心法"><a href="#二分-贪心法" class="headerlink" title="二分+贪心法"></a>二分+贪心法</h2><h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>对于一个序列，我们枚举一个值，考虑这个值如果在最长$LIS$里面，那么这个值的位置所在的地方是在哪？在前面比该值小的后面。也就是说，这样对于每一个数字，我们都可以知道，如果他在最长上升序列的位置，记录一下最大的位置就是最长长度！</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>拿一个数组存储在最长上升子序列中第$i$个位置所能出现的最小值，后面不用更新。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><blockquote><p>2 5 1 3 4<br>2<br>2 5<br>1 5//更新第一个位置的值，使其变小<br>1 3//更新第二个位置的值，使其变小<br>1 3 4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i);</span><br><span class="line">memset(dp, 0x1f, sizeof dp);//预处理为最大值</span><br><span class="line">mx = dp[0];</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">  pos = lower_bound(dp, dp + n, a[i]) - dp;//找到大于等于a[i]的第一个值，然后把a[pos]变小。</span><br><span class="line">  dp[pos] = a[i];//注意此时的dp[1~pos]就是以a[i]结尾的最长上升子序列，树状数组。。。多余了</span><br><span class="line">&#125;</span><br><span class="line">ans = 0;</span><br><span class="line">while (dp[ans] != mx) ++ans;</span><br></pre></td></tr></table></figure><p>复杂度$O(Nlog(N))$，该方法也可以$nlogn$求具体最大字串，具体实现可自己想。(提示：参照前向星写法)</p><h2 id="树状数组写法"><a href="#树状数组写法" class="headerlink" title="树状数组写法"></a>树状数组写法</h2><p><strong><a href="https://oi-wiki.org/ds/fenwick/" target="_blank" rel="noopener">不了解树状数组请参考</a></strong><br>可能好奇上面已经够了呀，干嘛还要这个写法呢？给出一点，他能求出具体的以a[i]结尾的最长上升子序列字符串。(二分法也行，不过已经写了，就不删除了，当思维扩展吧)</p><h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><p>树状数组可以连续修改一个区间，以及查询一个区间。<br>我们从第一个值开始枚举，每次按照贪心思想，把比他大的值全部更新为当前值！那么就可以得到以$a[i]$结尾的最大上升子序列的具体值了。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>首先离散化，<a href="https://oi-wiki.org/misc/discrete/" target="_blank" rel="noopener">不懂点击</a>，然后用树状数组查出比第$i$个值大的第一个值得位置，然后对该位置以及以后位置更新为当前值！</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define REP(i, a, b) for(register int i = (a); i &lt; (b); i++)</span><br><span class="line">#define _for(i, a, b) for(register int i = (a); i &lt;= (b); i++)</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXN = 1e3 + 10;</span><br><span class="line">int a[MAXN], b[MAXN], n, m, ans; </span><br><span class="line">int dp[MAXN], f[MAXN];</span><br><span class="line"></span><br><span class="line">inline int lowbit(int x) &#123; return x &amp; (-x); &#125; </span><br><span class="line"></span><br><span class="line">void motify(int x, int p)</span><br><span class="line">&#123;</span><br><span class="line">    for(; x &lt;= m; x += lowbit(x))</span><br><span class="line">        f[x] = max(f[x], p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_max(int x)</span><br><span class="line">&#123;</span><br><span class="line">    int res = 0;</span><br><span class="line">    for(; x; x -= lowbit(x))</span><br><span class="line">        res = max(res, f[x]);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    _for(i, 1, n) scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i];</span><br><span class="line">    sort(b + 1, b + n + 1);</span><br><span class="line">    m = unique(b + 1, b + n + 1) - b - 1;</span><br><span class="line">    _for(i, 1, n) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    _for(i, 1, n)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = get_max(a[i]) + 1;//查询大于等于a[i]得第一个位置</span><br><span class="line">        ans = max(ans, dp[i]);//最长上升子序列</span><br><span class="line">        motify(a[i], dp[i]); //把该位置往后得所有值全部更新</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个大家可能不熟悉，写全了。(百度抄的，改成了这样子的)</p><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>这里有两种解决办法</p><h2 id="动态规划-n-2"><a href="#动态规划-n-2" class="headerlink" title="动态规划($n^2$)"></a>动态规划($n^2$)</h2><p>$dp[i][j]$表示从字符串a的前i个字符与字符串b的前j个字符串的最长公共子序列的长度。说到这里大家伙可能就都知道了，直接贴代码，代码里面解释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;=n+1;i++)&#123;</span><br><span class="line">    for(j=1;j&lt;=m+1;j++)&#123;</span><br><span class="line">        if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;//俩子序列结尾相同时为前面值加一</span><br><span class="line">        else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);//不同时为这个。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个路径可以利用转移方程按前向星思路保存路径</p><h2 id="LCS-转-LIS"><a href="#LCS-转-LIS" class="headerlink" title="$LCS$转$LIS$"></a>$LCS$转$LIS$</h2><p><strong>使用条件，字串里面元素不得出现重复</strong></p><h3 id="思想-2"><a href="#思想-2" class="headerlink" title="思想"></a>思想</h3><p>我们按照第一个字串的顺序映射第一个字串元素在第二个子串中的位置(数组C)。那么$LCS$就转为$LIS$了。没看懂的话，我下面解释一下：<br>第一个字串按顺序映射位置，那么当位置单调递增，也就是在第二个字串中按顺序排列的，那么这几个位置就会是最长公共子序列！</p><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>假设两个字串</p><blockquote><p>a 1 7 5 4 8 3 9<br>b 1 4 3 5 6 2 8 9</p></blockquote><p>映射后</p><blockquote><p>a 1 7 5 4 8 3 9<br>b 1 4 3 5 6 2 8 9<br>c 1 0 4 2 0 0 7 8</p></blockquote><p>C数组$LIS$得到答案和路径长度4，路径1 4 7 8<br>到B里面就是 $1b[1] 5(b[4]) 8(b[7]) 9(b[8])$</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>下面是二分法，树状数组请自己改编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;=n+1;i++) vis[a[i]]=i;</span><br><span class="line">for(i=1;i&lt;=m+1;i++) b[i]=vis[b[i]];</span><br><span class="line">for(i=1;i&lt;=m+1;i++) dp[i]=2e9;</span><br><span class="line">for(i=1;i&lt;=m+1;i++)&#123;</span><br><span class="line">    tot = lower_bound(dp+1,dp+m+1,b[i])-dp;</span><br><span class="line">    ans=max(ans,tot);</span><br><span class="line">    dp[tot]=b[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h1><p><a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener">导弹拦截</a><br><a href="https://vjudge.net/problem/UVA-10635" target="_blank" rel="noopener">LCS</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/sugewud/p/9823222.html" target="_blank" rel="noopener">树状数组得最长不下降子序列</a><br><a href="https://oi-wiki.org/ds/fenwick/" target="_blank" rel="noopener">树状数组</a><br><a href="https://oi-wiki.org/misc/discrete/" target="_blank" rel="noopener">离散话</a><br><a href="https://oi-wiki.org/dp/basic/" target="_blank" rel="noopener">oi-wiki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近看到很多这种lcs与lis得题目，就来写一个关于这种题目的一个总结&lt;br&gt;更新&lt;br&gt;经我仔细思考，之前有以下漏洞：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;二分法$lis$已经把树状数组所有功能全部重合，具体写法写到里面了。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
    
      <category term="动态规划" scheme="https://www.dream-ak.top/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>codeforces1307D</title>
    <link href="https://www.dream-ak.top/2020/03/24/codeforces1307D/"/>
    <id>https://www.dream-ak.top/2020/03/24/codeforces1307D/</id>
    <published>2020-03-24T14:07:50.000Z</published>
    <updated>2020-03-25T09:02:16.814Z</updated>
    
    <content type="html"><![CDATA[<p>不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://codeforces.ml/problemset/problem/1307/D" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>已知一个连通图，每条边b(无向边)长度都为一，给我们一些点，求在这些点里面任意取两点之间建一条边(长度为一)后，使得从1到n的最短距离最长！求该两点。<br>说白了就是加一条边后形成最长最短路，问在哪里加。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于这一题，毫无疑问我们先要求出该1到其他所有点的最短距离$dis1$，和n到其他所有点的最短距离$dis$。那么最短路一定是$ ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$<br>枚举$a$与$b$找到最大的数字$ans$就好了，但是由于$a$的数字太多了，$O(n^2)$肯定不行，所以这就是该题的最难点，如何找到这个最大值！<br>首先我们可以假设</p><script type="math/tex; mode=display">dis1[a]+dis[b] \leq dis1[b]+dis[a]</script><p>推导发现</p><script type="math/tex; mode=display">dis1[a]-dis[a] \leq dis1[b]-dis[b]</script><p>也就是说只要左边的差值<strong>小于等于</strong>右边的差值，那么:<br>$ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$化简为$ans = dis1[a]+dis[b]+1$，<br>可以发现首先对给我们的点按照$dis1[a]-dis[a]$从小到大排序后，开始从前往后枚举点，i为枚举的下标，$ans=max(x+dis[i]+1),x=max(x,dis1[x])$，$x$代表1到枚举过的点之间的最长距离。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 4e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int p[N];</span><br><span class="line"></span><br><span class="line">int head[N],tot=0,a[N],vis[N],dis1[N],dis[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].id=v;</span><br><span class="line">    ed[tot].pre=head[u];</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dij(int x)&#123;</span><br><span class="line">    memset(dis,0x3f,sizeof(dis));</span><br><span class="line">    priority_queue&lt;pair&lt;int,int&gt; &gt;q;</span><br><span class="line">    dis[x]=0;</span><br><span class="line">    q.push(make_pair(0,x));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        int u=q.top().second;</span><br><span class="line">        q.pop();</span><br><span class="line">        if(vis[u]) continue;</span><br><span class="line">        vis[u]=1;</span><br><span class="line">        for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">            int v=ed[i].id;</span><br><span class="line">            if(dis[v]&gt;dis[u]+1)&#123;</span><br><span class="line">                dis[v]=dis[u]+1;</span><br><span class="line">                q.push(make_pair(-dis[v],v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    for(i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;a[++t]);</span><br><span class="line">    for(i=1;i&lt;=m;i++)&#123;</span><br><span class="line">        int u,v;</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">        add(u,v);</span><br><span class="line">        add(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    dij(1);</span><br><span class="line">    for(i=1;i&lt;=n;i++) dis1[i]=dis[i];</span><br><span class="line">    //printf(&quot;%dss\n&quot;,dis1[n]);</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">    dij(n);</span><br><span class="line">    int sum=2e9+9;</span><br><span class="line">    vector&lt;pair&lt;int,int&gt; &gt; dat;</span><br><span class="line">    for(i=1;i&lt;=t;i++)&#123;</span><br><span class="line">        dat.push_back(make_pair(dis1[a[i]]-dis[a[i]],a[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    sort(dat.begin(),dat.end());</span><br><span class="line">    int mm = -2e9+9,best=0;</span><br><span class="line">    for(i=0;i&lt;t;i++)&#123;</span><br><span class="line">        int x = dat[i].second;</span><br><span class="line">        best = max(best,mm+dis[x]);</span><br><span class="line">        mm = max(mm,dis1[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,min(best+1,dis1[n]));</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://codeforces.ml/blog/entry/73953" target="_blank" rel="noopener">cf题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="ACM" scheme="https://www.dream-ak.top/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Java的biginteger</title>
    <link href="https://www.dream-ak.top/2020/03/21/Java%E7%9A%84biginteger/"/>
    <id>https://www.dream-ak.top/2020/03/21/Java%E7%9A%84biginteger/</id>
    <published>2020-03-21T12:31:29.000Z</published>
    <updated>2020-03-25T10:11:04.059Z</updated>
    
    <content type="html"><![CDATA[<p>哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧<a id="more"></a></p><h2 id="1-赋值："><a href="#1-赋值：" class="headerlink" title="1.赋值："></a>1.赋值：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a=new BigInteger(&quot;1&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInteger b=BigInteger.valueOf(1);</span><br></pre></td></tr></table></figure><h2 id="2-运算："><a href="#2-运算：" class="headerlink" title="2.运算："></a>2.运算：</h2><p>① add(); 大整数相加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a=new BigInteger(“23”); </span><br><span class="line">BigInteger b=new BigInteger(“34”); </span><br><span class="line">a. add(b);</span><br></pre></td></tr></table></figure></p><p>②subtract(); 相减<br>③multiply(); 相乘<br>④divide(); 相除取整<br>⑤remainder(); 取余<br>⑥pow(); a.pow(b)=a^b<br>⑦gcd(); 最大公约数<br>⑧abs(); 绝对值<br>⑨negate(); 取反数<br>⑩mod(); a.mod(b)=a%b=a.remainder(b); </p><h2 id="3-BigInteger构造函数："><a href="#3-BigInteger构造函数：" class="headerlink" title="3.BigInteger构造函数："></a>3.BigInteger构造函数：</h2><p>一般用到以下两种：<br><code>BigInteger(String val);</code><br>将指定字符串转换为十进制表示形式；<br><code>BigInteger(String val,int radix);</code><br>将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger </p><h2 id="4-基本常量："><a href="#4-基本常量：" class="headerlink" title="4.基本常量："></a>4.基本常量：</h2><p><code>A=BigInteger.ONE</code> 1<br><code>B=BigInteger.TEN</code> 10<br><code>C=BigInteger.ZERO</code> 0 </p><ol><li><p>n.compareTo(BigInteger.ZERO)==0  //相当于n==0</p></li><li><p>if(a[i].compareTo(n)&gt;=0 &amp;&amp;a[i].compareTo(m)&lt;=0)   // a[i]&gt;=n &amp;&amp; a[i]&lt;=m </p></li><li>所有比较可以按照string比较规则来比较</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/unknownname/p/8823887.html" target="_blank" rel="noopener">biginteger</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>java对象复习</title>
    <link href="https://www.dream-ak.top/2020/03/21/java%E5%AF%B9%E8%B1%A1%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.dream-ak.top/2020/03/21/java%E5%AF%B9%E8%B1%A1%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-03-21T11:31:07.000Z</published>
    <updated>2020-03-21T12:49:44.059Z</updated>
    
    <content type="html"><![CDATA[<p>完辽，没学习的欲望了，拖了几天的总结。<a id="more"></a></p><h1 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类($abstract$)"></a>抽象类($abstract$)</h1><p>一个方法可以被覆写，那么如果当前类的全部方法都要被子类覆写的话，这个类我们就可以用抽象来代替。这个抽象的方法如果在它的子类里面不对该方法进行覆写的话，直接会报编译错误。<br>那么抽象类的特点：</p><ol><li>直接规范了子类的格式</li><li>抽象类无法实例化</li><li>子类的端口范围不能小于父类的端口范围</li><li>抽象方法不能用$private$修饰，因为抽象方法必须被子类重写，而$private$权限对于子类来说是不能访问的，所以就会产生矛盾。</li><li>抽象方法也不能用$static$修饰，如果用$static$修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。</li><li>抽象类不能被$final$修饰，因为被修饰以后就不能被继承了。</li></ol><h1 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h1><p>当一个抽象类里面没有字段，全是抽象方法时，我们可以将这个类定义为接口。<br>也就是说，接口里面不得有任何字段，所有方法都必须是抽象方法。也因为都是抽象，所以自动省略了$public abstract$修饰语句<br>对于一个接口来说，可以同时继承多个接口。<br>当用一个具体的类实现一个接口必须要用implement，举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    void run();</span><br><span class="line">    String getName();//自动省略public abstract</span><br><span class="line">&#125;</span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(this.name + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="default-方法"><a href="#default-方法" class="headerlink" title="$default$方法"></a>$default$方法</h2><p>接口之中可以定义$default$方法<br>他的优点：</p><ol><li>实现类里面可以不必覆写该方法，但是也可以覆写，方便修改接口。</li></ol><p>举个例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p = new Student(&quot;Xiao Ming&quot;);</span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    String getName();</span><br><span class="line">    default void run() &#123;</span><br><span class="line">        System.out.println(getName() + &quot; run&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student implements Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Student(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="static"><a href="#static" class="headerlink" title="$static$"></a>$static$</h1><h2 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h2><p>对于一个类的静态字段来说，他在这个字段里面只有一个共享空间，所有的实例都是用这一个变量。<br>举例来看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person ming = new Person(&quot;Xiao Ming&quot;, 12);</span><br><span class="line">        Person hong = new Person(&quot;Xiao Hong&quot;, 15);</span><br><span class="line">        ming.number = 88;</span><br><span class="line">        System.out.println(hong.number);</span><br><span class="line">        hong.number = 99;</span><br><span class="line">        System.out.println(ming.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    public String name;</span><br><span class="line">    public int age;</span><br><span class="line"></span><br><span class="line">    public static int number;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以发现修改了一个实例里的静态字段以后另外一个实例里的也改变了。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>对于一个类里面的静态方法，可以直接通过类名.方法名进行运行，但是不可以通过this.类名访问。</p><h2 id="接口的静态字段"><a href="#接口的静态字段" class="headerlink" title="接口的静态字段"></a>接口的静态字段</h2><p>因为$interface$是一个纯抽象类，所以它不能定义实例字段。但是，$interface$是可以有静态字段的，并且静态字段必须为$final$类型。也因为全是$final$所以我们可以省略。</p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>对于一个静态代码块来说，当我们调用该类的时候会自动将静态代码块运行一次，且仅运行一次。当往后运行时就不会再调用了。<br>一般使用这个功能时我们一般都是用来初始化的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/zuotongbin/p/11717010.html" target="_blank" rel="noopener">abstract</a><br><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260451488854880" target="_blank" rel="noopener">廖雪峰</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;完辽，没学习的欲望了，拖了几天的总结。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java多态</title>
    <link href="https://www.dream-ak.top/2020/03/17/Java%E5%A4%9A%E6%80%81/"/>
    <id>https://www.dream-ak.top/2020/03/17/Java%E5%A4%9A%E6%80%81/</id>
    <published>2020-03-17T08:20:29.000Z</published>
    <updated>2020-03-17T09:27:20.735Z</updated>
    
    <content type="html"><![CDATA[<p>这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧<a id="more"></a></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h2><p>子类对于父类的方法进行的修改就叫覆写(Override)。<br>覆写的方式是在子类中定义一个与父类<strong>方法名相同、返回值和参数一样</strong>的方法，就会变成覆写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 多态</span><br><span class="line">多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。</span><br><span class="line">**当一个子类向上转型为父类以后，那么如果父类中有方法被该子类覆写了，调用该方法是会动态调用子类中覆写的方法。**</span><br><span class="line">通过这个性质，对于同一个类的同一个方法就会出现不同的实现方式。例如以下代码：</span><br></pre></td></tr></table></figure><br>public class Main {<br>        public static void main(String[] args){<br>                Preson p1 = new Student();<br>                Preson p2 = new Teacher();<br>                p1.speak();<br>                p2.speak();<br>                p1.speak();<br>        }<br>}<br>public class Preson<br>{<br>    public int age=10;<br>    void speak() {<br>        System.out.println(“父类”);<br>    }<br>}<br>public class Student extends Preson<br>{    @Override//覆写<br>    void speak(){<br>        System.out.println(“学生”);<br>    }<br>}<br>public class Teacher extends Preson<br>{<br>    @Override//覆写<br>    void speak(){<br>        System.out.println(“老师”);<br>    }<br>}<br>```<br>同样都是Person类执行同一个方法输出却是：</p><blockquote><p>学生<br>老师<br>学生</p></blockquote><p><strong>在被子类覆写的方法里面如果想要运行父类方法，可以使用<code>super</code>关键字</strong></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>如果不想当前方法不被覆写，可以在方法名前加上final修饰符，就不会被重写了。<br>如果类不想被继承的话，用它就会绝育了。<br>变量用它后就不能修改了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260455778791232" target="_blank" rel="noopener">廖雪峰的java教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java继承</title>
    <link href="https://www.dream-ak.top/2020/03/17/Java%E7%BB%A7%E6%89%BF/"/>
    <id>https://www.dream-ak.top/2020/03/17/Java%E7%BB%A7%E6%89%BF/</id>
    <published>2020-03-17T06:42:03.000Z</published>
    <updated>2020-03-25T11:29:29.708Z</updated>
    
    <content type="html"><![CDATA[<p>对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西<a id="more"></a></p><h1 id="Java继承"><a href="#Java继承" class="headerlink" title="Java继承"></a>Java继承</h1><h2 id="extends"><a href="#extends" class="headerlink" title="$extends$"></a>$extends$</h2><p>继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让$Student$从$Person$继承时，$Student$就获得了$Person$的所有功能，我们只需要为$Student$编写新增的功能。<br>继承的关键字是<strong>extends</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Preson</span><br><span class="line">&#123;</span><br><span class="line">    public int age=10;</span><br><span class="line">void speak() &#123;</span><br><span class="line">System.out.println(age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Student extends Preson//继承Preson类</span><br><span class="line">&#123;</span><br><span class="line">public String meat;</span><br><span class="line">void eat(String x)&#123;</span><br><span class="line">System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Main &#123;</span><br><span class="line">        public static void main(String[] args)&#123; </span><br><span class="line">                Student p = new Student();</span><br><span class="line">                p.age = 1;</span><br><span class="line">                p.eat(&quot;Apple&quot;);</span><br><span class="line">                p.speak();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从以上代码可以看出，我们的$Student$类完全可以调用$Person$类的$speak()$方法，也可以自己写方法(譬如$eat()$方法)。<br>在OOP的术语中，我们把$Person$称为超类（super class），父类（parent class），基类（base class），把$Student$称为子类（subclass），扩展类（extended class）。</p><h2 id="继承树"><a href="#继承树" class="headerlink" title="继承树"></a>继承树</h2><p>可以发现上面我们的代码$Person$类是没有$extends$的。不过要注意，他还是有父类，是$Object$类，<strong>在Java里面一切不定义extends的类都有一个Object父类</strong>但是Object没有父类。<br>了解了这个以后我们来看一下继承树：<script type="math/tex">Student \rightarrow Preson \rightarrow Object</script></p><blockquote><p>注意：继承树的根是$Object$，上一个节点就是他的父类</p></blockquote><h2 id="protected"><a href="#protected" class="headerlink" title="$protected$"></a>$protected$</h2><p>继承一大特点：子类无法访问父类的$private$变量或$private$字段，这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把$private$改为$protected$。原因<a href="https://www.dream-ak.top/2020/03/11/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/#more">可参考</a>。<br>因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。</p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>如果父类不含有默认构造方法，那么我们需要使用$super(参数)$去自行构建。<br>含有默认构造方法的话，会自动在构造的时候加一个$super()$。</p><h2 id="转型"><a href="#转型" class="headerlink" title="转型"></a>转型</h2><p>对于Java的继承时我们可以对一个引用变量进行转化。<br>用代码解释一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Student p0 =new Student();</span><br><span class="line">Preson p1 = new Preson();</span><br><span class="line">p1 = p0;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">你会发现他成功了，而且这里的p1会丢失Student类的所有方法和属性，这就是**向上转型(子类向父类转换)**，如果要恢复的话必须要**向下转型(父类向子类转换)**。</span><br><span class="line">子类向父类转化是没啥条件的，毕竟父类本身就有子类的部分属性和方法，只不过是更加抽象而已，但是向下转型是有条件的(向下转型时需要判断它是不是要转化的子类类型，不是就会报错)</span><br><span class="line">### $instanceof$</span><br><span class="line">为了防止向下转型失败，这里提供了$instanceof$关键字来判断是否可以转型。</span><br><span class="line">$instanceof$返回$Boolean$值，true代表是后面的类型，false反之。</span><br></pre></td></tr></table></figure><br>Student p1 = new Student();<br>Preson p2 = new Preson();<br>if(p2 instanceof Student){<br>        p1 = (Student) p2;<br>}<br>```<br>这样就不会报错，防止转型失败</p><blockquote><p>对于一次向上转型来说，对于父类来说，他可以使用父类的所有属性和方法，而子类中定义的所有的方法和属性是没有办法的，但是当子类中对父类方法进行覆写时他就会调用子类覆写后的方法(动态连接)，否则就是调用父类自身方法。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260454548196032" target="_blank" rel="noopener">廖雪峰的Java教程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://www.dream-ak.top/tags/Java/"/>
    
  </entry>
  
</feed>
