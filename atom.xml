<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>林木森</title>
  
  <subtitle>淡然处之，莫要强求</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://smilecoding.cn/"/>
  <updated>2021-05-21T14:19:47.283Z</updated>
  <id>https://smilecoding.cn/</id>
  
  <author>
    <name>林木森</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql并发</title>
    <link href="https://smilecoding.cn/2021/05/21/Mysql%E5%B9%B6%E5%8F%91/"/>
    <id>https://smilecoding.cn/2021/05/21/Mysql%E5%B9%B6%E5%8F%91/</id>
    <published>2021-05-21T12:16:36.000Z</published>
    <updated>2021-05-21T14:19:47.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mysql并发问题"><a href="#Mysql并发问题" class="headerlink" title="Mysql并发问题"></a>Mysql并发问题</h3><p>Mysql本身是没有什么问题的，但是如果对于一个表引入并发以后，问题就来了，<strong>两个事务同时对于一个表进行时操作时，到底谁先操作的问题就会随之发生</strong>。如下：假设表table有属性value = 1000;<br>|事务1|事务2|结果|<br>|:—-:|:—-:|:—-:|<br>|写：将value改为800后回滚|读：读取value=800|脏读，读取到的数据是更新前的数据|<br>|读：在同一个事务中对同一数据value读取多次|写：将value的值进行改变|不可重复读：事务1多次读取的数据value不一样|<br>|读：多次读取value的数据|写: 在事务1读取过程中，在value中插入一个新的数据value=800|最后会出现多次读取道德value数量不一样，就像是幻觉|<br>|写：对value执行-100的操作后提交|写：对value执行+100的操作，但是读取数据时在事务1 减100以前，且提交时间在事务1之后|第二类丢失更新：最后的值会变为600，理论应该是500|<br>|写：对value+100|写：对value-100，但是取value值的时候时事务1加100以前，在事务1提交之后之后，发生回滚|第一类丢失更新：很明显，回滚value就会-100|</p><p>从上来看，在两个事务同时操作时，除非都是读，否则很容易出现问题，而出现问题的时候都是在某一个事务并没有执行完成，没有submit时，资源被另一个事务获取。<br>为解决这个问题我们一共有三种解决办法：</p><ol><li>悲观并发控制：最常用的一种机制，也就是锁</li><li>乐观并发控制：乐观锁其实并不是一种真实存在的锁，后文介绍</li><li>多版本并发控制(MVCC)</li></ol><h4 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h4><p>对于并发，我们常用的就是，一份资源只允许一个事务操作，那么这样就可以完全屏蔽上面所有问题。<br>而悲观并发控制时，所有对数据的修改都持悲观态度，每一次修改都会被加锁。</p><h5 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h5><p>共享锁：只能进行读操作，可以被多个事务同时获取。<br>排他锁：可以删除或更新一行数据，但只能被一个事务获取。</p><h5 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h5><p>因为锁的粒度不同，假设我对一个表里面的行加上了排他锁，那么我就不能对该表加上排他锁了。<br>因此，我们再加入意向锁。如果对表加锁，那么我们首先会对其下面子节点加上隐锁，向上对其父节点加上意向锁(并不是排他锁，因为如果是排他锁那么每次就只能锁一个表了)</p><h5 id="死锁的解决"><a href="#死锁的解决" class="headerlink" title="死锁的解决"></a>死锁的解决</h5><blockquote><p>死锁的预防：使用类似Tarjan的算法，对于每一个事务加入一个时间戳，当执行事务的时间戳小于另一事务时间戳时选择等待或者回滚（这两个可选择）</p></blockquote><p>没有办法进行死锁检测的时候我们可以直接考虑死锁恢复</p><blockquote><p>死锁的恢复：直接使用Tarjan的算法，检查当前是否出现闭环，出现则考虑死锁恢复，每次考虑回滚所造成时间消耗最少的事务进行回滚，当然为避免时间消耗最少的事务饿死，所以加一个时间上线</p></blockquote><h4 id="乐观事务控制"><a href="#乐观事务控制" class="headerlink" title="乐观事务控制"></a>乐观事务控制</h4><p>如果我不说，有人知道他是锁嘛？没错，他不是锁。<br>对于每一次读操作，乐观事务控制中都乐观的认为没有其他的事务对其进行修改，一旦发现修改就回滚(他是乐观，不是傻，会检测的)。<br>MySql最经常使用的乐观锁时进行版本控制，也就是在数据库表中增加一列，记为version，当我们将数据读出时，将版本号一并读出，当数据进行更新时，会对这个版本号进行加1，当我们提交数据时，会判断数据库表中当前的version列值和当时读出的version是否相同，若相同说明没有进行更新的操作，不然，则取消这次的操作。<br>从算法上理解：如果多个事务之间有交集，如果同时有多个事务同时操作该表，那么该列值会+x(x&gt;1)，如果只有一个事务操作，那就是+1，所以我们判断是否加1就好了。</p><h5 id="MVCC多版本事务控制"><a href="#MVCC多版本事务控制" class="headerlink" title="MVCC多版本事务控制"></a>MVCC多版本事务控制</h5><p>总的来说，就是一颗主席树，改都没改。。。<br>对于每一次修改，我们都维护一个版本号。每次查询时直接选择最合适的版本号查询，返回结果。<br>所以怎么查询一个最合适的版本号呢？<br>每一个版本的数据行都具有一个唯一的时间戳，当有读事务请求时，数据库程序会直接从多个版本的数据项中具有最大时间戳的返回。<br>更新操作就稍微有些复杂了，事务会先读取最新版本的数据计算出数据更新后的结果，然后创建一个新版本的数据，新数据的时间戳是目前数据行的最大版本＋1<br>数据版本的删除也是根据时间戳来选择的，MySQL 会将版本最低的数据定时从数据库中清除以保证不会出现大量的遗留内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mysql并发问题&quot;&gt;&lt;a href=&quot;#Mysql并发问题&quot; class=&quot;headerlink&quot; title=&quot;Mysql并发问题&quot;&gt;&lt;/a&gt;Mysql并发问题&lt;/h3&gt;&lt;p&gt;Mysql本身是没有什么问题的，但是如果对于一个表引入并发以后，问题就来了，&lt;str
      
    
    </summary>
    
    
      <category term="Mysql" scheme="https://smilecoding.cn/categories/Mysql/"/>
    
    
      <category term="数据库" scheme="https://smilecoding.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>NAT与ARP及DNS</title>
    <link href="https://smilecoding.cn/2021/05/20/NAT%E4%B8%8EARP%E5%8F%8ADNS/"/>
    <id>https://smilecoding.cn/2021/05/20/NAT%E4%B8%8EARP%E5%8F%8ADNS/</id>
    <published>2021-05-20T07:19:29.000Z</published>
    <updated>2021-05-21T11:53:27.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>NAT是在本地使用私有地址，在需要联网时，转换成全局IP地址的技术。还出现了转换TCP，UDP端口号的NAPT技术。</p><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>在私有网络中如果有一个计算机需要连接外网，则将IP数据包发送出去之后经过NAT(NAPT)的路由转换器，将其转换为公有IP继续发送，并在其中维护一个NAT(NAPT)的路由表，负责外网发送到私有网络的路由。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>无法从外部向私有网络内部建立连接</li><li>NAT的路由表的建立与维护需要时间开销</li><li>NAT路由器一旦重启，所有TCP连接将会重置</li></ol><blockquote><p>第一个缺点的解决是内网穿透技术，（没错，为了解决这个问题，出现了新的技术）也就是使用一台服务器进行辅助，当外网计算机需要连接私有地址时，采用发送信息报文到辅助服务器，让复制服务器发送命令到私有地址让其与该计算机通信</p></blockquote><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>因为在网络层我们只需要考虑IP地址，但是在数据链路层时没有IP地址，所以需要将其转换为MAC地址。</p><h3 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h3><p>当一台电脑需要与目标mac地址发送数据时，首先由该电脑广播一个ARP协议包，询问谁是目标mac，目标mac收到以后回复，否则丢弃该包。(限制了一个网络内MAC地址唯一)</p><p>通常做法：将获得的MAC地址缓存一段时间，之后再寻找路由时可直接使用，而每次ARP协议获得的mac地址将会在表中刷新。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>使用一个服务器，将IP与域名对应。</p><h3 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h3><ol><li><p>首先在本地缓存DNS解析器中检查是否有该地址</p></li><li><p>没有则向域名服务器请求查询，如果还没有则继续上一层</p></li><li>返回后存入DNS解析器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NAT&quot;&gt;&lt;a href=&quot;#NAT&quot; class=&quot;headerlink&quot; title=&quot;NAT&quot;&gt;&lt;/a&gt;NAT&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p
      
    
    </summary>
    
    
      <category term="TCP-IP" scheme="https://smilecoding.cn/categories/TCP-IP/"/>
    
    
      <category term="计算机网络" scheme="https://smilecoding.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>udp</title>
    <link href="https://smilecoding.cn/2021/05/20/udp/"/>
    <id>https://smilecoding.cn/2021/05/20/udp/</id>
    <published>2021-05-20T03:15:04.000Z</published>
    <updated>2021-05-20T03:15:04.824Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>数据链路层</title>
    <link href="https://smilecoding.cn/2021/01/23/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>https://smilecoding.cn/2021/01/23/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2021-01-23T00:59:52.000Z</published>
    <updated>2021-01-28T10:25:34.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>为网络层提供服务。无确认无连接服务(通信质量好，有线传输链路)，有确认无连接服务，有确认面向连接服务（通信质量差的无无线传输服务）。</li><li>链路管理</li><li>组帧</li><li>流量控制</li><li>差错控制</li></ul><a id="more"></a><h3 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h3><ul><li>封装成帧：在数据的前后部分添加首部与尾部，使之成为一个帧。首部与尾部的重要作用是<strong>帧定界</strong></li><li>透明传输：不管发送什么样的比特组合，都应当能在链路上传送。</li></ul><p>组帧的四种方法：</p><ol><li>字符计数法：帧首部使用一个计数字段表示长度。</li><li>字符填充法：帧以SOH(start of header)开始，EOT(end of transmission)结束，在数据部分如果出现SOH或者EOT在其前面加入一个ESC。</li><li>零比特填充法：帧以01111110开始和结束，那么数据部分每出现5个连续的1则添0。</li><li>违规编码法：曼彻斯特编码<strong>由高到低为1</strong>，<strong>由低到高为0</strong>，不会出现<strong>高高或低低</strong></li></ol><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><ul><li>差错检测<ul><li>奇偶校验码：奇校验则是1的数量为奇数。检错效率：50%</li><li>CRC循环冗余码：假设生成多项式G(x)阶数为R，则加R个0，<strong>阶数为多项式N位-1</strong>，数据加0以后除以多项式，余数为冗余码，(做差时用异或解决)</li></ul></li><li>纠错编码<ul><li>海明码：发现双比特错，纠正单比特错。</li></ul></li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>说明一下：部分教材把他放到了传输层里面讲解，特此说明传输层里的流量控制是端对端的，数据链路层是点对点的。控制的是相邻两节点之间数据链路上的<a href="https://baike.baidu.com/item/流量" target="_blank" rel="noopener">流量</a>，而对于<a href="https://baike.baidu.com/item/传输层/4329536" target="_blank" rel="noopener">传输层</a>来说，控制的则是从源到最终目的之间端的流量。</p><p>作用：<strong>匹配发送方和接收方的发送速度</strong>。</p><p><strong>链路层是点对点的流量控制，传输层是端对端的。</strong></p><p>链路层的控制手段是：接收方收不下就不回复确认。</p><p>传输层的控制手段是：接收方给发送方发送一个窗口公告。</p><p>流量控制方法</p><ul><li>停止等待协议：每发送一个帧就停止发送，等待对方确认，收到确认后发送下一个，如果超时(等待时间大于RTT：略大于帧的往返时间)，则发送端重发。发送窗口等于1，接收窗口等于1。同时帧需要编号。</li><li>滑动窗口协议<ul><li>后退N帧协议(GBN)：发送窗口大于1，接收窗口等于1。接收方发送的ACK是累计确认的，当对一个帧确认时，对于其前面的所有帧都确认了。接收窗口有一个变量保存下一个预计帧，当下一个接收到的帧与预计不同时丢弃帧，直到接收为止。(后退N帧的原理)。</li><li>选择重传协议(SR)：发送窗口大于1，接收窗口大于1。详细内容直接看参考文章。</li></ul></li></ul><h3 id="链路管理"><a href="#链路管理" class="headerlink" title="链路管理"></a>链路管理</h3><p>介质访问控制方式</p><ul><li>ALOHA协议：不监听信道，不按时间槽发送，随机重发。</li><li>时隙ALOHA协议：把时间分成若干个相同的时间片，所有用户在时间片开始时同步接入网络信道（执行ALOHA协议），如果冲突，必须等到下一个时间片才能再次发送。</li><li>CSMA，载波监听多路访问协议，每次发送前监听信道是否被占用，没有被占用即可发送数据（缺陷：存在同时发送数据的情况）</li><li>CSMA/CD（适用于有线网络），载波监听多路访问碰撞检测：发送以后检测是否发生碰撞，如果发生了则等待一个时间段再次发送。</li><li>CSMA/CA（适用于无线网络），载波监听多路访问碰撞避免</li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4329290#2" target="_blank" rel="noopener">百度百科-数据链路层</a></p><p><a href="https://www.pianshen.com/article/3214883893/" target="_blank" rel="noopener">流量控制与可靠传输</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为网络层提供服务。无确认无连接服务(通信质量好，有线传输链路)，有确认无连接服务，有确认面向连接服务（通信质量差的无无线传输服务）。&lt;/li&gt;
&lt;li&gt;链路管理&lt;/li&gt;
&lt;li&gt;组帧&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据链路层" scheme="https://smilecoding.cn/categories/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    
    
      <category term="计算机网络" scheme="https://smilecoding.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="https://smilecoding.cn/2021/01/19/%E8%BF%9B%E7%A8%8B/"/>
    <id>https://smilecoding.cn/2021/01/19/%E8%BF%9B%E7%A8%8B/</id>
    <published>2021-01-19T08:09:59.000Z</published>
    <updated>2021-05-21T11:53:40.102Z</updated>
    
    <content type="html"><![CDATA[<p>这里将讲述进程有关定义<a id="more"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>进程顾名思义是进行的程序，也就是说一个程序加载到内存后就变成了进程。</p><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>动态性：进程的实质是程序在<a href="https://baike.baidu.com/item/多道程序系统" target="_blank" rel="noopener">多道程序系统</a>中的一次执行过程，进程是动态产生，动态消亡的。</p><p>并发性：任何进程都可以同其他进程一起并发执行</p><p>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</p><p><a href="https://baike.baidu.com/item/异步性" target="_blank" rel="noopener">异步性</a>：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p><p>结构特征：进程由程序、数据和进程控制块三部分组成。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="7态转换图"><a href="#7态转换图" class="headerlink" title="7态转换图"></a>7态转换图</h3><p><img src="/2021/01/19/%E8%BF%9B%E7%A8%8B/进程转换图.png" alt="进程转换图"></p><h2 id="进程的管理"><a href="#进程的管理" class="headerlink" title="进程的管理"></a>进程的管理</h2><p>进程的管理通过进程控制块（PCB）实现，进程控制块包括一下几点：</p><ul><li><p>标志信息：用于唯一地标识一个进程，常常分由用户使用的外部标识符和被系统使用的内部标识号。常用的标识信息包括进程标识符、父进程的标识符、用户进程名、用户组名等。</p></li><li><p>现场信息：用于保留一个进程在运行时存放在处理器现场中的各种信息,任何一个进程在让出处理器时必须把此时的处理器现场信息保存到进程控制块中,而当该进程重新恢复运行时也应恢复处理器现场。常用的现场信息包括通用寄存器的内容、控制寄存器(如PSW寄存器)的内容、用户堆战指针、系统堆饺指针等。 </p></li><li><p>控制信息，用于管理和调度一个进程。常用的控制信息包括：</p><p>l) 进程的调度相关信息,如进程状态、等待事件和等待原因、进程优先级、队列指引元等</p><p>2) 进程组成信息,如正文段指针、数据段指针</p><p>3) 引进程间通信相关信息,如消息队列指针、信号量等互斥和同步机制</p><p>4) 进程在辅存储器内的地址</p><p>5) CPU资源的占用和使用信息,如时间片余量、进程己占用CPU的时间、进程己执行的时间总和,记账信息</p><p>6) 进程特权信息,如在内存访问和处理器状态方面的特权…</p></li></ul><h2 id="进程创建步骤"><a href="#进程创建步骤" class="headerlink" title="进程创建步骤"></a>进程创建步骤</h2><ol><li>分配进程控制块</li><li>初始化机器寄存器</li><li>初始化页表</li><li>将程序代码从磁盘读入内存</li><li>将处理器状态设置为用户态</li><li>跳转到程序的起始地址（设置程序计数器，此为内核指令，通过硬件将第五步与第六步一起完成）</li></ol><h2 id="进程的缺陷"><a href="#进程的缺陷" class="headerlink" title="进程的缺陷"></a>进程的缺陷</h2><ol><li>无法在同一个时间做两件事。</li><li>如果进程遇到oi则挂起的话，那么进程里面那不用使用到数据的部分也会被挂起无法执行。</li></ol><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>目标：达到极小化平均响应时间，极大化系统吞吐量，保持系统各个部件均处于忙碌状态和提供一种貌似公平的机制。</p><ul><li><p>FCFS先来先服务算法：是一个不能抢占的调度算法，CPU只能在当前进程中出现IO操作主动放弃或运行结束放弃，不能被其他进程抢占。</p><ul><li>缺陷在于不利于小进程的执行，加大了小进程的周转时间</li></ul></li><li><p>时间片轮转算法：由操作系统指定一个时间片，每一个进程运行一个时间片，当一个时间片运行后进程未结束则加入当前就绪队列的末尾，排队等待。</p></li><li><p>短任务优先算法（SJF）：一种非剥夺式算法，总是选取预计作业时间最短的作业优先运行。</p></li><li><p>最短剩余时间优先算法：一种剥夺式算法，总是选取剩余最短作业时间的作业优先运行。</p></li><li><p>最高响应比算法：该算法中的响应比是指作业等待时间与运行比值，响应比公式定义如下：</p><p>响应比 =（等待时间+要求服务时间）/ 要求服务时间,即RR=（w+s）/s=1+w/s，因此响应比一定是大于等于1的。因此不会出现饿死现象</p></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><a href="https://blog.csdn.net/xiaomanong11/article/details/112601868" target="_blank" rel="noopener">进程通信</a></h2><ol><li>管道</li><li>信号量</li><li>socket套接字</li><li>消息队列</li><li>共享内存</li></ol><p><a href="https://zhuanlan.zhihu.com/p/123377340" target="_blank" rel="noopener">参考文章</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里将讲述进程有关定义&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://smilecoding.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="操作系统" scheme="https://smilecoding.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>mybatis学习</title>
    <link href="https://smilecoding.cn/2021/01/11/mybatis%E5%AD%A6%E4%B9%A0/"/>
    <id>https://smilecoding.cn/2021/01/11/mybatis%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-01-11T11:42:21.000Z</published>
    <updated>2021-01-11T14:11:58.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h2><p>Mybatis是一个使用Java实现的<strong>持久层框架</strong>，分装了jdbc操作的很多细节，使开发者只需关注sql语句本身，而无需关注注册驱动，创建链接等繁杂过程。使用<strong>ORM思想实现结果集的封装</strong>。</p><a id="more"></a><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><p>Object Relational Mapping 对象关系映射</p><p>简单来说：</p><p>​                就是把数据库表和实体类及实体属性对应起来，让我们通过操作实体类操作数据库表，而我们需要实体类的属性与数据库的字段名称保持一致。</p><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>表现层：用于展示数据</p><p>业务层：处理业务需求</p><p>持久层：用于与数据库交互</p><h2 id="Mybatis环境搭建"><a href="#Mybatis环境搭建" class="headerlink" title="Mybatis环境搭建"></a>Mybatis环境搭建</h2><p>步骤：</p><ul><li>第一步：引入maven</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.4.5&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.1.47&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li><p>第二步：创建实体类与Dao接口</p></li><li><p>第三步：创建Mybatis的主配置文件</p><ul><li><p>SqlMapConfig.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 配置环境 --&gt;</span><br><span class="line">    &lt;environments default=&quot;mysql&quot;&gt;</span><br><span class="line">        &lt;!--配置mysql的环境--&gt;</span><br><span class="line">        &lt;environment id=&quot;mysql&quot;&gt;</span><br><span class="line">            &lt;!--配置事务类型--&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;!--配置数据库的四个基本信息--&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/MybatisDemo&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;p123456&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--指定映射配置文件位置，映射配置文件指的是每个dao独立的配置文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot; /&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>第四步：创建映射配置文件</p><ul><li>IUserDao.xml</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.itheima.dao.IUserDao"</span>&gt;</span><br><span class="line">    &lt;!--配置查询所有,resultType指向对应的类名--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"findAll"</span> resultType=<span class="string">"com.itheima.Bean.UserBean"</span>&gt;</span><br><span class="line">        select * from user</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>第一个：创建IUserDao.xml和IUserDao.java时名称是为了和我们之前的知识保持一致。在Mybatis中他把持久层的操作接口名称和映射文件也叫做Mapper，所以IUserDao与IUserMapper是一致的。</li><li>第二个：idea中创建目录与创建包是不一样的，创建包时com.itheima.dao是三级目录，而创建目录名为com.itheima.dao是一级目录。</li><li>第三个：mybatis的映射配置文件位置必须与dao接口位置相同。</li><li>第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名</li><li>第五个：映射配置文件的操作配置(select)，id属性的取值必须是dao接口的方法名</li></ul><p>当我们遵从第三四五点时，开发过程中无需再写dao的实现类。</p><h2 id="第一个Mybatis的测试类"><a href="#第一个Mybatis的测试类" class="headerlink" title="第一个Mybatis的测试类"></a>第一个Mybatis的测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">//1. 读取配置文件</span></span><br><span class="line">       InputStream inputStream = Resources.getResourceAsStream(<span class="string">"SqlMapConfig.xml"</span>);</span><br><span class="line">       <span class="comment">//2. 创建sqlSessionFactory工厂</span></span><br><span class="line">       SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">       SqlSessionFactory factory = builder.build(inputStream);</span><br><span class="line">       <span class="comment">//3. 使用工厂生产sqlSession对象</span></span><br><span class="line">       SqlSession session = factory.openSession();</span><br><span class="line">       <span class="comment">//4. 使用SqlSession创建Dao接口的代理对象</span></span><br><span class="line">       IUserDao userDao = session.getMapper(IUserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       <span class="comment">//5. 使用代理对象执行方法</span></span><br><span class="line">       List&lt;UserBean&gt; users = userDao.findAll();</span><br><span class="line">       <span class="keyword">for</span> (UserBean user:</span><br><span class="line">            users) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//6. 释放资源</span></span><br><span class="line">       session.close();</span><br><span class="line">       inputStream.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><p><img src="/2021/01/11/mybatis%E5%AD%A6%E4%B9%A0/Test.png" alt="image-20210111215935023"></p><h3 id="Log4j-properties："><a href="#Log4j-properties：" class="headerlink" title="Log4j.properties："></a>Log4j.properties：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">### 设置###</span><br><span class="line">log4j.rootLogger = debug,stdout,D,E</span><br><span class="line"></span><br><span class="line">### 输出信息到控制抬 ###</span><br><span class="line">log4j.appender.stdout = org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target = System.out</span><br><span class="line">log4j.appender.stdout.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n</span><br><span class="line"></span><br><span class="line">### 输出DEBUG 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.D = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.D.File = E://logs/log.log</span><br><span class="line">log4j.appender.D.Append = true</span><br><span class="line">log4j.appender.D.Threshold = DEBUG </span><br><span class="line">log4j.appender.D.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br><span class="line"></span><br><span class="line">### 输出ERROR 级别以上的日志到=E://logs/error.log ###</span><br><span class="line">log4j.appender.E = org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">log4j.appender.E.File =E://logs/error.log </span><br><span class="line">log4j.appender.E.Append = true</span><br><span class="line">log4j.appender.E.Threshold = ERROR </span><br><span class="line">log4j.appender.E.layout = org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125;  [ %t:%r ] - [ %p ]  %m%n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Mybatis简介&quot;&gt;&lt;a href=&quot;#Mybatis简介&quot; class=&quot;headerlink&quot; title=&quot;Mybatis简介&quot;&gt;&lt;/a&gt;Mybatis简介&lt;/h2&gt;&lt;p&gt;Mybatis是一个使用Java实现的&lt;strong&gt;持久层框架&lt;/strong&gt;，分装了jdbc操作的很多细节，使开发者只需关注sql语句本身，而无需关注注册驱动，创建链接等繁杂过程。使用&lt;strong&gt;ORM思想实现结果集的封装&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="SSM" scheme="https://smilecoding.cn/categories/SSM/"/>
    
    
      <category term="Java" scheme="https://smilecoding.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP1</title>
    <link href="https://smilecoding.cn/2021/01/08/TCP-IP1/"/>
    <id>https://smilecoding.cn/2021/01/08/TCP-IP1/</id>
    <published>2021-01-08T03:24:34.000Z</published>
    <updated>2021-05-20T07:17:13.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP-IP学习"><a href="#TCP-IP学习" class="headerlink" title="TCP/IP学习"></a>TCP/IP学习</h2><a id="more"></a><h3 id="OSi参考模型各个分层的作用"><a href="#OSi参考模型各个分层的作用" class="headerlink" title="OSi参考模型各个分层的作用"></a>OSi参考模型各个分层的作用</h3><div class="table-container"><table><thead><tr><th></th><th>分层名称</th><th style="text-align:center">功能</th><th style="text-align:left">功能概览</th></tr></thead><tbody><tr><td>7</td><td>应用层</td><td style="text-align:center">针对特定应用的协议</td><td style="text-align:left">电子邮件：电子邮件协议；远程登录：远程登陆协议；文件传输：文件传输协议</td></tr><tr><td>6</td><td>表示层</td><td style="text-align:center">设备固有数据与网络标准数据格式的转换</td><td style="text-align:left">接受不同表示形式的信息，如文字流，图像，声音等。</td></tr><tr><td>5</td><td>会话层</td><td style="text-align:center">通信管理，负责建立于断开连接，管理传输层以下的分层</td><td style="text-align:left">何时建立连接，何时断开连接，以及保持多久的连接</td></tr><tr><td>4</td><td>传输层</td><td style="text-align:center">管理两个节点之间的数据通信，保证数据可靠传输</td><td style="text-align:left">是否有数据丢失</td></tr><tr><td>3</td><td>网络层</td><td style="text-align:center">地址管理与路由选择</td><td style="text-align:left">经过那个路由传递到目标地址</td></tr><tr><td>2</td><td>数据链路层</td><td style="text-align:center">互联设备间传送和识别数据帧</td><td style="text-align:left">数据帧与比特流之间的转换</td></tr><tr><td>1</td><td>物理层</td><td style="text-align:center">以0/1代表电压的高低，灯光的闪灭</td><td style="text-align:left">比特流与电子信号之间的转换</td></tr></tbody></table></div><h3 id="TCP-IP分层模型"><a href="#TCP-IP分层模型" class="headerlink" title="TCP/IP分层模型"></a>TCP/IP分层模型</h3><div class="table-container"><table><thead><tr><th>分层名称</th><th>协议</th><th>OSI参考模型</th><th>所在位置</th></tr></thead><tbody><tr><td>应用层</td><td>DNS，URI，HTML，HTTP，TSL/SSL，SMTP，RTP，FTP</td><td>应用层，表示层，会话层</td><td>应用程序</td></tr><tr><td>传输层</td><td>TCP，UDP，UDP-Lite，SCTP，DCCP</td><td>传输层</td><td>操作系统</td></tr><tr><td>网络层</td><td>ARP，IP,ICMP</td><td>互联网层</td><td>操作系统</td></tr><tr><td>网卡层</td><td></td><td>数据链路层</td><td>设备驱动与网络接口</td></tr><tr><td>硬件</td><td></td><td>物理层</td><td>设备驱动与网络接口</td></tr></tbody></table></div><h3 id="TCP-IP通信示例"><a href="#TCP-IP通信示例" class="headerlink" title="TCP/IP通信示例"></a>TCP/IP通信示例</h3><p>假设甲给乙发送邮件：</p><ol><li>应用程序处理：<ol><li>点击发送以后在表示层将编写好的邮件进行编码，然后等待会话层发送邮件</li></ol></li><li>TCP处理：<ol><li>TCP建立连接，发送数据，与断开连接，TCP提供可靠传输。</li><li>为实现可靠传输，在应用层的数据包上再次进行封装一个TCP首部(包含：源端口号，目的端口号，序号(本次发送的是发送端的低级和字节的序列号)，以及校验和) 接着发给IP网络层</li></ol></li><li>IP模块处理<ol><li>IP将TCP传来的数据包当作自己的数据并在TCP首部继续加上IP首部以生成IP数据包。IP首部包括：发送端IP，接收端IP，及判断信息。</li></ol></li><li>网络接口发送</li></ol><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="地址划分"><a href="#地址划分" class="headerlink" title="地址划分"></a>地址划分</h4><ol><li>A类以0开头的ip地址，前8位是网络标识，后面是主机标识</li><li>B类地址以10开头，前16位为网络标识，后面为主机标识</li><li>C类地址以110开头，前24位为网络标识，后面为主机标识</li><li>D类地址以1110开头，前32位为网络标识，常用于多播</li></ol><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>如果只对地址进行划分的话，因为同一个网络标识的必须在同一个链路，所以为细化网络的大小，出现了子网掩码，以减少ip地址的浪费。</p><p>一个子网掩码，前面连续的1标识网络标识的长度，后面是连续的0，表示主机位</p><h4 id="IP数据报的分片与重组"><a href="#IP数据报的分片与重组" class="headerlink" title="IP数据报的分片与重组"></a>IP数据报的分片与重组</h4><p>因为不同类型的数据链路的使用目的不同，所以其MTU就不相同，IP不能被不同的数据链路所限制，所以其分片是寻找最小的MTU进行分片。</p><ol><li>首先将ip的分片标志位置1，如果数据包过大，则丢弃，根据icmp的不可达信息找到数据链路上的MTU。</li><li>下一次继续发送，直到没有ICMP后，将该值缓存10分钟左右，然后重新做一次路径MTU发现</li><li>TCP：根据路径MTU计算出最大段长度MSS，再根据这些进行数据报发送，因此，如果是TCP，再IP地址中不再会对其进行分片</li></ol><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2021/01/08/TCP-IP1/报文格式.jpg" alt="报文格式"></p><ol><li>总长度：表示首部与数据部分合起来的总字节数，一共16位，所以一个IP包理论上最长65535。</li><li>标识：16位，用于表示每一个IP数据包，同一个分片标识相同，如果标识相同，源地址目的地址不一样也不是同一个分片</li><li>标志：一共是3位，第一位必须是0；第二位表示是否可分片，0可以分配，1不可以；第三位表示分片时是否为最后一个包</li><li>片偏移：13位组成，表示每一个字节的位置，最大可表示65535个字节位置</li><li>TTL：8位组成，每经过一个路由器TTL减一，当其为0时丢弃该包。</li><li>协议：8位表示当前协议。</li><li>首部校验和：8位，用于校验ip数据报的首部是否出现差错</li><li>源地址：32位</li><li>目的地址：32位</li><li>可选项，只在进行实验与诊断时使用</li><li>填充，当出现可选字段时使用填充，让其保证是32位的整数倍</li></ol><p>首部校验和，将首部校验和默认为0，将首部所有数值相加后如果大于$2^16$则取低16位并将其+1，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ip</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CheckSum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Long&gt; st = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        insert(st,<span class="number">0x45</span>,<span class="number">0x00</span>);<span class="comment">//版本，及TOS</span></span><br><span class="line">        insert(st,<span class="number">0x00</span>,<span class="number">0x2d</span>);<span class="comment">//总长度</span></span><br><span class="line">        insert(st,<span class="number">0x1e</span>,<span class="number">0xfa</span>);<span class="comment">//标识</span></span><br><span class="line">        insert(st,<span class="number">0x40</span>,<span class="number">0x00</span>);<span class="comment">//片偏移与分片标志</span></span><br><span class="line">        insert(st,<span class="number">0x71</span>,<span class="number">0x06</span>);<span class="comment">//TTL与协议</span></span><br><span class="line">        insert(st,<span class="number">0x00</span>,<span class="number">0x00</span>);<span class="comment">//校验和</span></span><br><span class="line">        insert(st,<span class="number">0x25</span>,<span class="number">0xfc</span>);</span><br><span class="line">        insert(st,<span class="number">0xe5</span>,<span class="number">0xa7</span>);<span class="comment">//源地址</span></span><br><span class="line">        insert(st,<span class="number">0xac</span>,<span class="number">0x1e</span>);</span><br><span class="line">        insert(st,<span class="number">0x28</span>,<span class="number">0xd8</span>);<span class="comment">//目的地址</span></span><br><span class="line">        System.out.printf(<span class="string">"%X\n"</span>,solve(st));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(ArrayList&lt;Long&gt; st,<span class="keyword">long</span> x,<span class="keyword">long</span> y)</span></span>&#123;</span><br><span class="line">        st.add(((x)&lt;&lt;<span class="number">8</span>)+y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(ArrayList&lt;Long&gt; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> cksum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Long it:arr)&#123;</span><br><span class="line">            cksum = cksum + it;</span><br><span class="line">            cksum = (cksum&amp;<span class="number">0xFFFF</span>) + (cksum&gt;&gt;<span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ((~cksum)&amp;<span class="number">0xFFFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0x0a37</span></span><br></pre></td></tr></table></figure><blockquote><p>发送前我们算出校验和后将其放到首部，在接收的时候将所有首部加起来算得的数据校验和是0则首部没有问题，否则首部出现差错，丢弃。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP-IP学习&quot;&gt;&lt;a href=&quot;#TCP-IP学习&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP学习&quot;&gt;&lt;/a&gt;TCP/IP学习&lt;/h2&gt;
    
    </summary>
    
    
      <category term="TCP-IP" scheme="https://smilecoding.cn/categories/TCP-IP/"/>
    
    
      <category term="计算机网络" scheme="https://smilecoding.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>git初学</title>
    <link href="https://smilecoding.cn/2020/12/15/git%E5%88%9D%E5%AD%A6/"/>
    <id>https://smilecoding.cn/2020/12/15/git%E5%88%9D%E5%AD%A6/</id>
    <published>2020-12-15T14:42:45.000Z</published>
    <updated>2021-01-08T05:46:49.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><a id="more"></a><ol><li>初始化本地git仓库<br>git init</li><li>声明远程仓库路径<br>git remote add origin (你的远程项目地址)</li><li>查看仓库地址<br>git remote -v<br>如果结果是正确的则跳过下面的代码。<br>git remote rm origin<br>git remote add origin xxxxx.git</li><li>查看全局配置信息<br>git config —global —list</li><li>检测是否连接上远程仓库<br>git fetch</li></ol><p>E:\workspace\go-xxx&gt;git fetch<br>remote: Enumerating objects: 3, done.<br>remote: Counting objects: 100% (3/3), done.<br>remote: Compressing objects: 100% (2/2), done.<br>remote: Total 3 (delta 0), reused 0 (delta 0)<br>Unpacking objects: 100% (3/3), done.<br>From <a href="https://gitee.com/xxxx/go-xxxx" target="_blank" rel="noopener">https://gitee.com/xxxx/go-xxxx</a></p><ul><li>[new branch]      master     -&gt; origin/master</li></ul><ol><li><p>拉取远程仓库<br>git pull origin master (你要拉取的分支)</p></li><li><p>上传工作<br>git add .<br>git commit -m “first commit”(备注)<br>git push origin master</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h1&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://smilecoding.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://smilecoding.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Http简述</title>
    <link href="https://smilecoding.cn/2020/09/03/Http%E7%AE%80%E8%BF%B0/"/>
    <id>https://smilecoding.cn/2020/09/03/Http%E7%AE%80%E8%BF%B0/</id>
    <published>2020-09-03T05:49:12.000Z</published>
    <updated>2021-05-21T12:17:50.902Z</updated>
    
    <content type="html"><![CDATA[<p>下学期开网络编程和Web，我发现学完这里貌似就可以开发web了。<a id="more"></a></p><h1 id="关于HTTP协议"><a href="#关于HTTP协议" class="headerlink" title="关于HTTP协议"></a>关于HTTP协议</h1><blockquote><p>HTTP: 全称HyperText Transfer Protocol 超文本传输协议</p></blockquote><h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><p>HTTP是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如HTML文件和图像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中间层”，比如代理服务器、网关或者隧道（tunnel）。</p><p>尽管TCP/IP协议是互联网上最流行的应用，HTTP协议中，并没有规定必须使用它或它支持的层。事实上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在TCP/IP协议族使用TCP作为其传输层。</p><p>通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比如”HTTP/1.1 200 OK”，以及返回的内容，如请求的文件、错误消息、或者其它信息。</p><p>在HTTP1.0中每一次做数据传输时都需要重新建立连接，而HTTP1.1中建立的连接可以进行复用，直到没有数据传输而断开。</p><h2 id="HTTP请求流程"><a href="#HTTP请求流程" class="headerlink" title="HTTP请求流程"></a>HTTP请求流程</h2><ol><li><p>客户端连接到Web服务器<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://smilecoding.cn。" target="_blank" rel="noopener">http://smilecoding.cn。</a></p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求体4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></li><li><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><h2 id="关于请求报文"><a href="#关于请求报文" class="headerlink" title="关于请求报文"></a>关于请求报文</h2><blockquote><p>一个请求报文由请求行、请求头部、请求空行和请求体4部分组成。</p></blockquote><ol><li><p>请求行：请求方式+请求Url+使用协议/版本</p></li><li><p>请求头部：提供本身的一些信息</p></li><li><p>请求空行：将请求头部与请求体分隔开</p></li><li><p>请求体：包含请求数据</p></li></ol><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><blockquote><p>1xx消息——请求已被服务器接收，继续处理<br>2xx成功——请求已成功被服务器接收、理解、并接受<br>3xx重定向——需要后续操作才能完成这一请求<br>4xx请求错误——请求含有词法错误或者无法被执行<br>5xx服务器错误——服务器在处理某个正确请求时发生错误</p></blockquote><p><strong><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">有关请求方式请求，请求格式请参考这个</a></strong></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/an-wen/p/11180076.html" target="_blank" rel="noopener">HTTP超级详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下学期开网络编程和Web，我发现学完这里貌似就可以开发web了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Http" scheme="https://smilecoding.cn/categories/Http/"/>
    
    
      <category term="计算机网络" scheme="https://smilecoding.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引原理与实现</title>
    <link href="https://smilecoding.cn/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/"/>
    <id>https://smilecoding.cn/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/</id>
    <published>2020-08-18T14:05:43.000Z</published>
    <updated>2021-05-21T12:17:44.627Z</updated>
    
    <content type="html"><![CDATA[<p>最近要对数据库优化查询速度，于是来了解一下索引。<a id="more"></a></p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>索引：是存储引擎快速找到记录的数据结构。</p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="https://www.cnblogs.com/songwenjie/p/9415016.html" target="_blank" rel="noopener">请参考该篇文章</a></p><p>我在这里仅写一点观后感</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>对于这个存储引擎，所用的数据结构是B+Tree，每一次按存入顺序给每一个数据编号，在需要查询时，对主键进行索引得到编号后带入表中得到数据。可以发现，在存储引擎里面并没有数据，索引和数据分开了，是非聚集索引。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>它所使用的数据结构也是$B+Tree$，但是它本身就是数据文件，支持聚簇索引。</p><p><strong>优点：</strong></p><ol><li>数据访问快。</li><li>把相关数据放到一起，减少磁盘io。</li><li>使用索引覆盖时，可以直接使用页结点的主键值。</li></ol><p><strong>缺点：</strong></p><ol><li>插入速度严重依赖插入顺序。</li><li>更新聚簇索引代价高。</li><li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能会导致“页分裂”。当行的主键值要求必须将这一行插入到已满的页中时，存储引擎会将该页分裂为两个页面来容纳该行，这就是一次页分裂操作，页分裂会导致表占用更多的存储空间。</li></ol><blockquote><p>由最后一点可知为了加速插入速度，我们主键可以使用自增的无关元素。</p></blockquote><h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><p>$MyISAM$与$InnoDB$的底层都是$B+Tree$($BTree$把非叶子节点的data域去掉后在叶子节点直间加双向指针形成)。<br>总的来看就是$BTree$，按照索引从前到后去建立$B+Tree$。该结构形成了最左原则的规定，也就是联合索引$abc$，如果索引时没有$a$的话，在执行索引的时候就不清楚该怎么走,可能出现，无法使用索引。</p><h2 id="索引功能"><a href="#索引功能" class="headerlink" title="索引功能"></a>索引功能</h2><p><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/数据.png" alt="数据"><br><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/无索引.png" alt="无索引"><br>可以看到，在没有索引的时候，查询张三的时候我们一共影响了6行<br><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/有索引.png" alt="有索引"><br>添加了索引以后只影响了1行。</p><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h3 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h3><blockquote><p>alter table table_name add index (column);</p></blockquote><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><blockquote><p>drop index index_name on table_name</p></blockquote><h2 id="索引执行机制"><a href="#索引执行机制" class="headerlink" title="索引执行机制"></a>索引执行机制</h2><p>索引执行最左原则也就是最左边的一定要出现，否则不会使用索引(覆盖查询除外)。具体可以看下图。<br><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/索引.png" alt="索引"><br>这是典型的abc联合索引，然后我做了一个ac联合索引与bc联合索引的测试。<br><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/使用索引.png" alt="ac"><br>可以看到，它使用了索引$idx$。</p><p><img src="/2020/08/18/Mysql%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86/bc使用索引.png" alt="bc"><br>可以看到利用bc查询时，它的key是空，没有使用索引。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近要对数据库优化查询速度，于是来了解一下索引。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mysql" scheme="https://smilecoding.cn/categories/Mysql/"/>
    
    
      <category term="数据库" scheme="https://smilecoding.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>杭电2020多校第六场部分题解</title>
    <link href="https://smilecoding.cn/2020/08/07/%E6%9D%AD%E7%94%B52020%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <id>https://smilecoding.cn/2020/08/07/%E6%9D%AD%E7%94%B52020%E5%A4%9A%E6%A0%A1%E7%AC%AC%E5%85%AD%E5%9C%BA%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</id>
    <published>2020-08-07T08:13:08.000Z</published>
    <updated>2020-09-08T14:37:48.439Z</updated>
    
    <content type="html"><![CDATA[<p>又是罚坐，很奇怪的。<a id="more"></a></p><h1 id="A-Very-Easy-Graph-Problem"><a href="#A-Very-Easy-Graph-Problem" class="headerlink" title="A Very Easy Graph Problem"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6832" target="_blank" rel="noopener">A Very Easy Graph Problem</a></h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给我n个点，m条边，每个点的权值为0或1，边权为$2^i$。求图里面从权值为1的点到权值为0的点的所有最短路径的和。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>关于这题我们很容易可以发现，对于最短路来说，后面的点的长度大于前面所有的边权的总和。因此我们可以知道，这个最短路的图其实就是一个最小生成树。题意就转变成：在一棵树上，由权值为1的点走到权值为的点0的。接下来开始计算每一条边的贡献，通过计算边左右所包含的1和0来得知该边可能会被经过多少次而得出该边的贡献。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">int a[N],b[N],fa[N],ans=0;</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">struct EDGE&#123;</span><br><span class="line">    int pre,to,w;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],vis[N],son1[N],son0[N],tot=0,zero,one;</span><br><span class="line">void init()&#123;</span><br><span class="line">    tot=1,ans=0,zero=one=0;</span><br><span class="line">    memset(head,0,sizeof head);</span><br><span class="line">    memset(son0,0,sizeof son0);</span><br><span class="line">    memset(son1,0,sizeof son1);</span><br><span class="line">    memset(vis,0,sizeof vis);</span><br><span class="line">&#125;</span><br><span class="line">int get(int x)&#123;</span><br><span class="line">    return fa[x]==x?x:fa[x] = get(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].to=v;</span><br><span class="line">    ed[tot].w=w;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int p)&#123;</span><br><span class="line">    vis[x]=1;</span><br><span class="line">    for(int i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v=ed[i].to;</span><br><span class="line">        if(p!=v)&#123;</span><br><span class="line">            dfs(v,x);</span><br><span class="line">            son0[x]+=son0[v];</span><br><span class="line">            son1[x]+=son1[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a[x]==1) son1[x]++;</span><br><span class="line">    else son0[x]++;</span><br><span class="line">    for(int i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v=ed[i].to,w = ed[i].w;</span><br><span class="line">        if(p!=v)&#123;</span><br><span class="line">            ans=(ans+1ll * w * son0[v] % mod * (one-son1[v])%mod)%mod;</span><br><span class="line">            ans=(ans+1ll * w * son1[v] % mod * (zero-son0[v])%mod)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        init();</span><br><span class="line">        scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">        rep(i,1,n)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;a[i]);</span><br><span class="line">            fa[i]=i;</span><br><span class="line">            if(a[i]) one++;</span><br><span class="line">            else zero++;</span><br><span class="line">        &#125;</span><br><span class="line">        int cur = 1;</span><br><span class="line">        rep(i,1,m)&#123;</span><br><span class="line">            int x,y;</span><br><span class="line">            scanf(&quot;%d %d&quot;,&amp;x,&amp;y);</span><br><span class="line">            cur = (cur*2)%mod;</span><br><span class="line">            int p=get(x),q=get(y);</span><br><span class="line">            if(p!=q)&#123;</span><br><span class="line">                fa[p]=q;</span><br><span class="line">                add(x,y,cur);</span><br><span class="line">                add(y,x,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(1,1);</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无参考资料"><a href="#无参考资料" class="headerlink" title="无参考资料"></a>无参考资料</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是罚坐，很奇怪的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://smilecoding.cn/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>杭电2020第一场补题</title>
    <link href="https://smilecoding.cn/2020/07/31/%E6%9D%AD%E7%94%B52020%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98/"/>
    <id>https://smilecoding.cn/2020/07/31/%E6%9D%AD%E7%94%B52020%E7%AC%AC%E4%B8%80%E5%9C%BA%E8%A1%A5%E9%A2%98/</id>
    <published>2020-07-31T03:44:30.000Z</published>
    <updated>2020-08-06T14:45:28.112Z</updated>
    
    <content type="html"><![CDATA[<p>身体不适，这个暑假补题怕是只能尽量了。<a id="more"></a></p><h1 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h1><h2 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h2><ol><li>二次剩余，对于$\sqrt5$去进行取模时对$\sqrt5$实数化。</li><li>欧拉降幂($a^b \equiv a^{b\%(mod-1)}\%mod$)</li><li>斐波拉契通项式：$F(n) = \frac{1}{\sqrt5}* (\frac{1+\sqrt5}{2}-\frac{1-\sqrt5}{2})$</li></ol><p>由于这题的化简过程有点复杂，字有点丑，就不发截图了。直接上的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">const int mod = 1e9+9;</span><br><span class="line">const int sqr_5 = 383008016;</span><br><span class="line">const int A = 691504013;//(1+sqr_5)*inv(2)</span><br><span class="line">const int B = 308495997;//(1-sqr_5)*inv(2)</span><br><span class="line">const int A1 = 276601605;//inv(sqr_5)</span><br><span class="line">int noc[N],inoc[N],cura[N],curb[N];</span><br><span class="line">int qpow(int a,int b)&#123;</span><br><span class="line">    int tmp = a,ans = 1;</span><br><span class="line">    while(b)&#123;</span><br><span class="line">        if(b&amp;1)&#123;</span><br><span class="line">            ans = 1ll*ans*tmp%mod; </span><br><span class="line">        &#125;</span><br><span class="line">        tmp=1ll*tmp*tmp%mod;</span><br><span class="line">        b&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans%mod;</span><br><span class="line">&#125;</span><br><span class="line">void init()&#123;</span><br><span class="line">    noc[0]=1,inoc[0]=1;//noc是阶乘，inoc是结成的逆元。</span><br><span class="line">    int i;</span><br><span class="line">    rep(i,1,N-1)&#123;</span><br><span class="line">        noc[i]=(1ll*noc[i-1]*i)%mod;</span><br><span class="line">        inoc[i]=qpow(noc[i],mod-2)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int Com(int n,int m)&#123;</span><br><span class="line">    if(m&gt;n) return 0;</span><br><span class="line">    return (1ll*noc[n]*inoc[m]%mod*inoc[n-m]%mod)%mod;  </span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,i,j,t=0,k;</span><br><span class="line">    ll n,c;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    init();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%lld %lld %d&quot;,&amp;n,&amp;c,&amp;k);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        int a=qpow(A,c%(mod-1)),b=qpow(B,c%(mod-1));//欧拉降幂</span><br><span class="line">        //printf(&quot;%d %d\n&quot;,a,b);</span><br><span class="line">        cura[0]=curb[0]=1;</span><br><span class="line">        for(i=1;i&lt;=k;i++)&#123;</span><br><span class="line">            cura[i]=1ll*cura[i-1]*a%mod;</span><br><span class="line">            curb[i]=1ll*curb[i-1]*b%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0;i&lt;=k;i++)&#123;</span><br><span class="line">            int q = 1ll*cura[k-i]*curb[i]%mod;//公比</span><br><span class="line">            int tmp=0;</span><br><span class="line">            if(q==1)&#123;</span><br><span class="line">                tmp = n%mod;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                tmp = 1ll*q * (qpow(q,(n%(mod-1)))-1)%mod*(qpow(q-1,mod-2))%mod;</span><br><span class="line">            &#125;</span><br><span class="line">            //printf(&quot;%d %dssss\n&quot;,q,tmp);</span><br><span class="line">            int flag=1;</span><br><span class="line">            if(i&amp;1) flag=-1;</span><br><span class="line">            ans = (ans+1ll*flag*Com(k,i)%mod*tmp)%mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,(1ll*(ans%mod+mod)%mod*qpow(A1, k)%mod+mod)%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="1009"><a href="#1009" class="headerlink" title="1009"></a>1009</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给n个机器人，每一个机器人有一个初始位置$s$和加速度$a$，初速度都是0，在0时刻一同往同一个方向出发，问有多少个机器人出现过领先其他所有机器人的时刻。</p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>由题可知：</p><blockquote><p> 机器人的位置$y=\frac{1}{2}at^2+s$</p></blockquote><p>机器人之间超过的话也就是<script type="math/tex">y0>y1\rightarrow \frac{1}{2}a_1t^2+s_1>\frac{1}{2}a_2t^2+s_2</script><br>化简可得：</p><script type="math/tex; mode=display">t^2 > \frac{2(-s_1-(-s_2))}{a_1-a_2}(当且仅当a_1>a_2)</script><p>仔细观察可以发现，这个表达式可以解读为，当只要$\frac{-2s_1}{a_1}&gt;\frac{-2s_2}{a_2}$则$t$有解，可以超越。<br>我们把$-2s$看成$y$轴，$a$看成$x$轴，那么上述算式就是看斜率了，<br>我们先把所有机器人<strong>去重</strong>后按照$a$从小到大排序，接着对于排序后的机器人从第一个开始枚举机器人维护一个斜率单调上升队列(在队列里面表示该机器人能超越已经枚举过的所有机器人)。</p><blockquote><p>维护方法：<br>第一步：保证斜率单调上升，枚举一个机器人后把它的斜率与队列尾部的机器人的斜率。(保证该机器人能超越队列里所有机器人)<br>第二步：每枚举一个机器人时在加入队列尾部时注意它超过队列最后一个时，队列的最后一个有没有超过倒数第二个，如果超过了，队列的最后一个就不能超越所有机器人，也要弹出。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e5+50;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">pair&lt;ll,ll&gt; a[N];</span><br><span class="line">int q[N],vis[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">        rep(i,1,n)&#123;</span><br><span class="line">            scanf(&quot;%lld %lld&quot;,&amp;a[i].second,&amp;a[i].first);</span><br><span class="line">            a[i].second*=(-2);</span><br><span class="line">            vis[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a+1,a+1+n);</span><br><span class="line">        rep(i,2,n)&#123;</span><br><span class="line">            if(a[i].first==a[i-1].first&amp;&amp;a[i].second==a[i-1].second) vis[i]=vis[i-1] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int tot=0;</span><br><span class="line">        q[++tot]=1;</span><br><span class="line">        rep(i,2,n)&#123;</span><br><span class="line">            if(a[i].first==a[i-1].first) continue;</span><br><span class="line">            while(tot&gt;0&amp;&amp;a[i].second&lt;=a[q[tot]].second) tot--;//第一步：判断斜率单调上升</span><br><span class="line">            while(tot&gt;1)&#123;</span><br><span class="line">                j = q[tot],k = q[tot-1];</span><br><span class="line">                if((a[i].second-a[j].second)*(a[j].first-a[k].first) &lt;= (a[j].second-a[k].second)*(a[i].first-a[j].first)) tot--;//判断最后机器人是否能做leader</span><br><span class="line">                else break;</span><br><span class="line">            &#125;</span><br><span class="line">            q[++tot] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        int ans = 0;</span><br><span class="line">        rep(i,1,tot) if(!vis[q[i]]) ans++;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1011"><a href="#1011" class="headerlink" title="1011"></a>1011</h1><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给一个字符串，对于他的任意前缀求一个最小字典序的后缀，用该后缀开始的位置求和。</p><h3 id="补充知识点Lyndon串"><a href="#补充知识点Lyndon串" class="headerlink" title="补充知识点Lyndon串"></a><a href="https://oi-wiki.org/string/lyndon/" target="_blank" rel="noopener">补充知识点Lyndon串</a></h3><blockquote><p>对于该知识点我个人为这是我见过写的最好的，就直接看吧，反正我就看懂了它。</p></blockquote><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>学会Lyndon串以后再来看这题！嗯？这不就是板子？直接看代码吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">#define fli freopen(&quot;D://code//ACM//std.txt&quot;,&quot;r&quot;,stdin);</span><br><span class="line">char a[N];</span><br><span class="line">int ans = 0,num[N];</span><br><span class="line">const int mod = 1e9+7;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,a+1);</span><br><span class="line">        int len = strlen(a+1);</span><br><span class="line">        i=1;</span><br><span class="line">        while(i&lt;=len)&#123;</span><br><span class="line">            num[i]=i;</span><br><span class="line">            j=i+1,k=i;</span><br><span class="line">            while(j&lt;=len&amp;&amp;a[k]&lt;=a[j])&#123;</span><br><span class="line">                if(a[k]&lt;a[j]) k=i,num[j]=i;//不相等他的Lyndon串就是从i开始</span><br><span class="line">                else num[j]=num[k]+j-k,k++;//相等直接计算他的循环节就好了。</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            while(i&lt;=k)&#123;</span><br><span class="line">                i+=j-k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans=0;</span><br><span class="line">        int cur=1;</span><br><span class="line">        rep(i,1,len)&#123;</span><br><span class="line">            //printf(&quot;%dsss\n&quot;,num[i]);</span><br><span class="line">            ans=(1ll*ans+1ll*cur * num[i])%mod;</span><br><span class="line">            cur = 1ll * cur * 1112 %mod;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/qq_43202683/article/details/107508164" target="_blank" rel="noopener">一个大佬的题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;身体不适，这个暑假补题怕是只能尽量了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://smilecoding.cn/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu18.04安装docker安装酷Q</title>
    <link href="https://smilecoding.cn/2020/06/06/Ubuntu18%E5%AE%89%E8%A3%85%E9%85%B7Q/"/>
    <id>https://smilecoding.cn/2020/06/06/Ubuntu18%E5%AE%89%E8%A3%85%E9%85%B7Q/</id>
    <published>2020-06-06T02:20:38.000Z</published>
    <updated>2020-06-14T02:40:39.774Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。<a id="more"></a></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>这里我们首先安装Docker，关于什么是Docker，请点击<a href="https://www.zhihu.com/question/28300645" target="_blank" rel="noopener">知乎问答</a>。关于这里的说法我大致现总结一下，一家之见，如有不足，请私聊点出。<br>这里同样的以集装箱做比喻，我们在Docker上部署的每一个应用都相当于一个集装箱，每个集装箱之间互不影响，这样就解决了关于应用之间的冲突问题，所以我们部署的所有应用都可以使用一艘船(服务器)去进行运输，节省了开支与时间。</p><h2 id="卸载旧docker"><a href="#卸载旧docker" class="headerlink" title="卸载旧docker"></a>卸载旧docker</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br></pre></td></tr></table></figure><h2 id="使用存储库安装"><a href="#使用存储库安装" class="headerlink" title="使用存储库安装"></a>使用存储库安装</h2><ol><li><p>更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li></ol><p>9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   rsa4096 2017-02-22 [SCEA]</span><br><span class="line">      9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid           [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   rsa4096 2017-02-22 [S]</span><br></pre></td></tr></table></figure></p><h2 id="安装docker引擎"><a href="#安装docker引擎" class="headerlink" title="安装docker引擎"></a>安装docker引擎</h2><ol><li>更新apt程序包索引，并安装最新版本的Docker Engine和容器，或转到下一步以安装特定版本：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li></ol><h2 id="检验docker是否成功"><a href="#检验docker是否成功" class="headerlink" title="检验docker是否成功"></a>检验docker是否成功</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br></pre></td></tr></table></figure><h1 id="拉取酷Q镜像"><a href="#拉取酷Q镜像" class="headerlink" title="拉取酷Q镜像"></a>拉取酷Q镜像</h1><h2 id="拉取命令"><a href="#拉取命令" class="headerlink" title="拉取命令"></a>拉取命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull coolq/wine-coolq</span><br></pre></td></tr></table></figure><h2 id="查看是否成功"><a href="#查看是否成功" class="headerlink" title="查看是否成功"></a>查看是否成功</h2><p>镜像名称是：$coolq/wine-coolq$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker images   (查看镜像)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 运行命令</span><br></pre></td></tr></table></figure><br>docker run —name=coolq -d -p 9000:9000 -v /home/wt/coolq/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=905584041 coolq/wine-coolq<br>```<br>释义</p><blockquote><p>—name=coolq是将镜像命名为coolq</p><p>9000:9000是开放9000端口</p><p>/home/wt/coolq/coolq-data:/home/user/coolq 宿主机路径：酷q数据文件路径。</p><p>VNC_PASSWD=12345678:网页登陆密码</p><p>COOLQ_ACCOUNT=905584041登陆的qq好</p><p>coolq/wine-coolq 部署的镜像名称</p></blockquote><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>关于docker的报错，今天一共出现三种，如下：</p><ol><li>部署的端口冲突，我们改一下端口就好了</li><li>部署的应用的image已存在，两种修复办法，第一改掉名称，第二先暂停重复的应用<code>(docker stop (container id))</code>然后删除它<code>(docker rm (container id))</code>。</li><li>部署完以后无效，我这里是因为云服务器没有打开部署的端口号，到服务器找到安全组打开端口以后运行流畅。</li></ol><h2 id="部分docker命令"><a href="#部分docker命令" class="headerlink" title="部分docker命令"></a>部分docker命令</h2><div class="table-container"><table><thead><tr><th style="text-align:center">功能</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">部署</td><td style="text-align:center">docker pull 应用名</td></tr><tr><td style="text-align:center">查看部署状态</td><td style="text-align:center">docker ps -a</td></tr><tr><td style="text-align:center">暂停应用</td><td style="text-align:center">(docker stop (container id))</td></tr><tr><td style="text-align:center">删除已部署应用</td><td style="text-align:center">(docker rm (container id))</td></tr></tbody></table></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看了一下官方部署文档里面的下载命令，说真的，我居然没看懂，所以我要在这里写下来他们的差异。</p><blockquote><p>install与rpm： 关于这两个的差异的话呢，主要体现在对于安装有依赖包的软件，用yum命令特别方便，如果用rpm命令，就必须要先装依赖包再装软件包，而yum命令会直接匹配依赖包然后直接安装。</p><p>dokg与apt-get：dpkg只能安装已经下载到本地机器上的deb包. apt-get能在线下载并安装deb包,能更新系统,<br>且还能自动处理包与包之间的依赖问题,这个是dpkg工具所不具备的。</p><p>apt方式安装<br>apt-get是debian，ubuntu发行版的包管理工具，与红帽中的yum工具非常类似。<br>apt-get命令一般需要root权限执行，所以一般跟着sudo命令例sudo apt-get xxxx<br>apt-get install packagename——安装一个新软件包（参见下文的aptitude）<br>apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）<br>apt-get —purge remove packagename——卸载一个已安装的软件包（删除配置文件）<br>dpkg —force-all —purge packagename ——有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。<br>apt-get autoremove——因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件。<br>apt-get autoclean——定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。<br>apt-get clean——这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。<br>apt-get upgrade——更新所有已安装的软件包<br>apt-get dist-upgrade——将系统升级到新版本<br>apt-cache search string——在软件包列表中搜索字符串<br>apt-cache showpkg pkgs——显示软件包信息。<br>apt-cache stats——查看库里有多少软件<br>apt-cache dumpavail——打印可用软件包列表。<br>apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。<br>apt-cache pkgnames——打印软件包列表中所有软件包的名称</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://blog.csdn.net/qq_38901815/article/details/102978391" target="_blank" rel="noopener">16.04部署酷Q</a></li><li><a href="https://docs.docker.com/engine/install/ubuntu/" target="_blank" rel="noopener">docker官方部署文档</a></li><li><a href="https://blog.csdn.net/zyjustin9/article/details/84536663?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2" target="_blank" rel="noopener">linux的多种安装方式</a></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。&lt;/p&gt;
    
    </summary>
    
    
      <category term="环境配置" scheme="https://smilecoding.cn/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Linux" scheme="https://smilecoding.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Calendar类</title>
    <link href="https://smilecoding.cn/2020/06/05/Calenda/"/>
    <id>https://smilecoding.cn/2020/06/05/Calenda/</id>
    <published>2020-06-05T09:57:34.000Z</published>
    <updated>2020-06-05T12:09:49.185Z</updated>
    
    <content type="html"><![CDATA[<p>自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。<a id="more"></a></p><h1 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h1><p>所述Calendar类是一个抽象类，可以为在某一特定时刻和一组之间的转换的方法calendar fields如YEAR ， MONTH ， DAY_OF_MONTH ， HOUR ，等等，以及用于操纵该日历字段，如获取的日期下个星期。 时间上的瞬间可以用毫秒值表示，该值是从1970年1月1日00:00 00：00.000 GMT（Gregorian）的Epoch的偏移量。 </p><h2 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 使用默认时区和语言环境获得一个日历</span><br><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">// 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1</span><br><span class="line">System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));</span><br><span class="line">System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1));       </span><br><span class="line">System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));</span><br><span class="line">System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure><h2 id="设置时间"><a href="#设置时间" class="headerlink" title="设置时间"></a>设置时间</h2><blockquote><p>统一设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">// 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1</span><br><span class="line">// cal.set(year, month, date, hourOfDay, minute, second);</span><br><span class="line">cal.set(2018, 1, 15, 23, 59, 59);</span><br></pre></td></tr></table></figure><br>单个设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 或者6个字段分别进行设置，由于月份下标从0开始赋值月份要-1</span><br><span class="line">cal.set(Calendar.YEAR, 2018);</span><br><span class="line">cal.set(Calendar.MONTH, Calendar.FEBRUARY);</span><br><span class="line">cal.set(Calendar.DAY_OF_MONTH, 15);</span><br><span class="line">cal.set(Calendar.HOUR_OF_DAY, 23);</span><br><span class="line">cal.set(Calendar.MINUTE, 59);</span><br><span class="line">cal.set(Calendar.SECOND, 59);</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure></p><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>使用add方法对某个时间进行修改，如果月份修改后该日子不存在，会将不存在的日期归为当月日历的最后一天。<br>时间修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">System.out.println(cal.getTime());</span><br><span class="line">cal.set(2018, 1, 15, 23, 59, 59);</span><br><span class="line">cal.add(Calendar.SECOND, 1);//加一秒</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure><br>月份修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Calendar cal = Calendar.getInstance();</span><br><span class="line">cal.set(2018, 1, 31, 8, 0, 0);</span><br><span class="line">System.out.println(cal.getTime());</span><br><span class="line">cal.add(Calendar.MONTH, 1);//变为2018/2/28</span><br><span class="line">System.out.println(cal.getTime());</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://smilecoding.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="https://smilecoding.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Linux用户权限管理</title>
    <link href="https://smilecoding.cn/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/"/>
    <id>https://smilecoding.cn/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</id>
    <published>2020-06-03T03:45:32.000Z</published>
    <updated>2020-06-03T13:25:40.163Z</updated>
    
    <content type="html"><![CDATA[<p>关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。<a id="more"></a></p><h1 id="档案的基本权限"><a href="#档案的基本权限" class="headerlink" title="档案的基本权限"></a>档案的基本权限</h1><p>这里为表达方便，我把文件和目录统称为档案。</p><h2 id="档案的属性"><a href="#档案的属性" class="headerlink" title="档案的属性"></a>档案的属性</h2><p>对于一个档案我们首先在目录里面使用&lt;<strong>ll</strong>&gt;命令，查看每一个档案的属性，下图是属性的介绍表<br><img src="/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/档案属性.gif" alt="Linux属性"></p><blockquote><p>第一栏是档案的类型权限。<br><img src="/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/档案权限.gif" alt="Linux档案权限"><br>第一个字元代表这个档案是『目录、档案或连结档等等』：</p><blockquote><p>当为[ d ]则是目录。<br>当为[ - ]则是档案。<br>若是[ l ]则表示为连结档(link file)；<br>若是[ b ]则表示为装置档里面的可供储存的周边设备(可随机存取装置)；<br>若是[ c ]则表示为装置档里面的序列埠设备，例如键盘、滑鼠(一次性读取装置)。<br>接下来的字元中，以三个为一组，且均为『rwx』的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。<br>第一组为『档案拥有者可具备的权限』，该档案的拥有者可以读写，但不可执行；<br>第二组为『加入此群组之帐号的权限』；<br>第三组为『非本人且没有加入本群组之其他帐号的权限』。</p></blockquote><p>第二栏是与该文件的连接数<br>每个档案都会将他的权限与属性记录到档案系统的i-node中，不过，我们使用的目录树却是使用档名来记录，因此每个档名就会连结到一个i-node啰！这个属性记录的，就是有多少不同的档名连结到相同的一个i-node号码去就是了。</p><p>第三栏是账户拥有者</p><p>第四栏表示这个档案的所属群组<br>在Linux系统下，你的帐号会加入于一个或多个的群组中。举刚刚我们提到的例子，class1, class2, class3均属于projecta这个群组，假设某个档案所属的群组为projecta，且该档案的权限如图5.2.2所示(-rwxrwx—-) ，则class1, class2, class3三人对于该档案都具有可读、可写、可执行的权限(看群组权限)。但如果是不属于projecta的其他帐号，对于此档案就不具有任何权限了。</p><p>第五栏为这个档案的容量大小，预设单位为bytes；</p><p>第六栏为修改日期<br>这一栏的内容分别为日期(月/日)及时间。如果这个档案被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。如下所示：</p><p>第7栏为文档名称<br>这个栏位就是档名了。比较特殊的是：如果档名之前多一个『 . 』，则代表这个档案为『隐藏档』，例如上表中的.config那一行，该档案就是隐藏档。你可以使用『ls』及『ls -a』这两个指令去感受一下什么是隐藏档啰！</p></blockquote><h2 id="文档的重要性"><a href="#文档的重要性" class="headerlink" title="文档的重要性"></a>文档的重要性</h2><p>与Windows系统不一样的是，在Linux系统当中，每一个档案都多加了很多的属性进来，尤其是群组的概念，这样有什么用途呢？其实，最大的用途是在『资料安全性』上面的。</p><blockquote><p>系统保护的功能：<br>举个简单的例子，在你的系统中，关于系统服务的档案通常只有root才能读写或者是执行，例如/etc/shadow这一个帐号管理的档案，由于该档案记录了你系统中所有帐号的资料，因此是很重要的一个设定档，当然不能让任何人读取(否则密码会被窃取啊)，只有root才能够来读取啰！所以该档案的权限就会成为[ ————— ]啰！咦！所有人都不能使用？没关系，root基本上是不受系统的权限所限制的，所以无论档案权限为何，预设root都可以存取喔！</p><p>团队开发软体或资料共用的功能：<br>此外，如果你有一个软体开发团队，在你的团队中，你希望每个人都可以使用某一些目录下的档案，而非你的团队的其他人则不予以开放呢？以上面的例子来说，testgroup的团队共有三个人，分别是test1, test2, test3，那么我就可以将团队所需的档案权限订为[ -rwxrws—- ]来提供给testgroup的工作团队使用啰！(怎么会有s呢？没关系，这个我们在后续章节再讲给你听！)</p><p>未将权限设定妥当的危害：<br>再举个例子来说，如果你的目录权限没有作好的话，可能造成其他人都可以在你的系统上面乱搞啰！例如本来只有root才能做的开关机、ADSL的拨接程式、新增或删除使用者等等的指令，若被你改成任何人都可以执行的话，那么如果使用者不小心给你重新开机啦！重新拨接啦！等等的！那么你的系统不就会常常莫名其妙的挂掉啰！而且万一你的使用者的密码被其他不明人士取得的话，只要他登入你的系统就可以轻而易举的执行一些root的工作！</p></blockquote><p>可怕吧！因此，在你修改你的linux档案与目录的属性之前，一定要先搞清楚，什么资料是可变的，什么是不可变的！千万注意啰！接下来我们来处理一下档案属性与权限的变更吧！</p><h2 id="改变档案的属性和权限"><a href="#改变档案的属性和权限" class="headerlink" title="改变档案的属性和权限"></a>改变档案的属性和权限</h2><blockquote><p>改变所属群组, chgrp<br>改变一个档案的群组真是很简单的，直接以chgrp来改变即可，咦！这个指令就是change group的缩写嘛！这样就很好记了吧！^_^。不过，请记得，要被改变的群组名称必须要在/etc/group档案内存在才行，否则就会显示错误！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chgrp [-R] dirname/filename ... </span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案、目录</span><br><span class="line">     都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。</span><br><span class="line">范例： </span><br><span class="line">[root@study ~]# chgrp users initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">-rw-r--r--. 1 root users 1864 May 4 18:01 initial-setup -ks.cfg</span><br><span class="line">[root@study ~]# chgrp testing initial-setup-ks.cfg </span><br><span class="line">chgrp: invalid group: `testing&apos; &lt;==发生错误讯息啰～找不到这个群组名～</span><br></pre></td></tr></table></figure></p><p>改变档案拥有者, chown<br>如何改变一个档案的拥有者呢？很简单呀！既然改变群组是change group，那么改变拥有者就是change owner啰！BINGO！那就是chown这个指令的用途，要注意的是，使用者必须是已经存在系统中的帐号，也就是在/etc/passwd 这个档案中有纪录的使用者名称才能改变。</p></blockquote><p>chown的用途还满多的，他还可以顺便直接修改群组的名称呢！此外，如果要连目录下的所有次目录或档案同时更改档案拥有者的话，直接加上-R的选项即可！我们来看看语法与范例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chown [-R]帐号名称档案或目录 </span><br><span class="line">[root@study ~]# chown [-R]帐号名称:群组名称档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更</span><br><span class="line"></span><br><span class="line">范例：将initial-setup-ks.cfg的拥有者改为bin这个帐号： </span><br><span class="line">[root@study ~]# chown bin initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">-rw-r- -r--. 1 bin   users 1864 May 4 18:01 initial-setup-ks.cfg</span><br><span class="line"></span><br><span class="line">范例：将initial-setup-ks.cfg的拥有者与群组改回为root： </span><br><span class="line">[root@study ~]# chown root:root initial-setup-ks.cfg </span><br><span class="line">[root@study ~]# ls -l </span><br><span class="line">- rw-r--r--. 1 root root 1864 May 4 18:01 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure></p><p>事实上，chown也可以使用『chown user.group file』，亦即在拥有者与群组间加上小数点『 . 』也行！不过很多朋友设定帐号时，喜欢在帐号当中加入小数点(例如vbird.tsai这样的帐号格式)，这就会造成系统的误判了！所以我们比较建议使用冒号『:』来隔开拥有者与群组啦！此外，<strong>chown也能单纯的修改所属群组呢</strong>！例如『chown .sshd initial-setup-ks.cfg』就是修改群组～看到了吗？就是那个小数点的用途！</p><blockquote><p>改变权限, chmod<br>这里只讲一种，另外一种u、g、o、a代名词的自行了解。<br>Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：<br>r:4<br>w:2<br>x:1<br>每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—-] 分数则是：<br>owner = rwx = 4+2+1 = 7<br>group = rwx = 4+2+1 = 7<br>others= —- = 0+0+0 = 0<br>所以等一下我们设定权限的变更时，该档案的权限数字就是770啦！变更权限的指令chmod的语法是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@study ~]# chmod [-R] xyz档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。</span><br><span class="line">-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="档案权限介绍"><a href="#档案权限介绍" class="headerlink" title="档案权限介绍"></a>档案权限介绍</h2><p>对于档案的权限这里是两种，分别分为文件的权限和目录的权限</p><ol><li>当是一个文件的时候，『r』就是浏览文件，『w』就是修改文件，『x』就是执行文件</li><li>当该档案是一个目录的时候『r』是查看目录下的所有档案或档案信息，『w』是修改当前目录的文档信息，『x』是是否能进入该目录的权限。</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">目录</th><th style="text-align:left">放置档案内容</th></tr></thead><tbody><tr><td style="text-align:center">/bin</td><td style="text-align:left">系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。</td></tr><tr><td style="text-align:center">/boot</td><td style="text-align:left">这个目录主要在放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub2这个开机管理程式，则还会存在/boot/grub2/这个目录喔！</td></tr><tr><td style="text-align:center">/dev</td><td style="text-align:left">在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/loop<em>, / dev/sd</em>等等</td></tr><tr><td style="text-align:center">/etc</td><td style="text-align:left">系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中喔。比较重要的档案有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在/etc/目录下喔：&lt;\br&gt;/etc/opt(必要)：这个目录在放置第三方协力软体/opt的相关设定档/etc/X11/(建议)：与X Window有关的各种设定档都在这里，尤其是xorg.conf这个X Server的设定档。&lt;\br&gt;/etc/sgml/(建议)：与SGML格式有关的各项设定档&lt;\br&gt;/etc/xml/(建议)：与XML格式有关的各项设定档</td></tr><tr><td style="text-align:center">/lib</td><td style="text-align:left">系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。另外FHS还要求底下的目录必须要存在：&lt;\br&gt;/lib/modules/：这个目录主要放置可抽换式的核心相关模组(驱动程式)喔！&lt;\br&gt;/media    media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。</td></tr><tr><td style="text-align:center">/mnt</td><td style="text-align:left">如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。</td></tr><tr><td style="text-align:center">/opt</td><td style="text-align:left">这个是给第三方协力软体放置的目录。什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！</td></tr><tr><td style="text-align:center">/run</td><td style="text-align:left">早期的FHS 规定系统开机后所产生的各项资讯应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用记忆体来模拟，因此效能上会好很多！</td></tr><tr><td style="text-align:center">/sbin</td><td style="text-align:left">Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他使用者最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。</td></tr><tr><td style="text-align:center">/srv</td><td style="text-align:left">srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。常见的服务例如WWW, FTP等等。举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。不过，系统的服务资料如果尚未要提供给网际网路任何人浏览的话，预设还是建议放置到/var/lib 底下即可。</td></tr><tr><td style="text-align:center">/tmp</td><td style="text-align:left">这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除唷！</td></tr></tbody></table></div><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://linux.vbird.org/linux_basic/0210filepermission.php#table2.1.1" target="_blank" rel="noopener">鸟哥的Linux私房菜</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://smilecoding.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://smilecoding.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CCPC Wannafly Winter Camp Day3</title>
    <link href="https://smilecoding.cn/2020/05/19/DAY3/"/>
    <id>https://smilecoding.cn/2020/05/19/DAY3/</id>
    <published>2020-05-19T02:35:01.000Z</published>
    <updated>2020-06-03T03:20:17.315Z</updated>
    
    <content type="html"><![CDATA[<p>最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。<a id="more"></a></p><h1 id="G火山哥周游世界"><a href="#G火山哥周游世界" class="headerlink" title="G火山哥周游世界"></a>G火山哥周游世界</h1><p>赛时想到树，但是没有想到是树形dp，主要是这里的根实在太多了，看了题解，原来换根$dp$完全可以解决这种题型，而且常用于解决这些问题。<br>该类题目的特点是：给定一个树形结构，需要以每个节点为根进行一系列统计。完全符合。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>经过$k$个点的最短路径很容易看出来就是从点$s$出发经过所有点后在一个节点上停下来，那么距离就是$dis = sum[s]-dept[s]$其中$sum[s]$表示$s$到经过$k$点后返回原点的距离，而$dept[s]$表示从$s$开始走，能到的$k$个点中最远的那个。<br>问题就分解成了两个子问题。</p><ol><li>从当前点到达k个点后返回自身距离。</li><li>从当前点出发能走到的最远的距离。</li></ol><p>对于这两个问题，我们先看问题1，首先单独考虑一个点,一个点时直接暴力$dfs$就好了。<br>扩展来看多个点。我们在一个点$dfs$时构建了一棵树，考虑父节点(上一棵树的根节点)与子节点的关系，对于父节点来说，他的答案是已知的，而更新到子节点我们也就只要考虑如何更新子节点，子节点维护了子节点下面的所有点的距离，根据父节点我们也就可以更新该节点往上走的所有值，同时判断是否加上一个边$(u \rightarrow v)$。<br>来看更新过程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(m-sz[v]==0)&#123;//v上面没有有需要经过的点</span><br><span class="line">dp[v]=dp[u]-ed[i].w;把边权去掉</span><br><span class="line">&#125;</span><br><span class="line">else if(sz[v]==0)&#123;//v下面有需要经过的点</span><br><span class="line">dp[v]=dp[u]+ed[i].w;增加边权</span><br><span class="line">&#125;</span><br><span class="line">else dp[v]=dp[u];//该点是必要点(必须经过)所以边权不变。</span><br></pre></td></tr></table></figure></p><p>子问题2：<br>当前点能到的最远距离。<br>也是首先来看单个点，我们可以知道，对于单个点来说，直接大力$dfs$就好了。<br>接下来，我们来看多个点，我们首先已经处理一个点，考虑以他为父节点，那么父节点最远距离已知，我们将一棵按照两个节点$u \rightarrow v$割成两颗子树，分别以$u$和$v$为父节点。那么当前节点v的能到的$dept=max(v树里面能走到的最远的距离,u树能走到的最远距离+u \rightarrow v)$<br>而$v$树里面最远的距离在第一次$dfs$就可以知道，明显可以发现一个道理，不管根节点在$v$的上面怎么变，他的父节点一直不变，且$v$下面的节点结构也不变！(<del>是你爹终归是爹</del>)。<br>$u$树的最远距离有两种可能</p><ol><li>经过点$v$，那就有点尴尬了，我们考虑一条不经过$v$的次长路径和$u$往上走的最长路径更新最远距离</li><li>不经过点$v$，那直接就是，$u$往上走的最远距离和它往不经过v的最长路径更新最远距离。</li></ol><p>可能会问为什么是不能经过$v$的最长路径，这是$u$树(以$u$为根节点，断掉$u \rightarrow v$)边的树。<br>来看转移方程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//注意，如果上面没有树，就不要去寂寞的更新了。</span><br><span class="line">if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123;</span><br><span class="line">    up[v]=max(up[u],deep1[u])+ed[i].w;</span><br><span class="line">&#125;else if(m-sz[v]!=0)&#123;</span><br><span class="line">    up[v]=max(up[u],deep0[u])+ed[i].w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来看全部代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 1e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">int pre,to;</span><br><span class="line">ll w;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot=0,vis[N],sz[N],n,m;</span><br><span class="line">ll deep0[N],dp[N],deep1[N],ans[N],dept[N],up[N];</span><br><span class="line">void add(int u,int v,int w)&#123;</span><br><span class="line">ed[++tot].pre=head[u];</span><br><span class="line">ed[tot].to=v;</span><br><span class="line">ed[tot].w=w;</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dfs0(int u,int fa)&#123;</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">int v=ed[i].to;</span><br><span class="line">if(fa==v) continue;</span><br><span class="line">dfs0(v,u);</span><br><span class="line">sz[u]+=sz[v];</span><br><span class="line">if(sz[v])&#123;</span><br><span class="line">dp[u]+=dp[v]+ed[i].w;</span><br><span class="line">if(deep0[v]+ed[i].w&gt;deep0[u])&#123;</span><br><span class="line">vis[u]=v;</span><br><span class="line">deep1[u]=deep0[u];</span><br><span class="line">deep0[u]=ed[i].w+deep0[v];//更新最长路</span><br><span class="line">&#125;else deep1[u]=max(deep1[u],deep0[v]+ed[i].w);//保证了最长路与次长路不在同一个子节点上面</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int u,int fa)&#123;</span><br><span class="line">//printf(&quot;%d %d %d %d\n&quot;,u,dp[u],deep0[u],up[u]);</span><br><span class="line">dept[u]=max(deep0[u],up[u]);</span><br><span class="line">ans[u]=(dp[u]*2-dept[u]);</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">int v=ed[i].to;</span><br><span class="line">if(fa==v) continue;</span><br><span class="line">if(m-sz[v]==0)&#123;</span><br><span class="line">dp[v]=dp[u]-ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">else if(sz[v]==0)&#123;</span><br><span class="line">dp[v]=dp[u]+ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">else dp[v]=dp[u];</span><br><span class="line">if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123;</span><br><span class="line">up[v]=max(up[u],deep1[u])+ed[i].w;</span><br><span class="line">&#125;else if(m-sz[v]!=0)&#123;</span><br><span class="line">up[v]=max(up[u],deep0[u])+ed[i].w;</span><br><span class="line">&#125;</span><br><span class="line">dfs1(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,t=0;</span><br><span class="line">int u,v,w;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">tot=0;</span><br><span class="line">rep(i,1,n-1)&#123;</span><br><span class="line">scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);</span><br><span class="line">add(u,v,w);</span><br><span class="line">add(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line">rep(i,1,m) scanf(&quot;%d&quot;,&amp;u),sz[u]=1;</span><br><span class="line">dfs0(1,1);</span><br><span class="line">dfs1(1,1);</span><br><span class="line">rep(i,1,n)&#123;</span><br><span class="line">printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="无向图定向"><a href="#无向图定向" class="headerlink" title="无向图定向"></a>无向图定向</h1><h2 id="迪尔沃斯定理"><a href="#迪尔沃斯定理" class="headerlink" title="迪尔沃斯定理"></a>迪尔沃斯定理</h2><p>定理指出：<strong>对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目</strong>。<br>具体应用有</p><ol><li>求一个序列的上升子序列的数量，我们可以求其最长下降子序列的长度就是其上升子序列的数量。<a href="https://www.luogu.com.cn/problem/P1020" target="_blank" rel="noopener">题目链接</a></li></ol><p>这一题就当是开了眼，蛮玄乎的。<br>我们暴力枚举每一个点的颜色，注意其一条边之间的两个点颜色不得相同，当颜色使用的最少的时候，就是其最小反链的数目+1，直接输出就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 17+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">int pre,to,w;</span><br><span class="line">&#125;ed[N*2];</span><br><span class="line">int head[N],tot,ans=30,n,m,siz=0,clo[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">ed[++tot].pre=head[u];</span><br><span class="line">ed[tot].to=v;</span><br><span class="line">head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">bool check(int u,int flag)&#123;</span><br><span class="line">for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">if(clo[ed[i].to]==flag) return 1;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int u,int res)&#123;</span><br><span class="line">if(res&gt;ans) return ;</span><br><span class="line">if(u&gt;n)&#123;</span><br><span class="line">ans=min(ans,res);</span><br><span class="line">return ;</span><br><span class="line">&#125;</span><br><span class="line">rep(j,1,res)&#123;</span><br><span class="line">if(check(u,j)) continue;</span><br><span class="line">clo[u]=j;</span><br><span class="line">dfs(u+1,res);</span><br><span class="line">&#125;</span><br><span class="line">clo[u]=res+1;</span><br><span class="line">dfs(u+1,res+1);</span><br><span class="line">clo[u]=0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int i,j,k,t=0;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;n,&amp;m);</span><br><span class="line">ans=m+1;</span><br><span class="line">siz=1,tot=0;</span><br><span class="line">rep(i,1,m)&#123;</span><br><span class="line">int u,v;</span><br><span class="line">scanf(&quot;%d %d&quot;,&amp;u,&amp;v);</span><br><span class="line">add(v,u);</span><br><span class="line">add(u,v);</span><br><span class="line">&#125;</span><br><span class="line">dfs(1,1);</span><br><span class="line">printf(&quot;%d\n&quot;,ans-1);</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.cnblogs.com/laoguantongxiegogo/p/12490457.html" target="_blank" rel="noopener">迪尔沃斯定理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://smilecoding.cn/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>2020美团杯补题日志</title>
    <link href="https://smilecoding.cn/2020/05/18/2020%E7%BE%8E%E5%9B%A2%E6%9D%AF%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97/"/>
    <id>https://smilecoding.cn/2020/05/18/2020%E7%BE%8E%E5%9B%A2%E6%9D%AF%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97/</id>
    <published>2020-05-18T13:14:29.000Z</published>
    <updated>2020-05-18T13:50:27.304Z</updated>
    
    <content type="html"><![CDATA[<p>说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！<del>cf疯狂掉分，感人肺腑:(</del><a id="more"></a></p><h1 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h1><p>真的是写题3分钟，debug5小时，人都傻了，秒出思路后居然细节处理出现问题，样例都没过，后面疯狂想到假算法，我真是个睿智。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为在整个字符串里面都不能出现$xxxll$这个子序列，那么我们思考最后的修改后的结果，显然可以知道在每一个位置上其前面不得超过$2$个$x$，多余的$x$我们全部转成$l$，这样操作结果是在该位置以前一定不会有非法串，后面不能超过$1$个$l$，将多余的$l$全部转成$x$。然后枚举每一个位置得到其最小值就是答案了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">char a[N];</span><br><span class="line">int pre[N],nxt[N];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m,i,j,k,t=0;</span><br><span class="line">scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">while(t--)&#123;</span><br><span class="line">scanf(&quot;%s&quot;,a+1);</span><br><span class="line">int len = strlen(a+1);</span><br><span class="line">rep(i,1,105) pre[i]=0,nxt[i]=0;</span><br><span class="line">rep(i,1,len) pre[i]=pre[i-1]+(a[i]==&apos;x&apos;);</span><br><span class="line">for(i=len;~i;i--) nxt[i]=nxt[i+1]+(a[i]==&apos;l&apos;);</span><br><span class="line">int ans = 1000;</span><br><span class="line">rep(i,1,len)&#123;</span><br><span class="line">ans=min(ans,max(pre[i-1]-2,0)+max(0,nxt[i]-1));</span><br><span class="line">//printf(&quot;%d %d\n&quot;,pre[i],nxt[i]);</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">//system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="M"><a href="#M" class="headerlink" title="M"></a>M</h1><p>一个交互题，主要是关于$sort$被卡的问题，很玄学！官方解释是sort在数据量很小时自动退化为插入排序，而qsort不会。</p><h2 id="qsort使用方法"><a href="#qsort使用方法" class="headerlink" title="qsort使用方法"></a>qsort使用方法</h2><ol><li>传入数组地址</li><li>传入排序长度</li><li>传入排序元素字节长度</li><li>最重要的一点！cmp函数，格式固定，返回值为int，大于零则表示大于，小于零则表示小于。<br>这里贴一个$qsort$的版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &quot;lcs.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">int cmp(const void *a,const void *b)&#123;//此处格式固定</span><br><span class="line">int num[2]=&#123;*(int *) a ,*(int *)b&#125;;</span><br><span class="line">int flag = get_lcs(2,num);</span><br><span class="line">if(flag&gt;1) flag=1;</span><br><span class="line">else flag=-1;</span><br><span class="line">return -flag;</span><br><span class="line">&#125;</span><br><span class="line">void find_permutation(int n, int res[])&#123;</span><br><span class="line">int i;</span><br><span class="line">rep(i,0,n-1)&#123;</span><br><span class="line">res[i]=i+1;</span><br><span class="line">&#125;</span><br><span class="line">qsort(res,n,sizeof(int),cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！&lt;del&gt;cf疯狂掉分，感人肺腑:(&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://smilecoding.cn/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>shell入门</title>
    <link href="https://smilecoding.cn/2020/05/12/shell%E5%85%A5%E9%97%A8/"/>
    <id>https://smilecoding.cn/2020/05/12/shell%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-12T02:26:45.000Z</published>
    <updated>2020-06-03T03:29:15.150Z</updated>
    
    <content type="html"><![CDATA[<p>最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础<a id="more"></a></p><h1 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p># 是注释号</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量分为永久变量和临时变量<br>临时变量是shell内部定义，用于该shell程序，随shell程序关闭而清理。<br>永久变量是环境变量，不随shell结束而消失。<br>变量定义和python一致，直接定义就好了。<br>$ 访问变量<br>set命令是列出所有变量</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串的单引号与双引号<br>单引号不会自动访问变量，而双引号会访问该变量的值。举个例子</p><blockquote><p>定义一个var=’aaa’<br>a=’var’这里a是var<br>a=”var”这里a是aaa </p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">\$*($@)</td><td style="text-align:center">这个程序的所有参数</td></tr><tr><td style="text-align:center">$#</td><td style="text-align:center">几个配置参数</td></tr><tr><td style="text-align:center">$$</td><td style="text-align:center">该程序的PID</td></tr><tr><td style="text-align:center">@!</td><td style="text-align:center">后台的pid值</td></tr></tbody></table></div><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>read 从键盘输入数据</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>echo 输出当前包含的变量</p><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>shell仅支持整形运算<br>expr 整形运算(仅支持整形运算)<br>+代表加法<br>-代表减法<br>/代表除法<br>*乘法<br>所有运算都要放到反单引号里面才能成功，且<strong>运算符两边必须含有空格，等号两边不得含有空格</strong></p><h2 id="test变量测试语句"><a href="#test变量测试语句" class="headerlink" title="test变量测试语句"></a>test变量测试语句</h2><h3 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test str1=str2</td><td style="text-align:center">是否相等</td></tr><tr><td style="text-align:center">test str1!=str2</td><td style="text-align:center">是否不相等</td></tr><tr><td style="text-align:center">test str1</td><td style="text-align:center">是否为空</td></tr><tr><td style="text-align:center">test -n str1</td><td style="text-align:center">判断是否不为空</td></tr><tr><td style="text-align:center">test -z str1</td><td style="text-align:center">是否为空</td></tr></tbody></table></div><h3 id="数字测试"><a href="#数字测试" class="headerlink" title="数字测试"></a>数字测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test int1 -eq int2</td><td style="text-align:center">是否相等 (equal)</td></tr><tr><td style="text-align:center">test int1 -ge int2 int1</td><td style="text-align:center">是否大于等于int2 (great)</td></tr><tr><td style="text-align:center">test int1 -gt int2 int1</td><td style="text-align:center">是否大于int2 (great than)</td></tr><tr><td style="text-align:center">test int1 -le int2 int1</td><td style="text-align:center">是否小于等于int2 (less)</td></tr><tr><td style="text-align:center">test int1 -lt int2 int1</td><td style="text-align:center">是否小于int2 (less than)</td></tr><tr><td style="text-align:center">test int1 -ne int2 int1</td><td style="text-align:center">不相等int2</td></tr></tbody></table></div><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">test -d -file</td><td style="text-align:center">是否为目录</td></tr><tr><td style="text-align:center">test -f file</td><td style="text-align:center">指定文件是否常规文件</td></tr><tr><td style="text-align:center">test -x file</td><td style="text-align:center">指定文件是否可执行</td></tr></tbody></table></div><p>test -r file |指定文件是否可读<br>test -w file |指定文件是否可写<br>test -a/e file |指定文件是否存在<br>test -s file |指定文件大小是否为0</p><ol><li>exit 返回，0为正常<br>流程控制语句<br>if … then … fi<br>其中 -a逻辑与，-o逻辑或<br>循环语句<br>while[逻辑语句]do…done</li></ol></blockquote><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>环境变量<br>书要是定义对系统操作的环境生效的系统默认环境变量如PATH等<br>环境配置文件</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">/etx/profile</td><td style="text-align:center">全局变量</td></tr><tr><td style="text-align:center">/etx/profile.d/*.sh</td><td style="text-align:center">全局变量</td></tr><tr><td style="text-align:center">~/.bash_profile</td><td style="text-align:center">仅对当前用户有效</td></tr><tr><td style="text-align:center">~/.bashrc</td><td style="text-align:center">仅对当前用户有效</td></tr><tr><td style="text-align:center">/etc/bashrc</td><td style="text-align:center">全局变量</td></tr></tbody></table></div><p><img src="/2020/05/12/shell%E5%85%A5%E9%97%A8/启动顺序.png" alt="运行顺序"><br>启动配置文件：source 配置文件或 .配置文件</p><h2 id="重启命令"><a href="#重启命令" class="headerlink" title="重启命令"></a>重启命令</h2><p>init 6</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础&lt;/p&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://smilecoding.cn/categories/shell/"/>
    
    
      <category term="Linux" scheme="https://smilecoding.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>AC自动机与矩阵快速幂</title>
    <link href="https://smilecoding.cn/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://smilecoding.cn/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2020-05-09T13:09:20.000Z</published>
    <updated>2020-05-10T12:54:46.687Z</updated>
    
    <content type="html"><![CDATA[<p>这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快<a id="more"></a></p><h1 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://vjudge.net/problem/POJ-2778" target="_blank" rel="noopener">题目链接</a></h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>首先给我们$x$个字符串，主要是由$A,C,T,G$四个字符组成的长度不超过10的字符串，$x \leq 10$，问由$A,C,G,T$组成的长度为$m$的字符串有多少个合法的(如果该字符串有一个子串和之前的字符串一样，则该字符非法)。$m \leq 2*10^9$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>$m$初看很假！这么大怎么弄，不要慌，我们先慢慢来，首先一共有$x$个模式串，我们先对模式串建一个$trie$树，保留他的$tail$节点。如果把一个构造后的字符串a后面加一个字符$v$看成是从$a$这个节点引4条有向路径出去。同时$trie$树里面的$tail$节点都是尾节点，这些节点如果出现在构造后的字符串里面，那么该串也就会出现非法子串。这题意也就抽象成了构造后的字符串里面不得含有非法节点，一共有多少种构造方式。联想到AC自动机fail的性质，它可以$O(n)$的判断字典树里面节点$cur$后面添加一条边v是否会成为非法节点。(通过fail失配节点去寻找以$root \rightarrow fail$是$root \rightarrow cur$的尾串，进而判断是否是非法节点)，也就完成了建边操作。<br>再看一个矩阵定理<br>邻接矩阵$a$ * $a$所代表的含义是从$i$节点经过两步以后能达到$j$的方案数。以此类推$a * a * a$就是三步的意思，证明的话看参考资料吧<br>从一颗字典树来看我们生成一个矩阵，表示从$u \rightarrow v$的方案数，从此观之，我们可以知道如果$mat[u][v]=0$就表示如果在由字典树到$u$的字串后加一个$v$变成了非法串。<br><img src="/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/图形示意.png" alt="图形示意"><br>黑色箭头表示失配指针，线条表示边，从上至下有向边。<br>模式串为$ACG$与$C$时$trie$树如上图我们就可以知道初始矩阵$mat$为：</p><ol><li>2 1 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0<br>0 0 0 0 0</li></ol><p>这里的$mat[0][0]=2$是因为从$0$节点走$G(T)$边会发现trie树里面没有该节点，那么走向$G(T)$后的节点还是一个虚点$0$节点，所以$mat[0][0]$就等于2了。<br>然后直接用上面得到的矩阵开始矩阵快速幂。直接得到$m$步后的矩阵，统计$mat[0]$的和，表示从$0$到任意节点的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 110</span><br><span class="line">#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)</span><br><span class="line">struct kkk&#123;</span><br><span class="line">int son[5],flag,fail;</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line">int cnt,nxt[maxn];</span><br><span class="line">const int mod = 100000;</span><br><span class="line">char aa[maxn];</span><br><span class="line">queue&lt;int &gt;q;</span><br><span class="line">int check(char x)&#123;</span><br><span class="line">    if(x==&apos;A&apos;) return 1;</span><br><span class="line">    if(x==&apos;C&apos;) return 2;</span><br><span class="line">    if(x==&apos;T&apos;) return 3;</span><br><span class="line">    return 4;</span><br><span class="line">&#125;</span><br><span class="line">void insert(char* s)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=check(s[i]);</span><br><span class="line">if(!trie[u].son[v])trie[u].son[v]=++cnt;</span><br><span class="line">u=trie[u].son[v];</span><br><span class="line">&#125;</span><br><span class="line">trie[u].flag=1;</span><br><span class="line">&#125;</span><br><span class="line">void getFail()&#123;</span><br><span class="line">for(int i=1;i&lt;5;i++)trie[0].son[i]=1;</span><br><span class="line">q.push(1);trie[1].fail=0;</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int u=q.front();q.pop();</span><br><span class="line">for(int i=1;i&lt;5;i++)&#123;</span><br><span class="line">int v=trie[u].son[i];</span><br><span class="line">int Fail=trie[u].fail;</span><br><span class="line">if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125;</span><br><span class="line">trie[v].fail=trie[Fail].son[i];</span><br><span class="line">            trie[v].flag|=trie[trie[Fail].son[i]].flag;//核心，标记是否为非法节点。</span><br><span class="line">q.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">struct mat&#123;</span><br><span class="line">    long long m[maxn][maxn];</span><br><span class="line">&#125;unit,pos;</span><br><span class="line">void init_unit()&#123;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        unit.m[i][i]=1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void builds()&#123;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        int u;</span><br><span class="line">        for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">            u = trie[i].son[j];</span><br><span class="line">            if(trie[u].flag||trie[i].flag)&#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            pos.m[i][u]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mat plus1(mat a,mat b)&#123;</span><br><span class="line">    mat ans;</span><br><span class="line">    long long cur;</span><br><span class="line">    rep(i,1,cnt)&#123;</span><br><span class="line">        rep(j,1,cnt)&#123;</span><br><span class="line">            cur = 0;</span><br><span class="line">            rep(k,1,cnt)&#123;</span><br><span class="line">                cur += (1ll*a.m[i][k]*b.m[k][j])%mod;</span><br><span class="line">                cur%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.m[i][j]=cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line">void sol(int n)&#123;</span><br><span class="line">    int ans = 0;</span><br><span class="line">    init_unit();</span><br><span class="line">    mat cur = unit;</span><br><span class="line">    builds();</span><br><span class="line">    while(n)&#123;</span><br><span class="line">        if(n&amp;1) cur = plus1(cur,pos);</span><br><span class="line">        pos = plus1(pos,pos);</span><br><span class="line">        n&gt;&gt;=1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        ans = (ans+cur.m[1][i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,ans);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int t,x,n;</span><br><span class="line">    memset(trie,0,sizeof trie);</span><br><span class="line">    cnt=1;            //代码实现细节，编号从1开始</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;x);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s&quot;,aa);</span><br><span class="line">        insert(aa);</span><br><span class="line">    &#125;</span><br><span class="line">    getFail();</span><br><span class="line">    sol(x);</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="瞎说"><a href="#瞎说" class="headerlink" title="瞎说"></a>瞎说</h2><p>这题简直就是开拓视野，写完了之后理清思路写博客还是有点懵，视野开拓的有点猛，我被吓到了。。。同时注意矩阵快速幂需要注意爆栈问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.matrix67.com/blog/archives/276" target="_blank" rel="noopener">矩阵乘法</a><br><a href="https://blog.csdn.net/morgan_xww/article/details/7834801" target="_blank" rel="noopener">正版题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快&lt;/p&gt;
    
    </summary>
    
    
      <category term="字符串" scheme="https://smilecoding.cn/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>CCPC Wannafly Winter Camp Day2</title>
    <link href="https://smilecoding.cn/2020/05/02/Day2/"/>
    <id>https://smilecoding.cn/2020/05/02/Day2/</id>
    <published>2020-05-02T11:35:21.000Z</published>
    <updated>2020-05-07T15:03:59.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="持续更新中，，，"><a href="#持续更新中，，，" class="headerlink" title="持续更新中，，，"></a>持续更新中，，，</h1><p>2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。<a id="more"></a><br>今天队友过来A，我过了C说句实在的A我还是有点懵，但是C我是知道了。先来一个C的题解。</p><h2 id="C博弈"><a href="#C博弈" class="headerlink" title="C博弈"></a>C博弈</h2><p>关于这题呢，求有多少种必胜方案。题目明显是一个$nim$博弈，同时先空的输，因而我们可以知道，<strong>先手必胜也就是先手拿完以后，进入平衡态，剩余数组异或值为0</strong>，那么首先朴素算法。</p><h3 id="朴素做法"><a href="#朴素做法" class="headerlink" title="朴素做法"></a>朴素做法</h3><p>暴力枚举：$CurNor \oplus a_i &lt; a_i$的数量，输出该数量就是答案了。($CurNor$当前的异或值)<br>枚举$i$明显超时。</p><h3 id="bouton定理"><a href="#bouton定理" class="headerlink" title="bouton定理"></a>bouton定理</h3><p>没错，这里又是一个定理。异或和的最高的为1的二进制位，所有这一位是1的y显然都是必胜态，这一位是0的不是必胜态。<br>为啥？<br>如果是必胜态，那么一定存在</p><script type="math/tex; mode=display">CurNor \oplus a_i \leq a_i</script><p>因为$a_i$里面的某一位变成了$0$以后，不管后面数字怎么变都只会变小，所以上式成立。<br>同时如果不是必胜态，那么一定存在<script type="math/tex">CurNor \oplus a_i > a_i</script><br>因为$a_i$里面有一位变成了$1$，不管后面怎么变，都会变大。所以也成立。<br>证毕。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">ll a[N];</span><br><span class="line">int cnt[N],ans[N];</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        int pos=0;</span><br><span class="line">        rep(j,0,60)&#123;</span><br><span class="line">            if(a[i]&amp;(1ll&lt;&lt;j)) cnt[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum^=a[i];</span><br><span class="line">        if(sum==0)&#123;</span><br><span class="line">            ans[i]=0;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = 0;</span><br><span class="line">        rep(j,0,60)&#123;</span><br><span class="line">            if(sum&amp;(1ll&lt;&lt;j)) pos=j;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[i]=cnt[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="E树上启发式合并"><a href="#E树上启发式合并" class="headerlink" title="E树上启发式合并"></a>E树上启发式合并</h2><p>普及概念：</p><ol><li>重点： 表示其子节点中子树最大的子结点。</li><li>重边：一个节点的重边是自身节点与重点的连边。</li></ol><p>赛时队友提问：请问有啥好的数据结构能做到在插入是$log$情况下还能二分的吗？本憨批回答，无。我怕不是真憨批。$set$呀！！！错亿，这锅我背了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e5+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%lld\n&quot;,(a))</span><br><span class="line">set&lt;int&gt; q[N];</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id;</span><br><span class="line">&#125;ed[N];</span><br><span class="line">int head[N],tot=0,sz[N],son[N];</span><br><span class="line">ll ans[N];</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].pre=head[u];</span><br><span class="line">    ed[tot].id=v;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">void dfs1(int u)&#123;</span><br><span class="line">    int x = 0,sum=1;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v =ed[i].id;</span><br><span class="line">        dfs1(v);</span><br><span class="line">        sum+=sz[v];</span><br><span class="line">        if(sz[v]&gt;sz[x]) x=v;</span><br><span class="line">    &#125;</span><br><span class="line">    sz[u]=sum;</span><br><span class="line">    son[u]=x;</span><br><span class="line">&#125;</span><br><span class="line">void query(int u,int x)&#123;</span><br><span class="line">    set&lt;int&gt;:: iterator it = q[u].lower_bound(x);</span><br><span class="line">    if(q[u].empty())&#123;</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(it==q[u].begin())&#123;</span><br><span class="line">        ll r = *it;</span><br><span class="line">        ans[u]+=1ll*(r-x)*(r-x);</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        //printf(&quot;%d %lld l\n&quot;,x,r);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    if(it==q[u].end())&#123;</span><br><span class="line">        ll l = *--it;</span><br><span class="line">        ans[u]+=1ll*(x-l)*(x-l);</span><br><span class="line">        q[u].insert(x);</span><br><span class="line">        //printf(&quot;%d r\n&quot;,x);</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    ll r = *it,l=*(--it);</span><br><span class="line">    ans[u]-=(r-l)*(r-l);</span><br><span class="line">    ans[u]+=1ll*(r-x)*(r-x);</span><br><span class="line">    ans[u]+=1ll*(x-l)*(x-l);</span><br><span class="line">    q[u].insert(x);</span><br><span class="line">&#125;</span><br><span class="line">void dfs3(int u,int pos)&#123;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        dfs3(v,pos);</span><br><span class="line">    &#125;</span><br><span class="line">    query(pos,u);</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u)&#123;</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        dfs2(v);</span><br><span class="line">    &#125;</span><br><span class="line">    q[u].swap(q[son[u]]);</span><br><span class="line">    ans[u]=ans[son[u]];</span><br><span class="line">    for(int i=head[u];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        if(v==son[u]) continue;</span><br><span class="line">        q[v].clear();</span><br><span class="line">        dfs3(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    query(u,u);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,m,i,j,k,t=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    rep(i,2,n)&#123;</span><br><span class="line">        int u;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;u);</span><br><span class="line">        add(u,i);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(1);</span><br><span class="line">    dfs2(1);</span><br><span class="line">    rep(i,1,n)&#123;</span><br><span class="line">        pt(ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写完这个代码，嗯，说句实在的，感觉算法不是很难理解，唯独在于时间复杂度，他是$n*log_n$的，比较难以理解。<br>同时加深set的理解：</p><ol><li>用$q[u]=q[v]$的话时间复杂度是$O(N)$而使用q[u].swap(q[v])就会是$O(1)$，把我t飞了。</li><li>关于$set$的$lower_bound()$返回的是第一个大于等于他的位置，如果查询值是最大的，返回一个迭代器，指向最后一个元素的后一个节点，要把它修回来。。。</li></ol><h2 id="H-欧拉回路"><a href="#H-欧拉回路" class="headerlink" title="H 欧拉回路"></a>H 欧拉回路</h2><p>到底是这题提议玄学还是我憨批，我怎么看了那么久题意，刚刚才懂。。。<br>题意懂了以后就很明显地知道是个构造题，构造一个欧拉路。(比赛的时候题意看偏了，以为是随便整个数字就好了，还一直在想为啥样例为啥最大只能到4，是真够憨的我)。</p><blockquote><p>对于一个欧拉路径存在定理: <strong>一个图里面奇度为$0$时存在欧拉回路，为$2$时存在欧拉路径</strong></p></blockquote><p>所以我们先找到合适的点就好了，当点数时奇数时，每一个点的度数都是偶数，存在欧拉回路，当点数时偶数$x$时，每个点度数都是奇数，最少需要加入$x/2-1$条边变成两个奇度顶点。单调性容易证明，可以直接二分，如果数学可以的话我发现其实可以直接算出来。不过赛时二分也不错，写起来也快。<br>算出最大的顶点后直接跑欧拉路就好了，唯一坑点，注意格式！！！格式错误是$30%$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include&lt;math.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N = 2e6+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">#define rep(i,a,b) for(i=(a);i&lt;=b;i++)</span><br><span class="line">#define pt(a) printf(&quot;%d\n&quot;,(a))</span><br><span class="line">struct ED&#123;</span><br><span class="line">    int pre,id,w;</span><br><span class="line">&#125;ed[2*N];</span><br><span class="line">ll check(int x)&#123;</span><br><span class="line">    if(x%2) return 1ll*x*(x-1)/2;</span><br><span class="line">    else return 1ll*x*(x-1)/2+(x/2)-1;</span><br><span class="line">&#125;</span><br><span class="line">int head[N],tot=0;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">    ed[++tot].id=v;</span><br><span class="line">    ed[tot].pre=head[u];</span><br><span class="line">    ed[tot].w=1;</span><br><span class="line">    head[u]=tot;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;int&gt; ans;</span><br><span class="line">void sol(int x)&#123;</span><br><span class="line">    for(int &amp;i=head[x];i;i=ed[i].pre)&#123;</span><br><span class="line">        int v = ed[i].id;</span><br><span class="line">        if(ed[i].w==0) continue;</span><br><span class="line">        ed[i].w=ed[i^1].w=0;</span><br><span class="line">        sol(v);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,i,j,k,t=0;</span><br><span class="line">    ll n;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    ll l=1,r=1.5e9;</span><br><span class="line">    while(l&lt;r)&#123;</span><br><span class="line">        ll mid = ((l+r)+1)/2;</span><br><span class="line">        if(check(mid)&lt;n) l=mid;</span><br><span class="line">        else r = mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    int poi = l;</span><br><span class="line">    if(n&gt;2e6) &#123;</span><br><span class="line">        printf(&quot;%d\n&quot;,poi);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    tot=1;</span><br><span class="line">    for(i=1;i&lt;=poi;i++)&#123;</span><br><span class="line">        rep(j,i+1,poi)&#123;</span><br><span class="line">            add(i,j),add(j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(poi%2==0)&#123;</span><br><span class="line">        for(int i=3;i&lt;=poi;i+=2) add(i,i+1),add(i+1,i);</span><br><span class="line">    &#125;</span><br><span class="line">    ans.clear();</span><br><span class="line">    sol(1);</span><br><span class="line">    for(i=ans.size();i&lt;=n;i++)&#123;</span><br><span class="line">        ans.push_back(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;,poi);</span><br><span class="line">    rep(i,0,n-1)&#123;</span><br><span class="line">        if(i!=n-1) printf(&quot;%d &quot;,ans[i]);</span><br><span class="line">        else printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="K-AC自动机优化后dp。"><a href="#K-AC自动机优化后dp。" class="headerlink" title="K AC自动机优化后dp。"></a>K AC自动机优化后dp。</h2><p>赛时看着一头雾水，补完以后来瞎逼逼一下，对于这一题，看了一天AC自动机和优化(没办法，tle在93.9了)，真快乐，后来看到一个博主说可以优化fail数组！<br>一共两个优化，可能因为拿到的板子就是$trie$优化后的产物，所以只发现一个$last$优化，说起来网上关于这个优化各说纷纭，我就叫他$last$了，其实应该来说就是剪枝，在得到$fail$数组去查询时，直接跳$fail$数组可能会经过一些没必要的点，那么这些点我们就可以通过$last$优化掉，直接减少跳的次数！(演示代码使用的$trans$数组)<br>至于该题的dp较明显就是$dp[i]=min(dp[i-len(x)]+val[x],dp[i])$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">const int  maxn=5e5+5;</span><br><span class="line">using namespace std;</span><br><span class="line">struct kkk&#123;</span><br><span class="line">int son[26],flag,fail;</span><br><span class="line">&#125;trie[maxn];</span><br><span class="line">int n,cnt,num[maxn],le[maxn],trans[maxn];</span><br><span class="line">long long dp[maxn],inf;</span><br><span class="line">char a[maxn];</span><br><span class="line">queue&lt;int &gt;q;</span><br><span class="line">void insert(char* s,int val)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=s[i]-&apos;a&apos;;</span><br><span class="line">if(!trie[u].son[v])trie[u].son[v]=++cnt;</span><br><span class="line">u=trie[u].son[v];</span><br><span class="line">&#125;</span><br><span class="line">if(trie[u].flag == 0) trie[u].flag=val;</span><br><span class="line">    else trie[u].flag = min(val,trie[u].flag);</span><br><span class="line">    le[u] = len;</span><br><span class="line">&#125;</span><br><span class="line">void getFail()&#123;</span><br><span class="line">for(int i=0;i&lt;26;i++)trie[0].son[i]=1;//初始化0的所有儿子都是1</span><br><span class="line">q.push(1);trie[1].fail=0;//将根压入队列</span><br><span class="line">while(!q.empty())&#123;</span><br><span class="line">int u=q.front();q.pop();</span><br><span class="line">for(int i=0;i&lt;26;i++)&#123;//遍历所有儿子</span><br><span class="line">int v=trie[u].son[i];//处理u的i儿子的fail，这样就可以不用记父亲了</span><br><span class="line">int Fail=trie[u].fail;//就是fafail，trie[Fail].son[i]就是和v值相同的点</span><br><span class="line">if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125;//不存在该节点，就把父节点的失配节点的该位子节点补充到该节点上来。</span><br><span class="line">trie[v].fail=trie[Fail].son[i];//存在该节点直接把该节点的失配节点设置为父节点的失配节点的该位子节点的值。</span><br><span class="line">q.push(v);//存在实节点才压入队列</span><br><span class="line">            int x = trie[Fail].son[i];</span><br><span class="line">            if(trie[x].flag!=0)&#123;</span><br><span class="line">                trans[v] = x;//利用trans剪枝，假设当前节点是尾节点则此点有效，可以跳到这个点来</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                trans[v]=trans[x];//无效，跳到该点的上一个点去。</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void query(char* s)&#123;</span><br><span class="line">int u=1,len=strlen(s);</span><br><span class="line">for(int i=0;i&lt;len;i++)&#123;</span><br><span class="line">int v=s[i]-&apos;a&apos;;</span><br><span class="line">int k=trie[u].son[v];//跳Fail</span><br><span class="line">while(k&gt;1)&#123;</span><br><span class="line">            dp[i+1]=min(dp[i+1],1ll*dp[i-le[k]+1]+1ll*trie[k].flag);</span><br><span class="line">k=trans[k];//继续跳trans</span><br><span class="line">&#125;</span><br><span class="line">u=trie[u].son[v];//到下一个儿子</span><br><span class="line">&#125;</span><br><span class="line">    if(dp[len]&gt;=inf)&#123;</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;%lld\n&quot;,dp[len]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    memset(trie,0,sizeof trie);</span><br><span class="line">    memset(dp,0x3f,sizeof dp);</span><br><span class="line">    memset(le,0,sizeof le);</span><br><span class="line">    inf = dp[0];</span><br><span class="line">    dp[0]=0;</span><br><span class="line">    cnt=1;</span><br><span class="line">    int x;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%s %d&quot;,a,&amp;x);</span><br><span class="line">        insert(a,x);</span><br><span class="line">    &#125;</span><br><span class="line">    getFail();</span><br><span class="line">    scanf(&quot;%s&quot;,a);</span><br><span class="line">    query(a);</span><br><span class="line">    //system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;持续更新中，，，&quot;&gt;&lt;a href=&quot;#持续更新中，，，&quot; class=&quot;headerlink&quot; title=&quot;持续更新中，，，&quot;&gt;&lt;/a&gt;持续更新中，，，&lt;/h1&gt;&lt;p&gt;2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛日志" scheme="https://smilecoding.cn/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="ACM" scheme="https://smilecoding.cn/tags/ACM/"/>
    
  </entry>
  
</feed>
