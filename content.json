{"meta":{"title":"Hexo","subtitle":"","description":"飞蛾扑火也许仅仅是因为那一丝的温暖吧","author":"无向秃","url":"http://yoursite.com","root":"/"},"pages":[{"title":"自由空间","date":"2019-11-26T10:37:58.000Z","updated":"2019-11-27T09:40:42.857Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-26T11:57:02.000Z","updated":"2019-11-26T11:57:53.216Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-01-14T08:05:26.985Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"http://yoursite.com/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"","text":"欧拉筛欧拉筛证明：首先介绍一下算术基本原理：x=p1^e1 * p2^e2 * p3^e3…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道x=x1 * p(min)，(p为组成x的最小质数)。所以每一个数一定可以变成一个最小质数乘上一个比这个数小的正整数；那么x将会在x1处被判断，同时也将判断比x * j(j为比x最小质数小的所有质数)那么我们可以通过枚举x值来判断每一个数字是否为质数。 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;//枚举x if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123; vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;第一个比x小的质数 &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2019-11-27T10:10:37.106Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"http://yoursite.com/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"","text":"题目链接按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2019-11-27T10:13:04.368Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"http://yoursite.com/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://yoursite.com/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]}]}