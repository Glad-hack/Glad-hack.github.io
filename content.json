{"meta":{"title":"Hexo","subtitle":"","description":"飞蛾扑火也许仅仅是因为那一丝的温暖吧","author":"无向秃","url":"https://dream-ak.top","root":"/"},"pages":[{"title":"自由空间","date":"2019-11-26T10:37:58.000Z","updated":"2019-11-27T09:40:42.857Z","comments":true,"path":"categories/index.html","permalink":"https://dream-ak.top/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-11-26T11:57:02.000Z","updated":"2019-11-26T11:57:53.216Z","comments":true,"path":"tags/index.html","permalink":"https://dream-ak.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"迪杰斯特拉堆优化","slug":"迪杰斯特拉堆优化","date":"2020-02-01T06:53:49.000Z","updated":"2020-02-01T13:25:37.985Z","comments":true,"path":"2020/02/01/迪杰斯特拉堆优化/","link":"","permalink":"https://dream-ak.top/2020/02/01/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%A0%86%E4%BC%98%E5%8C%96/","excerpt":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃","text":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃 原理来说原理的话我建议可以讲一下迪杰斯特拉的算法思想，利用贪心，每一次走距离当前点$u$最近的点$v$，那么我们由原点到$v$一定会是最近的，因为$u$一开始就是最近的，那么dis[u]+min(u\\rightarrow v)\\leq dis[u]+!min(u\\rightarrow v)根据这个我们可以知道我们只需 维护一个最小堆来得到当前最小的$dis[u]$得到$u$的位置，然后找到$u$能到的点$v$的最短路径，得到$dis[v]$然后加入堆 循环1操作直到堆为空就好了。代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=0,dis[N],vis[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij_heap(int x)&#123; int i; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(i=head[u];i;i=ed[i].pre)&#123; if(dis[u]+ed[i].w&lt;=dis[ed[i].id])&#123; dis[ed[i].id]=dis[u]+w; q.push(-dis[ed[i].id],ed[i].id);//这里用负数使最大堆变最小堆 &#125; &#125; &#125;&#125;int main()&#123; dij_heap(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"差分约束","slug":"差分约束","date":"2020-01-30T13:33:49.000Z","updated":"2020-02-02T04:48:46.745Z","comments":true,"path":"2020/01/30/差分约束/","link":"","permalink":"https://dream-ak.top/2020/01/30/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh","text":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh 一般形式差分约束题一般是给出大量的一些不等式 a_i-b_i\\leq x \\rightarrow a_i\\leq x + b_i由上面这个不等式我们应该可以联想到最短路的不等式 dis[u]\\leq dis[v] + x(u \\rightarrow v)因此，我们可以将差分约束化成一个最短路来求，我们的$dis[u]$保存由远点到$u$的可以选择的最大范围!==为什么是最大范围？==我们每一次选择的是$min(u \\rightarrow v)$，那么一开始我们就会选择一个从原点$s$最小的范围，且没有其他路径会是她变得更小(三角形)，那么这个由原点出发的范围将会是$s \\rightarrow u$的范围，选择最大的话，就是这个范围啦。 求最长路当求最大的范围时是最短路，已经说过了，但是如果求最小范围呢？看一下基本形式 a_i-b_i\\geq x \\rightarrow a_i \\geq x + b_i这个又是什么意思呢？试着把$a_i，b_i$也当作两个点，那么这就是 dis[a_i]\\geq dis[b_i] + x也就是最长路的样子啦 最长路实现最长路的办法，我们试着用最短路的办法去试 floyd $O(n^3)$很明显暴力枚举下面肯定是可以的，但是复杂度实在太高，放弃 dijstra基于贪心的算法，我们最长路的贪心是做不到的，从三角形来看是很明显的，遂继续放弃 bellman_ford差不多就是暴力对所有的边进行n-1次遍历了==一条最长路最多经过$n-1$次松弛==，在这里最长路也是这样啊，时间复杂度的话，我们可以考虑已经死了的 spfa呀，死了不要紧我们可以优化spfa玄学优化 双端队列优化，一个非常常见的优化，当边权小于队首时从队首加入，否则队尾！ 双端慢了？没事我们可以数组模拟，强行加速！ 啊，还是tle？淡定加容错优化，我们首先把所有边权加起来开个根号后加上一个容错值$x$然后当当前边权小于队首边权加上容错时从队首加入，否则队尾，继续强行加速！ 听说还是tle？emmm，等死吧","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"vscode背景配置","slug":"vscode背景配置","date":"2020-01-30T13:00:23.000Z","updated":"2020-01-30T13:22:37.168Z","comments":true,"path":"2020/01/30/vscode背景配置/","link":"","permalink":"https://dream-ak.top/2020/01/30/vscode%E8%83%8C%E6%99%AF%E9%85%8D%E7%BD%AE/","excerpt":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！","text":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！ 安装background扩展商店安装就好了这里会弹出code损坏，莫急，往下看 下载 Fix vscode checksum扩展商店下载好以后按下ctrl+shift+p输入 Fix checksum 选择apply就行了 配置插件管理员运行vscode，打开以后按如下图操作打开setting.json 编辑setting.json1234567891011121314151617181920&#123; &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;file:///E:background/vscode.png&quot;//你的图片的绝对路径 ], &quot;background.style&quot;: &#123; &quot;content&quot;: &quot;&apos;&apos;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;background-position&quot;: &quot;50% 50%&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 &#125;, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;&#125; 接下来可能会要求你重启就完成了","categories":[{"name":"vscode","slug":"vscode","permalink":"https://dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"vscode配置c","slug":"vscode配置c","date":"2020-01-28T16:45:47.000Z","updated":"2020-01-30T13:31:33.843Z","comments":true,"path":"2020/01/29/vscode配置c/","link":"","permalink":"https://dream-ak.top/2020/01/29/vscode%E9%85%8D%E7%BD%AEc/","excerpt":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。","text":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。 1.下载DEV也许有人会问不是vscode嘛？为啥下载这个，因为vscode是编辑器我们需要下载一个编译器，我们就把DEV里面的mingw单独拿出来添加环境变量，提供编译环境。下载网址：1https://dl.pconline.com.cn/download/908942-1.html进入后点击普通下载，安装好。 2.配置环境变量1.右击电脑属性后2.进入高级设置点击环境变量3.在系统变量Path里面增加mingw64/bin的路径声明一下mingw64/bin就在之前下的DEV文件里面，桌面右击快捷方式打开文件所在地址就可以找到该文件了从左至右逐一执行后点击确定。打开cmd输入gcc如果返回的是gcc: fatal error: no input filescompilation terminated.那么环境就配好了，否则重启一下电脑再试一下，再不行的话就是环境配置失败，再来吧 3.下载vscode下载地址1https://code.visualstudio.com/Download下载过程中一路确定就好了。声明：安装路径不得含有中文！不然之后的操作会有玄学错误，gdb退出代码为-3 汉化chinese 汉化工具打开vscode工具，使用快捷键组合【command+Shift+p】，在搜索框中输入“configure display language”，点击确定后；修改locale.json文件下的属性“locale”为“zh-CN”; 重启vscode工具 安装插件c/c++ c配置必须的vscode-icons美化图标工具chinese 汉化工具Bracket Pair Colorizer 一起安装算了beautify 美化工具 4.文件配置1.我们首先写一个test.cpp文件代码里面必须含有一个输入getchar或者scanf都行,不然后面看不到输出效果，直接说返回值为1 launch文件2.从左到右操作，创建launch.json文件3.使用gdb创建之后点击gcc.exe生成一个文件，在该文件里面添加下面这段代码1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;gcc.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //这里是控制台时候打开运行一般是true！ &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gdb.exe&quot;, //你的环境gdb.exe文件地址，我这里是在DEV-cpp里面，如果你安装方式和我差不多的话，那你的也在dev里面。 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;gcc.exe build active file&quot; &#125; ]&#125;两个要注意的地方1.miDebuggerPath这是你的gdb.exe文件地址，注意要修改正确！（好像还有一个gdb32.exe你看那一个成功用那个吧）2.externalConsole这里是true！ tasks.json文件这个文件我们手动添加，在.vscode文件里面创建tasks.json注意别打错了添加如下代码12345678910111213141516171819&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc.exe build active file&quot;, &quot;command&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gcc.exe&quot;,//你的文件地址 &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot;//你的文件地址 &#125; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;上面代码两个地方需要修改，请仔细看！此时再回到test.cpp里面按F5运行一下，应该能输出了。 到此环境安装结束！撒花","categories":[{"name":"vscode","slug":"vscode","permalink":"https://dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2020-01-28T03:19:55.000Z","updated":"2020-01-29T13:32:37.117Z","comments":true,"path":"2020/01/28/欧拉函数/","link":"","permalink":"https://dream-ak.top/2020/01/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数","text":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数 欧拉函数的性质 φ(x y) = φ(x) φ(y) 当且(x,y)==1 φ(x) = x - 1 当且仅当x为质数时 φ(n) = (p-1) * p^(k-1) φ(n)=n∗∏(1−1/pi) pi是n的质因子 a^(φ(m))==1%m 当且仅当(a,m)==1 s = n (φ(n)/2) *s为小于n且与n互质的数之和 φ(n p)=φ(n) p 当p为质数且n%p==0 φ(n p)=φ(n) (p-1) 当p为质数且n%p!=0 计算欧拉值的打表代码,时间复杂度O(n)123456789101112phi[1]=1; for(int i=2;i&lt;n;i++)&#123; if(vis[i]==0) pri[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;1ll*i*pri[j]&lt;n;j++)&#123; vis[i*pri[j]]=1;//标记此点经过非质数 if(i%pri[j]==0) &#123; phi[i*pri[j]]=phi[i]*pri[j];//性质7 break; &#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1);//性质8 &#125; &#125; 用性质4计算单个欧拉值1234567891011121314int ph(int n)&#123; int res=n,i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; res=res-res/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) res=res-res/n; return res;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[]},{"title":"割点","slug":"割点","date":"2020-01-20T14:21:29.000Z","updated":"2020-01-29T13:32:39.699Z","comments":true,"path":"2020/01/20/割点/","link":"","permalink":"https://dream-ak.top/2020/01/20/%E5%89%B2%E7%82%B9/","excerpt":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。","text":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。易得割点是2号点。 具体操作：121.用dfs给每一个点打上一个时间戳，把每一个点的时间戳保存至num【】里面；2.通过dfs来统计每一个点能到达的最小的时间戳。&lt;br&gt; 割点的判定方式： 如果存在一个点他的子节点能到达的最小时间戳大于等于父节点的时间戳那么这个点是一个割点。(也就是不能回到祖先，那么当前点就是割点咯) 假设一个点存在两个子节点，那么该点就是割点。我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。更新 low 的伪代码如下：1234如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);否则low[u] = min(low[u], num[v]);//这里是num[v]而不是low[v]的原因是如下图//按照节点编号从小到大遍历，4节点先到1，如果是low[v]的话，节点6的low值等于1，很明显是不可以的，所以是num 例题板子题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;const int N=2e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=1,cnt=0;int vis[N],num[N],low[N],inde,res,flag[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void tarjan(int u,int fa)&#123; vis[u]=1; low[u]=num[u]=++inde; int ch=0,i; for(i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(!vis[v])&#123; ch++; tarjan(v,u); low[u]=min(low[u],low[v]); if(fa!=u&amp;&amp;low[v]&gt;=num[u]&amp;&amp;!flag[u]) flag[u]=1,res++; &#125; else if(v!=fa)&#123; low[u]=min(low[u],num[v]);//这里非常关键，如果写成low[u]=min(low[u],low[v])在题目里面会wa &#125; &#125; if(ch&gt;= 2&amp;&amp;fa==u&amp;&amp;!flag[u])&#123; flag[u]=1; res++; &#125;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) head[i]=0,vis[i]=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; for(i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; inde=0; tarjan(i,i); &#125; &#125; printf(&quot;%d\\n&quot;,res); for(i=1;i&lt;=n;i++)&#123; if(flag[i]) printf(&quot;%d &quot;,i); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2020-01-14T11:59:52.000Z","updated":"2020-01-29T13:32:38.328Z","comments":true,"path":"2020/01/14/扩展欧几里得/","link":"","permalink":"https://dream-ak.top/2020/01/14/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"扩展欧几里得应用：计算逆元，解方程","text":"扩展欧几里得应用：计算逆元，解方程 证明方式：首先贝祖原理我大概就不解释了，直接照搬结论： ax+by=(a,b);贝祖原理 有ax+by=(b,a%b); 假设解为x1,y1则有a x1+b y1=(b,a%b) 由3式从右往左代替可得b x1+(a%b) y1 = (b,a%b);b x1 + (a-(a/b) b) y1 = (b,a%b);a y1 +b (x1 - (a/b) y1) = a x + b y由上可知x = y1,y = x1 - (a/b) * y1。 对于上式，我们可以比较一下欧几里得求最大公约数的算法： (a,b)=(b,a%b)，一直到b等于0时结束递归，而当b等于0时的x=1,y=0(); 然后又可以通过上面代数式4回退时计算出x与y的值！ 代码123456789101112ll x,y;ll ex_gcd(ll a,ll b)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll ans=ex_gcd(b,a%b); ll t=x; x=y; y=t-a/b*y; return ans;&#125; 应用逆元当求一个数字x对于p的逆元时，我们将其写成代数式将是如下形式： a*x=1%p; 对其进行化简可得a x+y p=1，已知x,p求a就好了化简成这样以后再看，简直就是扩展欧几里得板子！","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-01-29T13:31:44.953Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"https://dream-ak.top/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"欧拉筛欧拉函数打表简单版！","text":"欧拉筛欧拉函数打表简单版！ 欧拉筛证明：首先介绍一下算术基本原理：x=p1^e1 p2^e2 p3^e3…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道x=x1 p(min)，(p为组成x的最小质数)。所以每一个数一定可以变成一个最小质数乘上一个比这个数小的正整数；那么x将会在x1处被判断，同时也将判断比x j(j为比x最小质数小的所有质数)那么我们可以通过枚举x值来判断每一个数字是否为质数。 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;//枚举x if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123; vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;第一个比x小的质数 &#125; &#125;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.061Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"https://dream-ak.top/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://dream-ak.top/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.983Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"https://dream-ak.top/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；","text":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}