{"meta":{"title":"添砖Java","subtitle":"屡败屡战，终有一胜！","description":"心有不甘，却无以为继","author":"无向秃","url":"https://www.dream-ak.top","root":"/"},"pages":[{"title":"404","date":"2020-04-21T13:06:11.000Z","updated":"2020-04-21T13:17:54.024Z","comments":true,"path":"404/index.html","permalink":"https://www.dream-ak.top/404/index.html","excerpt":"","text":"你没有看错，这里啥都没有，我也不知道我为什么要开放，可能是抽风了吧。"},{"title":"Glak","date":"2020-04-21T13:05:59.000Z","updated":"2020-05-03T15:38:47.687Z","comments":true,"path":"about/index.html","permalink":"https://www.dream-ak.top/about/index.html","excerpt":"","text":"这里介绍一些我个人的生活日记，平常不怎么喜欢说话，我就在这里吐吐槽吧。关于这个站点，我可能会写出一些bug与错误，如果有人看到或者看不懂的话，可以在下面回复我，或者直接发邮件给我。有过时的信息可以直接反馈，如果某天不会更新了，我会在这里直接说出来的。在这里我一般会写一些我学过的算法(不是全部)，有需要可以私聊问我，我有问必答的。个人重心在于Java，python和ACM，目前还是个蒟蒻，希望大佬们路过时能够指点一二。"},{"title":"Glak","date":"2019-11-26T10:37:58.000Z","updated":"2020-04-22T01:02:16.789Z","comments":true,"path":"categories/index.html","permalink":"https://www.dream-ak.top/categories/index.html","excerpt":"","text":""},{"title":"折腾&自闭","date":"2019-11-26T11:57:02.000Z","updated":"2020-02-02T12:29:03.898Z","comments":true,"path":"tags/index.html","permalink":"https://www.dream-ak.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ubuntu18.04安装docker安装酷Q","slug":"Ubuntu18安装酷Q","date":"2020-06-06T02:20:38.000Z","updated":"2020-06-06T14:34:21.476Z","comments":true,"path":"2020/06/06/Ubuntu18安装酷Q/","link":"","permalink":"https://www.dream-ak.top/2020/06/06/Ubuntu18%E5%AE%89%E8%A3%85%E9%85%B7Q/","excerpt":"最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。","text":"最近发现我的服务器完全闲置了，所以我决定在上面部署一个qqbot来练习自己的py爬虫。 安装Docker这里我们首先安装Docker，关于什么是Docker，请点击知乎问答。关于这里的说法我大致现总结一下，一家之见，如有不足，请私聊点出。这里同样的以集装箱做比喻，我们在Docker上部署的每一个应用都相当于一个集装箱，每个集装箱之间互不影响，这样就解决了关于应用之间的冲突问题，所以我们部署的所有应用都可以使用一艘船(服务器)去进行运输，节省了开支与时间。 卸载旧docker1sudo apt-get remove docker docker-engine docker.io containerd runc 使用存储库安装 更新apt软件包索引并安装软件包以允许apt通过HTTPS使用存储库： 1234567$ sudo apt-get update$ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 添加Docker的官方GPG密钥： 1$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥 。123456$ sudo apt-key fingerprint 0EBFCD88pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt;sub rsa4096 2017-02-22 [S] 安装docker引擎 更新apt程序包索引，并安装最新版本的Docker Engine和容器，或转到下一步以安装特定版本：12$ sudo apt-get update$ sudo apt-get install docker-ce 检验docker是否成功1$ docker version 拉取酷Q镜像拉取命令1docker pull coolq/wine-coolq 查看是否成功镜像名称是：$coolq/wine-coolq$1234docker images (查看镜像)``` ## 运行命令docker run —name=coolq -d -p 9000:9000 -v /home/wt/coolq/coolq-data:/home/user/coolq -e VNC_PASSWD=12345678 -e COOLQ_ACCOUNT=905584041 coolq/wine-coolq```释义 —name=coolq是将镜像命名为coolq 9000:9000是开放9000端口 /home/wt/coolq/coolq-data:/home/user/coolq 宿主机路径：酷q数据文件路径。 VNC_PASSWD=12345678:网页登陆密码 COOLQ_ACCOUNT=905584041登陆的qq好 coolq/wine-coolq 部署的镜像名称 报错关于docker的报错，今天一共出现三种，如下： 部署的端口冲突，我们改一下端口就好了 部署的应用的image已存在，两种修复办法，第一改掉名称，第二先暂停重复的应用(docker stop (container id))然后删除它(docker remove (container id))。 部署完以后无效，我这里是因为云服务器没有打开部署的端口号，到服务器找到安全组打开端口以后运行流畅。 部分docker命令 功能 命令 部署 docker pull 应用名 查看部署状态 docker ps -a 暂停应用 (docker stop (container id)) 删除已部署应用 (docker remove (container id)) 总结看了一下官方部署文档里面的下载命令，说真的，我居然没看懂，所以我要在这里写下来他们的差异。 install与rpm： 关于这两个的差异的话呢，主要体现在对于安装有依赖包的软件，用yum命令特别方便，如果用rpm命令，就必须要先装依赖包再装软件包，而yum命令会直接匹配依赖包然后直接安装。 dokg与apt-get：dpkg只能安装已经下载到本地机器上的deb包. apt-get能在线下载并安装deb包,能更新系统,且还能自动处理包与包之间的依赖问题,这个是dpkg工具所不具备的。 apt方式安装apt-get是debian，ubuntu发行版的包管理工具，与红帽中的yum工具非常类似。apt-get命令一般需要root权限执行，所以一般跟着sudo命令例sudo apt-get xxxxapt-get install packagename——安装一个新软件包（参见下文的aptitude）apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）apt-get —purge remove packagename——卸载一个已安装的软件包（删除配置文件）dpkg —force-all —purge packagename ——有些软件很难卸载，而且还阻止了别的软件的应用，就可以用这个，不过有点冒险。apt-get autoremove——因为apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件。apt-get autoclean——定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，可以释放大量的磁盘空间。如果需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。apt-get clean——这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。apt-get upgrade——更新所有已安装的软件包apt-get dist-upgrade——将系统升级到新版本apt-cache search string——在软件包列表中搜索字符串apt-cache showpkg pkgs——显示软件包信息。apt-cache stats——查看库里有多少软件apt-cache dumpavail——打印可用软件包列表。apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。apt-cache pkgnames——打印软件包列表中所有软件包的名称 参考文献 16.04部署酷Q docker官方部署文档 linux的多种安装方式","categories":[{"name":"配置环境","slug":"配置环境","permalink":"https://www.dream-ak.top/categories/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.dream-ak.top/tags/Linux/"}]},{"title":"Calendar类","slug":"Calenda","date":"2020-06-05T09:57:34.000Z","updated":"2020-06-05T12:09:49.185Z","comments":true,"path":"2020/06/05/Calenda/","link":"","permalink":"https://www.dream-ak.top/2020/06/05/Calenda/","excerpt":"自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。","text":"自己做的日历轮子终究比不上Java的Calendar类啊，至少不用思考那么多的有关越界问题。接下来我们就来了解一下Calendar类。 Calendar类所述Calendar类是一个抽象类，可以为在某一特定时刻和一组之间的转换的方法calendar fields如YEAR ， MONTH ， DAY_OF_MONTH ， HOUR ，等等，以及用于操纵该日历字段，如获取的日期下个星期。 时间上的瞬间可以用毫秒值表示，该值是从1970年1月1日00:00 00：00.000 GMT（Gregorian）的Epoch的偏移量。 获取当前时间123456789// 使用默认时区和语言环境获得一个日历Calendar cal = Calendar.getInstance();// 赋值时年月日时分秒常用的6个值，注意月份下标从0开始，所以取月份要+1System.out.println(&quot;年:&quot; + cal.get(Calendar.YEAR));System.out.println(&quot;月:&quot; + (cal.get(Calendar.MONTH) + 1)); System.out.println(&quot;日:&quot; + cal.get(Calendar.DAY_OF_MONTH));System.out.println(&quot;时:&quot; + cal.get(Calendar.HOUR_OF_DAY));System.out.println(&quot;分:&quot; + cal.get(Calendar.MINUTE));System.out.println(&quot;秒:&quot; + cal.get(Calendar.SECOND)); 设置时间 统一设置1234Calendar cal = Calendar.getInstance();// 如果想设置为某个日期，可以一次设置年月日时分秒，由于月份下标从0开始赋值月份要-1// cal.set(year, month, date, hourOfDay, minute, second);cal.set(2018, 1, 15, 23, 59, 59);单个设置12345678// 或者6个字段分别进行设置，由于月份下标从0开始赋值月份要-1cal.set(Calendar.YEAR, 2018);cal.set(Calendar.MONTH, Calendar.FEBRUARY);cal.set(Calendar.DAY_OF_MONTH, 15);cal.set(Calendar.HOUR_OF_DAY, 23);cal.set(Calendar.MINUTE, 59);cal.set(Calendar.SECOND, 59);System.out.println(cal.getTime()); 时间计算使用add方法对某个时间进行修改，如果月份修改后该日子不存在，会将不存在的日期归为当月日历的最后一天。时间修改12345Calendar cal = Calendar.getInstance();System.out.println(cal.getTime());cal.set(2018, 1, 15, 23, 59, 59);cal.add(Calendar.SECOND, 1);//加一秒System.out.println(cal.getTime());月份修改12345Calendar cal = Calendar.getInstance();cal.set(2018, 1, 31, 8, 0, 0);System.out.println(cal.getTime());cal.add(Calendar.MONTH, 1);//变为2018/2/28System.out.println(cal.getTime());","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Linux用户权限管理","slug":"Linux用户权限管理","date":"2020-06-03T03:45:32.000Z","updated":"2020-06-03T13:25:40.163Z","comments":true,"path":"2020/06/03/Linux用户权限管理/","link":"","permalink":"https://www.dream-ak.top/2020/06/03/Linux%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。","text":"关于Linux的权限管理不得不说十分的重要，几乎很多在部署上的错误都是因为权限不够，所以这里特意写一篇来了解这个Linux的权限管理。 档案的基本权限这里为表达方便，我把文件和目录统称为档案。 档案的属性对于一个档案我们首先在目录里面使用&lt;ll&gt;命令，查看每一个档案的属性，下图是属性的介绍表 第一栏是档案的类型权限。第一个字元代表这个档案是『目录、档案或连结档等等』： 当为[ d ]则是目录。当为[ - ]则是档案。若是[ l ]则表示为连结档(link file)；若是[ b ]则表示为装置档里面的可供储存的周边设备(可随机存取装置)；若是[ c ]则表示为装置档里面的序列埠设备，例如键盘、滑鼠(一次性读取装置)。接下来的字元中，以三个为一组，且均为『rwx』的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。第一组为『档案拥有者可具备的权限』，该档案的拥有者可以读写，但不可执行；第二组为『加入此群组之帐号的权限』；第三组为『非本人且没有加入本群组之其他帐号的权限』。 第二栏是与该文件的连接数每个档案都会将他的权限与属性记录到档案系统的i-node中，不过，我们使用的目录树却是使用档名来记录，因此每个档名就会连结到一个i-node啰！这个属性记录的，就是有多少不同的档名连结到相同的一个i-node号码去就是了。 第三栏是账户拥有者 第四栏表示这个档案的所属群组在Linux系统下，你的帐号会加入于一个或多个的群组中。举刚刚我们提到的例子，class1, class2, class3均属于projecta这个群组，假设某个档案所属的群组为projecta，且该档案的权限如图5.2.2所示(-rwxrwx—-) ，则class1, class2, class3三人对于该档案都具有可读、可写、可执行的权限(看群组权限)。但如果是不属于projecta的其他帐号，对于此档案就不具有任何权限了。 第五栏为这个档案的容量大小，预设单位为bytes； 第六栏为修改日期这一栏的内容分别为日期(月/日)及时间。如果这个档案被修改的时间距离现在太久了，那么时间部分会仅显示年份而已。如下所示： 第7栏为文档名称这个栏位就是档名了。比较特殊的是：如果档名之前多一个『 . 』，则代表这个档案为『隐藏档』，例如上表中的.config那一行，该档案就是隐藏档。你可以使用『ls』及『ls -a』这两个指令去感受一下什么是隐藏档啰！ 文档的重要性与Windows系统不一样的是，在Linux系统当中，每一个档案都多加了很多的属性进来，尤其是群组的概念，这样有什么用途呢？其实，最大的用途是在『资料安全性』上面的。 系统保护的功能：举个简单的例子，在你的系统中，关于系统服务的档案通常只有root才能读写或者是执行，例如/etc/shadow这一个帐号管理的档案，由于该档案记录了你系统中所有帐号的资料，因此是很重要的一个设定档，当然不能让任何人读取(否则密码会被窃取啊)，只有root才能够来读取啰！所以该档案的权限就会成为[ ————— ]啰！咦！所有人都不能使用？没关系，root基本上是不受系统的权限所限制的，所以无论档案权限为何，预设root都可以存取喔！ 团队开发软体或资料共用的功能：此外，如果你有一个软体开发团队，在你的团队中，你希望每个人都可以使用某一些目录下的档案，而非你的团队的其他人则不予以开放呢？以上面的例子来说，testgroup的团队共有三个人，分别是test1, test2, test3，那么我就可以将团队所需的档案权限订为[ -rwxrws—- ]来提供给testgroup的工作团队使用啰！(怎么会有s呢？没关系，这个我们在后续章节再讲给你听！) 未将权限设定妥当的危害：再举个例子来说，如果你的目录权限没有作好的话，可能造成其他人都可以在你的系统上面乱搞啰！例如本来只有root才能做的开关机、ADSL的拨接程式、新增或删除使用者等等的指令，若被你改成任何人都可以执行的话，那么如果使用者不小心给你重新开机啦！重新拨接啦！等等的！那么你的系统不就会常常莫名其妙的挂掉啰！而且万一你的使用者的密码被其他不明人士取得的话，只要他登入你的系统就可以轻而易举的执行一些root的工作！ 可怕吧！因此，在你修改你的linux档案与目录的属性之前，一定要先搞清楚，什么资料是可变的，什么是不可变的！千万注意啰！接下来我们来处理一下档案属性与权限的变更吧！ 改变档案的属性和权限 改变所属群组, chgrp改变一个档案的群组真是很简单的，直接以chgrp来改变即可，咦！这个指令就是change group的缩写嘛！这样就很好记了吧！^_^。不过，请记得，要被改变的群组名称必须要在/etc/group档案内存在才行，否则就会显示错误！12345678910[root@study ~]# chgrp [-R] dirname/filename ... 选项与参数：-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案、目录 都更新成为这个群组之意。常常用在变更某一目录内所有的档案之情况。范例： [root@study ~]# chgrp users initial-setup-ks.cfg [root@study ~]# ls -l -rw-r--r--. 1 root users 1864 May 4 18:01 initial-setup -ks.cfg[root@study ~]# chgrp testing initial-setup-ks.cfg chgrp: invalid group: `testing&apos; &lt;==发生错误讯息啰～找不到这个群组名～ 改变档案拥有者, chown如何改变一个档案的拥有者呢？很简单呀！既然改变群组是change group，那么改变拥有者就是change owner啰！BINGO！那就是chown这个指令的用途，要注意的是，使用者必须是已经存在系统中的帐号，也就是在/etc/passwd 这个档案中有纪录的使用者名称才能改变。 chown的用途还满多的，他还可以顺便直接修改群组的名称呢！此外，如果要连目录下的所有次目录或档案同时更改档案拥有者的话，直接加上-R的选项即可！我们来看看语法与范例：1234567891011121314[root@study ~]# chown [-R]帐号名称档案或目录 [root@study ~]# chown [-R]帐号名称:群组名称档案或目录选项与参数：-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都变更范例：将initial-setup-ks.cfg的拥有者改为bin这个帐号： [root@study ~]# chown bin initial-setup-ks.cfg [root@study ~]# ls -l -rw-r- -r--. 1 bin users 1864 May 4 18:01 initial-setup-ks.cfg范例：将initial-setup-ks.cfg的拥有者与群组改回为root： [root@study ~]# chown root:root initial-setup-ks.cfg [root@study ~]# ls -l - rw-r--r--. 1 root root 1864 May 4 18:01 initial-setup-ks.cfg 事实上，chown也可以使用『chown user.group file』，亦即在拥有者与群组间加上小数点『 . 』也行！不过很多朋友设定帐号时，喜欢在帐号当中加入小数点(例如vbird.tsai这样的帐号格式)，这就会造成系统的误判了！所以我们比较建议使用冒号『:』来隔开拥有者与群组啦！此外，chown也能单纯的修改所属群组呢！例如『chown .sshd initial-setup-ks.cfg』就是修改群组～看到了吗？就是那个小数点的用途！ 改变权限, chmod这里只讲一种，另外一种u、g、o、a代名词的自行了解。Linux档案的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限，先复习一下刚刚上面提到的资料：档案的权限字元为：『-rwxrwxrwx』，这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下：r:4w:2x:1每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—-] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= —- = 0+0+0 = 0所以等一下我们设定权限的变更时，该档案的权限数字就是770啦！变更权限的指令chmod的语法是这样的：1234[root@study ~]# chmod [-R] xyz档案或目录选项与参数：xyz : 就是刚刚提到的数字类型的权限属性，为rwx 属性数值的相加。-R : 进行递回(recursive)的持续变更，亦即连同次目录下的所有档案都会变更 档案权限介绍对于档案的权限这里是两种，分别分为文件的权限和目录的权限 当是一个文件的时候，『r』就是浏览文件，『w』就是修改文件，『x』就是执行文件 当该档案是一个目录的时候『r』是查看目录下的所有档案或档案信息，『w』是修改当前目录的文档信息，『x』是是否能进入该目录的权限。 目录 放置档案内容 /bin 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。 在/bin底下的指令可以被root与一般帐号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等常用的指令。 /boot 这个目录主要在放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。 Linux kernel常用的档名为：vmlinuz，如果使用的是grub2这个开机管理程式，则还会存在/boot/grub2/这个目录喔！ /dev 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中的。你只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/loop, / dev/sd等等 /etc 系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行档(binary)在这个目录中喔。比较重要的档案有： /etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在/etc/目录下喔：&lt;\\br&gt;/etc/opt(必要)：这个目录在放置第三方协力软体/opt的相关设定档/etc/X11/(建议)：与X Window有关的各种设定档都在这里，尤其是xorg.conf这个X Server的设定档。&lt;\\br&gt;/etc/sgml/(建议)：与SGML格式有关的各项设定档&lt;\\br&gt;/etc/xml/(建议)：与XML格式有关的各项设定档 /lib 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已。什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程式的执行之意。另外FHS还要求底下的目录必须要存在：&lt;\\br&gt;/lib/modules/：这个目录主要放置可抽换式的核心相关模组(驱动程式)喔！&lt;\\br&gt;/media media是『媒体』的英文，顾名思义，这个/media底下放置的就是可移除的装置啦！ 包括软碟、光碟、DVD等等装置都暂时挂载于此。常见的档名有：/media/floppy, /media/cdrom等等。 /mnt 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦！只是有了/media之后，这个目录就用来暂时挂载用了。 /opt 这个是给第三方协力软体放置的目录。什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下呢！ /run 早期的FHS 规定系统开机后所产生的各项资讯应该要放置到/var/run 目录下，新版的FHS 则规范到/run 底下。由于/run 可以使用记忆体来模拟，因此效能上会好很多！ /sbin Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来『设定』系统，其他使用者最多只能用来『查询』而已。 放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, mkfs等等。 /srv srv可以视为『service』的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。常见的服务例如WWW, FTP等等。举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。不过，系统的服务资料如果尚未要提供给网际网路任何人浏览的话，预设还是建议放置到/var/lib 底下即可。 /tmp 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊！因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除唷！ 参考文章鸟哥的Linux私房菜","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.dream-ak.top/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.dream-ak.top/tags/Linux/"}]},{"title":"CCPC Wannafly Winter Camp Day3","slug":"DAY3","date":"2020-05-19T02:35:01.000Z","updated":"2020-06-03T03:20:17.315Z","comments":true,"path":"2020/05/19/DAY3/","link":"","permalink":"https://www.dream-ak.top/2020/05/19/DAY3/","excerpt":"最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。","text":"最近比赛有点诡异，一直只有签到水准，人都没了。不禁开始思考知识面有点狭窄了，加油，继续补题。本次A题与E题不讲，补C题与G题。 G火山哥周游世界赛时想到树，但是没有想到是树形dp，主要是这里的根实在太多了，看了题解，原来换根$dp$完全可以解决这种题型，而且常用于解决这些问题。该类题目的特点是：给定一个树形结构，需要以每个节点为根进行一系列统计。完全符合。 解题思路经过$k$个点的最短路径很容易看出来就是从点$s$出发经过所有点后在一个节点上停下来，那么距离就是$dis = sum[s]-dept[s]$其中$sum[s]$表示$s$到经过$k$点后返回原点的距离，而$dept[s]$表示从$s$开始走，能到的$k$个点中最远的那个。问题就分解成了两个子问题。 从当前点到达k个点后返回自身距离。 从当前点出发能走到的最远的距离。 对于这两个问题，我们先看问题1，首先单独考虑一个点,一个点时直接暴力$dfs$就好了。扩展来看多个点。我们在一个点$dfs$时构建了一棵树，考虑父节点(上一棵树的根节点)与子节点的关系，对于父节点来说，他的答案是已知的，而更新到子节点我们也就只要考虑如何更新子节点，子节点维护了子节点下面的所有点的距离，根据父节点我们也就可以更新该节点往上走的所有值，同时判断是否加上一个边$(u \\rightarrow v)$。来看更新过程1234567if(m-sz[v]==0)&#123;//v上面没有有需要经过的点 dp[v]=dp[u]-ed[i].w;把边权去掉&#125;else if(sz[v]==0)&#123;//v下面有需要经过的点 dp[v]=dp[u]+ed[i].w;增加边权&#125;else dp[v]=dp[u];//该点是必要点(必须经过)所以边权不变。 子问题2：当前点能到的最远距离。也是首先来看单个点，我们可以知道，对于单个点来说，直接大力$dfs$就好了。接下来，我们来看多个点，我们首先已经处理一个点，考虑以他为父节点，那么父节点最远距离已知，我们将一棵按照两个节点$u \\rightarrow v$割成两颗子树，分别以$u$和$v$为父节点。那么当前节点v的能到的$dept=max(v树里面能走到的最远的距离,u树能走到的最远距离+u \\rightarrow v)$而$v$树里面最远的距离在第一次$dfs$就可以知道，明显可以发现一个道理，不管根节点在$v$的上面怎么变，他的父节点一直不变，且$v$下面的节点结构也不变！(是你爹终归是爹)。$u$树的最远距离有两种可能 经过点$v$，那就有点尴尬了，我们考虑一条不经过$v$的次长路径和$u$往上走的最长路径更新最远距离 不经过点$v$，那直接就是，$u$往上走的最远距离和它往不经过v的最长路径更新最远距离。 可能会问为什么是不能经过$v$的最长路径，这是$u$树(以$u$为根节点，断掉$u \\rightarrow v$)边的树。来看转移方程123456//注意，如果上面没有树，就不要去寂寞的更新了。if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123; up[v]=max(up[u],deep1[u])+ed[i].w;&#125;else if(m-sz[v]!=0)&#123; up[v]=max(up[u],deep0[u])+ed[i].w;&#125; 来看全部代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))struct ED&#123; int pre,to; ll w;&#125;ed[N];int head[N],tot=0,vis[N],sz[N],n,m;ll deep0[N],dp[N],deep1[N],ans[N],dept[N],up[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].to=v; ed[tot].w=w; head[u]=tot;&#125;void dfs0(int u,int fa)&#123; for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].to; if(fa==v) continue; dfs0(v,u); sz[u]+=sz[v]; if(sz[v])&#123; dp[u]+=dp[v]+ed[i].w; if(deep0[v]+ed[i].w&gt;deep0[u])&#123; vis[u]=v; deep1[u]=deep0[u]; deep0[u]=ed[i].w+deep0[v];//更新最长路 &#125;else deep1[u]=max(deep1[u],deep0[v]+ed[i].w);//保证了最长路与次长路不在同一个子节点上面 &#125; &#125;&#125;void dfs1(int u,int fa)&#123; //printf(&quot;%d %d %d %d\\n&quot;,u,dp[u],deep0[u],up[u]); dept[u]=max(deep0[u],up[u]); ans[u]=(dp[u]*2-dept[u]); for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].to; if(fa==v) continue; if(m-sz[v]==0)&#123; dp[v]=dp[u]-ed[i].w; &#125; else if(sz[v]==0)&#123; dp[v]=dp[u]+ed[i].w; &#125; else dp[v]=dp[u]; if(vis[u]==v&amp;&amp;m-sz[v]!=0)&#123; up[v]=max(up[u],deep1[u])+ed[i].w; &#125;else if(m-sz[v]!=0)&#123; up[v]=max(up[u],deep0[u])+ed[i].w; &#125; dfs1(v,u); &#125;&#125;int main()&#123; int i,j,k,t=0; int u,v,w; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); tot=0; rep(i,1,n-1)&#123; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); &#125; rep(i,1,m) scanf(&quot;%d&quot;,&amp;u),sz[u]=1; dfs0(1,1); dfs1(1,1); rep(i,1,n)&#123; printf(&quot;%lld\\n&quot;,ans[i]); &#125; //system(&quot;pause&quot;); return 0;&#125; 无向图定向迪尔沃斯定理定理指出：对于任意有限偏序集，其最长链中元素的数目必等于其最小反链划分中反链的数目。具体应用有 求一个序列的上升子序列的数量，我们可以求其最长下降子序列的长度就是其上升子序列的数量。题目链接 这一题就当是开了眼，蛮玄乎的。我们暴力枚举每一个点的颜色，注意其一条边之间的两个点颜色不得相同，当颜色使用的最少的时候，就是其最小反链的数目+1，直接输出就好了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 17+5;typedef long long ll;#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))struct ED&#123; int pre,to,w;&#125;ed[N*2];int head[N],tot,ans=30,n,m,siz=0,clo[N];void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].to=v; head[u]=tot;&#125;bool check(int u,int flag)&#123; for(int i=head[u];i;i=ed[i].pre)&#123; if(clo[ed[i].to]==flag) return 1; &#125; return 0;&#125;void dfs(int u,int res)&#123; if(res&gt;ans) return ; if(u&gt;n)&#123; ans=min(ans,res); return ; &#125; rep(j,1,res)&#123; if(check(u,j)) continue; clo[u]=j; dfs(u+1,res); &#125; clo[u]=res+1; dfs(u+1,res+1); clo[u]=0;&#125;int main()&#123; int i,j,k,t=0; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); ans=m+1; siz=1,tot=0; rep(i,1,m)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(v,u); add(u,v); &#125; dfs(1,1); printf(&quot;%d\\n&quot;,ans-1); //system(&quot;pause&quot;); return 0;&#125; 参考资料 迪尔沃斯定理","categories":[{"name":"比赛日志","slug":"比赛日志","permalink":"https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"2020美团杯补题日志","slug":"2020美团杯补题日志","date":"2020-05-18T13:14:29.000Z","updated":"2020-05-18T13:50:27.304Z","comments":true,"path":"2020/05/18/2020美团杯补题日志/","link":"","permalink":"https://www.dream-ak.top/2020/05/18/2020%E7%BE%8E%E5%9B%A2%E6%9D%AF%E8%A1%A5%E9%A2%98%E6%97%A5%E5%BF%97/","excerpt":"说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！cf疯狂掉分，感人肺腑:(","text":"说句实在的，这一场我得好好检讨，10分钟秒出的思路被自己否决后一直没写出来就算了，还没有去开其他的题目！最大的失职，同时考虑问题还是不够周到，明明和AC代码就差个1了，还以为是自己思路错了。。。看来很久没刷题，都没有手感了！cf疯狂掉分，感人肺腑:( A题真的是写题3分钟，debug5小时，人都傻了，秒出思路后居然细节处理出现问题，样例都没过，后面疯狂想到假算法，我真是个睿智。 思路因为在整个字符串里面都不能出现$xxxll$这个子序列，那么我们思考最后的修改后的结果，显然可以知道在每一个位置上其前面不得超过$2$个$x$，多余的$x$我们全部转成$l$，这样操作结果是在该位置以前一定不会有非法串，后面不能超过$1$个$l$，将多余的$l$全部转成$x$。然后枚举每一个位置得到其最小值就是答案了。1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 2e5+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))char a[N];int pre[N],nxt[N];int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%s&quot;,a+1); int len = strlen(a+1); rep(i,1,105) pre[i]=0,nxt[i]=0; rep(i,1,len) pre[i]=pre[i-1]+(a[i]==&apos;x&apos;); for(i=len;~i;i--) nxt[i]=nxt[i+1]+(a[i]==&apos;l&apos;); int ans = 1000; rep(i,1,len)&#123; ans=min(ans,max(pre[i-1]-2,0)+max(0,nxt[i]-1)); //printf(&quot;%d %d\\n&quot;,pre[i],nxt[i]); &#125; printf(&quot;%d\\n&quot;,ans); &#125; //system(&quot;pause&quot;); return 0;&#125; M一个交互题，主要是关于$sort$被卡的问题，很玄学！官方解释是sort在数据量很小时自动退化为插入排序，而qsort不会。 qsort使用方法 传入数组地址 传入排序长度 传入排序元素字节长度 最重要的一点！cmp函数，格式固定，返回值为int，大于零则表示大于，小于零则表示小于。这里贴一个$qsort$的版本12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &quot;lcs.h&quot;using namespace std;const int N = 2e5+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))int cmp(const void *a,const void *b)&#123;//此处格式固定 int num[2]=&#123;*(int *) a ,*(int *)b&#125;; int flag = get_lcs(2,num); if(flag&gt;1) flag=1; else flag=-1; return -flag;&#125;void find_permutation(int n, int res[])&#123; int i; rep(i,0,n-1)&#123; res[i]=i+1; &#125; qsort(res,n,sizeof(int),cmp);&#125;","categories":[{"name":"比赛日志","slug":"比赛日志","permalink":"https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"shell入门","slug":"shell入门","date":"2020-05-12T02:26:45.000Z","updated":"2020-06-03T03:29:15.150Z","comments":true,"path":"2020/05/12/shell入门/","link":"","permalink":"https://www.dream-ak.top/2020/05/12/shell%E5%85%A5%E9%97%A8/","excerpt":"最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础","text":"最近Linux有课设，嗯，看了一下，蛮有意思的，准备再去买一台云服务器来搞课设，嘿嘿嘿。先来打点基础 shell基础注释# 是注释号 变量变量分为永久变量和临时变量临时变量是shell内部定义，用于该shell程序，随shell程序关闭而清理。永久变量是环境变量，不随shell结束而消失。变量定义和python一致，直接定义就好了。$ 访问变量set命令是列出所有变量 字符串字符串的单引号与双引号单引号不会自动访问变量，而双引号会访问该变量的值。举个例子 定义一个var=’aaa’a=’var’这里a是vara=”var”这里a是aaa 特殊符号 符号 意义 \\$*($@) 这个程序的所有参数 $# 几个配置参数 $$ 该程序的PID @! 后台的pid值 输入read 从键盘输入数据 输出echo 输出当前包含的变量 运算shell仅支持整形运算expr 整形运算(仅支持整形运算)+代表加法-代表减法/代表除法*乘法所有运算都要放到反单引号里面才能成功，且运算符两边必须含有空格，等号两边不得含有空格 test变量测试语句字符测试 命令 含义 test str1=str2 是否相等 test str1!=str2 是否不相等 test str1 是否为空 test -n str1 判断是否不为空 test -z str1 是否为空 数字测试 命令 含义 test int1 -eq int2 是否相等 (equal) test int1 -ge int2 int1 是否大于等于int2 (great) test int1 -gt int2 int1 是否大于int2 (great than) test int1 -le int2 int1 是否小于等于int2 (less) test int1 -lt int2 int1 是否小于int2 (less than) test int1 -ne int2 int1 不相等int2 文件测试 命令 含义 test -d -file 是否为目录 test -f file 指定文件是否常规文件 test -x file 指定文件是否可执行 test -r file |指定文件是否可读test -w file |指定文件是否可写test -a/e file |指定文件是否存在test -s file |指定文件大小是否为0 exit 返回，0为正常流程控制语句if … then … fi其中 -a逻辑与，-o逻辑或循环语句while[逻辑语句]do…done 环境变量环境变量书要是定义对系统操作的环境生效的系统默认环境变量如PATH等环境配置文件 命令 含义 /etx/profile 全局变量 /etx/profile.d/*.sh 全局变量 ~/.bash_profile 仅对当前用户有效 ~/.bashrc 仅对当前用户有效 /etc/bashrc 全局变量 启动配置文件：source 配置文件或 .配置文件 重启命令init 6","categories":[{"name":"shell","slug":"shell","permalink":"https://www.dream-ak.top/categories/shell/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.dream-ak.top/tags/Linux/"}]},{"title":"AC自动机与矩阵快速幂","slug":"AC自动机与矩阵快速幂","date":"2020-05-09T13:09:20.000Z","updated":"2020-05-10T12:54:46.687Z","comments":true,"path":"2020/05/09/AC自动机与矩阵快速幂/","link":"","permalink":"https://www.dream-ak.top/2020/05/09/AC%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快","text":"这一道题一周前我可能一个技能点都没有。。。太他妈真实了！,菜的真实，还是打难比赛学得快 题目链接题目大意首先给我们$x$个字符串，主要是由$A,C,T,G$四个字符组成的长度不超过10的字符串，$x \\leq 10$，问由$A,C,G,T$组成的长度为$m$的字符串有多少个合法的(如果该字符串有一个子串和之前的字符串一样，则该字符非法)。$m \\leq 2*10^9$ 思路$m$初看很假！这么大怎么弄，不要慌，我们先慢慢来，首先一共有$x$个模式串，我们先对模式串建一个$trie$树，保留他的$tail$节点。如果把一个构造后的字符串a后面加一个字符$v$看成是从$a$这个节点引4条有向路径出去。同时$trie$树里面的$tail$节点都是尾节点，这些节点如果出现在构造后的字符串里面，那么该串也就会出现非法子串。这题意也就抽象成了构造后的字符串里面不得含有非法节点，一共有多少种构造方式。联想到AC自动机fail的性质，它可以$O(n)$的判断字典树里面节点$cur$后面添加一条边v是否会成为非法节点。(通过fail失配节点去寻找以$root \\rightarrow fail$是$root \\rightarrow cur$的尾串，进而判断是否是非法节点)，也就完成了建边操作。再看一个矩阵定理邻接矩阵$a$ * $a$所代表的含义是从$i$节点经过两步以后能达到$j$的方案数。以此类推$a * a * a$就是三步的意思，证明的话看参考资料吧从一颗字典树来看我们生成一个矩阵，表示从$u \\rightarrow v$的方案数，从此观之，我们可以知道如果$mat[u][v]=0$就表示如果在由字典树到$u$的字串后加一个$v$变成了非法串。黑色箭头表示失配指针，线条表示边，从上至下有向边。模式串为$ACG$与$C$时$trie$树如上图我们就可以知道初始矩阵$mat$为： 2 1 0 0 00 0 0 0 00 0 0 0 00 0 0 0 00 0 0 0 0 这里的$mat[0][0]=2$是因为从$0$节点走$G(T)$边会发现trie树里面没有该节点，那么走向$G(T)$后的节点还是一个虚点$0$节点，所以$mat[0][0]$就等于2了。然后直接用上面得到的矩阵开始矩阵快速幂。直接得到$m$步后的矩阵，统计$mat[0]$的和，表示从$0$到任意节点的值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define maxn 110#define rep(i,a,b) for(int i=(a);i&lt;=b;i++)struct kkk&#123; int son[5],flag,fail;&#125;trie[maxn];int cnt,nxt[maxn];const int mod = 100000;char aa[maxn];queue&lt;int &gt;q;int check(char x)&#123; if(x==&apos;A&apos;) return 1; if(x==&apos;C&apos;) return 2; if(x==&apos;T&apos;) return 3; return 4;&#125;void insert(char* s)&#123; int u=1,len=strlen(s); for(int i=0;i&lt;len;i++)&#123; int v=check(s[i]); if(!trie[u].son[v])trie[u].son[v]=++cnt; u=trie[u].son[v]; &#125; trie[u].flag=1;&#125;void getFail()&#123; for(int i=1;i&lt;5;i++)trie[0].son[i]=1; q.push(1);trie[1].fail=0; while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=1;i&lt;5;i++)&#123; int v=trie[u].son[i]; int Fail=trie[u].fail; if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125; trie[v].fail=trie[Fail].son[i]; trie[v].flag|=trie[trie[Fail].son[i]].flag;//核心，标记是否为非法节点。 q.push(v); &#125; &#125;&#125;struct mat&#123; long long m[maxn][maxn];&#125;unit,pos;void init_unit()&#123; for(int i=1;i&lt;=cnt;i++)&#123; unit.m[i][i]=1; &#125;&#125;void builds()&#123; for(int i=1;i&lt;=cnt;i++)&#123; int u; for(int j=1;j&lt;=4;j++)&#123; u = trie[i].son[j]; if(trie[u].flag||trie[i].flag)&#123; continue; &#125; pos.m[i][u]++; &#125; &#125;&#125;mat plus1(mat a,mat b)&#123; mat ans; long long cur; rep(i,1,cnt)&#123; rep(j,1,cnt)&#123; cur = 0; rep(k,1,cnt)&#123; cur += (1ll*a.m[i][k]*b.m[k][j])%mod; cur%=mod; &#125; ans.m[i][j]=cur; &#125; &#125; return ans;&#125;void sol(int n)&#123; int ans = 0; init_unit(); mat cur = unit; builds(); while(n)&#123; if(n&amp;1) cur = plus1(cur,pos); pos = plus1(pos,pos); n&gt;&gt;=1; &#125; for(int i=1;i&lt;=cnt;i++)&#123; ans = (ans+cur.m[1][i])%mod; &#125; printf(&quot;%d\\n&quot;,ans);&#125;int main()&#123; int t,x,n; memset(trie,0,sizeof trie); cnt=1; //代码实现细节，编号从1开始 scanf(&quot;%d %d&quot;,&amp;n,&amp;x); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s&quot;,aa); insert(aa); &#125; getFail(); sol(x); //system(&quot;pause&quot;); return 0;&#125; 瞎说这题简直就是开拓视野，写完了之后理清思路写博客还是有点懵，视野开拓的有点猛，我被吓到了。。。同时注意矩阵快速幂需要注意爆栈问题。 参考资料矩阵乘法正版题解","categories":[{"name":"字符串","slug":"字符串","permalink":"https://www.dream-ak.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"CCPC Wannafly Winter Camp Day2","slug":"Day2","date":"2020-05-02T11:35:21.000Z","updated":"2020-05-07T15:03:59.766Z","comments":true,"path":"2020/05/02/Day2/","link":"","permalink":"https://www.dream-ak.top/2020/05/02/Day2/","excerpt":"持续更新中，，，2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。","text":"持续更新中，，，2020年5月2日，过了这么久我来写朋友们1月份写过的wls集训营的题目，看了一下，，，懵了。唉，在家直接颓废了，思维都跟不上了。今天队友过来A，我过了C说句实在的A我还是有点懵，但是C我是知道了。先来一个C的题解。 C博弈关于这题呢，求有多少种必胜方案。题目明显是一个$nim$博弈，同时先空的输，因而我们可以知道，先手必胜也就是先手拿完以后，进入平衡态，剩余数组异或值为0，那么首先朴素算法。 朴素做法暴力枚举：$CurNor \\oplus a_i &lt; a_i$的数量，输出该数量就是答案了。($CurNor$当前的异或值)枚举$i$明显超时。 bouton定理没错，这里又是一个定理。异或和的最高的为1的二进制位，所有这一位是1的y显然都是必胜态，这一位是0的不是必胜态。为啥？如果是必胜态，那么一定存在 CurNor \\oplus a_i \\leq a_i因为$a_i$里面的某一位变成了$0$以后，不管后面数字怎么变都只会变小，所以上式成立。同时如果不是必胜态，那么一定存在CurNor \\oplus a_i > a_i因为$a_i$里面有一位变成了$1$，不管后面怎么变，都会变大。所以也成立。证毕。123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 2e5+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))ll a[N];int cnt[N],ans[N];ll sum=0;int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d&quot;,&amp;n); rep(i,1,n)&#123; scanf(&quot;%lld&quot;,&amp;a[i]); &#125; rep(i,1,n)&#123; int pos=0; rep(j,0,60)&#123; if(a[i]&amp;(1ll&lt;&lt;j)) cnt[j]++; &#125; sum^=a[i]; if(sum==0)&#123; ans[i]=0; continue; &#125; pos = 0; rep(j,0,60)&#123; if(sum&amp;(1ll&lt;&lt;j)) pos=j; &#125; ans[i]=cnt[pos]; &#125; rep(i,1,n)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; //system(&quot;pause&quot;); return 0;&#125; E树上启发式合并普及概念： 重点： 表示其子节点中子树最大的子结点。 重边：一个节点的重边是自身节点与重点的连边。 赛时队友提问：请问有啥好的数据结构能做到在插入是$log$情况下还能二分的吗？本憨批回答，无。我怕不是真憨批。$set$呀！！！错亿，这锅我背了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;const int N = 2e5+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%lld\\n&quot;,(a))set&lt;int&gt; q[N];struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=0,sz[N],son[N];ll ans[N];void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;void dfs1(int u)&#123; int x = 0,sum=1; for(int i=head[u];i;i=ed[i].pre)&#123; int v =ed[i].id; dfs1(v); sum+=sz[v]; if(sz[v]&gt;sz[x]) x=v; &#125; sz[u]=sum; son[u]=x;&#125;void query(int u,int x)&#123; set&lt;int&gt;:: iterator it = q[u].lower_bound(x); if(q[u].empty())&#123; q[u].insert(x); return ; &#125; if(it==q[u].begin())&#123; ll r = *it; ans[u]+=1ll*(r-x)*(r-x); q[u].insert(x); //printf(&quot;%d %lld l\\n&quot;,x,r); return ; &#125; if(it==q[u].end())&#123; ll l = *--it; ans[u]+=1ll*(x-l)*(x-l); q[u].insert(x); //printf(&quot;%d r\\n&quot;,x); return ; &#125; ll r = *it,l=*(--it); ans[u]-=(r-l)*(r-l); ans[u]+=1ll*(r-x)*(r-x); ans[u]+=1ll*(x-l)*(x-l); q[u].insert(x);&#125;void dfs3(int u,int pos)&#123; for(int i=head[u];i;i=ed[i].pre)&#123; int v = ed[i].id; dfs3(v,pos); &#125; query(pos,u);&#125;void dfs2(int u)&#123; for(int i=head[u];i;i=ed[i].pre)&#123; int v = ed[i].id; dfs2(v); &#125; q[u].swap(q[son[u]]); ans[u]=ans[son[u]]; for(int i=head[u];i;i=ed[i].pre)&#123; int v = ed[i].id; if(v==son[u]) continue; q[v].clear(); dfs3(v,u); &#125; query(u,u);&#125;int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d&quot;,&amp;n); rep(i,2,n)&#123; int u; scanf(&quot;%d&quot;,&amp;u); add(u,i); &#125; dfs1(1); dfs2(1); rep(i,1,n)&#123; pt(ans[i]); &#125; //system(&quot;pause&quot;); return 0;&#125;写完这个代码，嗯，说句实在的，感觉算法不是很难理解，唯独在于时间复杂度，他是$n*log_n$的，比较难以理解。同时加深set的理解： 用$q[u]=q[v]$的话时间复杂度是$O(N)$而使用q[u].swap(q[v])就会是$O(1)$，把我t飞了。 关于$set$的$lower_bound()$返回的是第一个大于等于他的位置，如果查询值是最大的，返回一个迭代器，指向最后一个元素的后一个节点，要把它修回来。。。 H 欧拉回路到底是这题提议玄学还是我憨批，我怎么看了那么久题意，刚刚才懂。。。题意懂了以后就很明显地知道是个构造题，构造一个欧拉路。(比赛的时候题意看偏了，以为是随便整个数字就好了，还一直在想为啥样例为啥最大只能到4，是真够憨的我)。 对于一个欧拉路径存在定理: 一个图里面奇度为$0$时存在欧拉回路，为$2$时存在欧拉路径 所以我们先找到合适的点就好了，当点数时奇数时，每一个点的度数都是偶数，存在欧拉回路，当点数时偶数$x$时，每个点度数都是奇数，最少需要加入$x/2-1$条边变成两个奇度顶点。单调性容易证明，可以直接二分，如果数学可以的话我发现其实可以直接算出来。不过赛时二分也不错，写起来也快。算出最大的顶点后直接跑欧拉路就好了，唯一坑点，注意格式！！！格式错误是$30%$12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include&lt;math.h&gt;#include &lt;vector&gt;using namespace std;const int N = 2e6+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))struct ED&#123; int pre,id,w;&#125;ed[2*N];ll check(int x)&#123; if(x%2) return 1ll*x*(x-1)/2; else return 1ll*x*(x-1)/2+(x/2)-1;&#125;int head[N],tot=0;void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; ed[tot].w=1; head[u]=tot;&#125;vector&lt;int&gt; ans;void sol(int x)&#123; for(int &amp;i=head[x];i;i=ed[i].pre)&#123; int v = ed[i].id; if(ed[i].w==0) continue; ed[i].w=ed[i^1].w=0; sol(v); &#125; ans.push_back(x);&#125;int main()&#123; int m,i,j,k,t=0; ll n; scanf(&quot;%lld&quot;,&amp;n); ll l=1,r=1.5e9; while(l&lt;r)&#123; ll mid = ((l+r)+1)/2; if(check(mid)&lt;n) l=mid; else r = mid-1; &#125; int poi = l; if(n&gt;2e6) &#123; printf(&quot;%d\\n&quot;,poi); return 0; &#125; tot=1; for(i=1;i&lt;=poi;i++)&#123; rep(j,i+1,poi)&#123; add(i,j),add(j,i); &#125; &#125; if(poi%2==0)&#123; for(int i=3;i&lt;=poi;i+=2) add(i,i+1),add(i+1,i); &#125; ans.clear(); sol(1); for(i=ans.size();i&lt;=n;i++)&#123; ans.push_back(1); &#125; printf(&quot;%d\\n&quot;,poi); rep(i,0,n-1)&#123; if(i!=n-1) printf(&quot;%d &quot;,ans[i]); else printf(&quot;%d\\n&quot;,ans[i]); &#125; //system(&quot;pause&quot;); return 0;&#125; K AC自动机优化后dp。赛时看着一头雾水，补完以后来瞎逼逼一下，对于这一题，看了一天AC自动机和优化(没办法，tle在93.9了)，真快乐，后来看到一个博主说可以优化fail数组！一共两个优化，可能因为拿到的板子就是$trie$优化后的产物，所以只发现一个$last$优化，说起来网上关于这个优化各说纷纭，我就叫他$last$了，其实应该来说就是剪枝，在得到$fail$数组去查询时，直接跳$fail$数组可能会经过一些没必要的点，那么这些点我们就可以通过$last$优化掉，直接减少跳的次数！(演示代码使用的$trans$数组)至于该题的dp较明显就是$dp[i]=min(dp[i-len(x)]+val[x],dp[i])$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;const int maxn=5e5+5;using namespace std;struct kkk&#123; int son[26],flag,fail;&#125;trie[maxn];int n,cnt,num[maxn],le[maxn],trans[maxn];long long dp[maxn],inf;char a[maxn];queue&lt;int &gt;q;void insert(char* s,int val)&#123; int u=1,len=strlen(s); for(int i=0;i&lt;len;i++)&#123; int v=s[i]-&apos;a&apos;; if(!trie[u].son[v])trie[u].son[v]=++cnt; u=trie[u].son[v]; &#125; if(trie[u].flag == 0) trie[u].flag=val; else trie[u].flag = min(val,trie[u].flag); le[u] = len;&#125;void getFail()&#123; for(int i=0;i&lt;26;i++)trie[0].son[i]=1; //初始化0的所有儿子都是1 q.push(1);trie[1].fail=0; //将根压入队列 while(!q.empty())&#123; int u=q.front();q.pop(); for(int i=0;i&lt;26;i++)&#123; //遍历所有儿子 int v=trie[u].son[i]; //处理u的i儿子的fail，这样就可以不用记父亲了 int Fail=trie[u].fail; //就是fafail，trie[Fail].son[i]就是和v值相同的点 if(!v)&#123;trie[u].son[i]=trie[Fail].son[i];continue;&#125; //不存在该节点，就把父节点的失配节点的该位子节点补充到该节点上来。 trie[v].fail=trie[Fail].son[i]; //存在该节点直接把该节点的失配节点设置为父节点的失配节点的该位子节点的值。 q.push(v); //存在实节点才压入队列 int x = trie[Fail].son[i]; if(trie[x].flag!=0)&#123; trans[v] = x;//利用trans剪枝，假设当前节点是尾节点则此点有效，可以跳到这个点来 &#125;else&#123; trans[v]=trans[x];//无效，跳到该点的上一个点去。 &#125; &#125; &#125;&#125;void query(char* s)&#123; int u=1,len=strlen(s); for(int i=0;i&lt;len;i++)&#123; int v=s[i]-&apos;a&apos;; int k=trie[u].son[v]; //跳Fail while(k&gt;1)&#123; dp[i+1]=min(dp[i+1],1ll*dp[i-le[k]+1]+1ll*trie[k].flag); k=trans[k]; //继续跳trans &#125; u=trie[u].son[v]; //到下一个儿子 &#125; if(dp[len]&gt;=inf)&#123; printf(&quot;-1\\n&quot;); &#125; else&#123; printf(&quot;%lld\\n&quot;,dp[len]); &#125;&#125;int main()&#123; scanf(&quot;%d&quot;,&amp;n); memset(trie,0,sizeof trie); memset(dp,0x3f,sizeof dp); memset(le,0,sizeof le); inf = dp[0]; dp[0]=0; cnt=1; int x; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%s %d&quot;,a,&amp;x); insert(a,x); &#125; getFail(); scanf(&quot;%s&quot;,a); query(a); //system(&quot;pause&quot;); return 0;&#125;","categories":[{"name":"比赛日志","slug":"比赛日志","permalink":"https://www.dream-ak.top/categories/%E6%AF%94%E8%B5%9B%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"codeforces1343F-set操作","slug":"codeforces1343F-set操作","date":"2020-04-23T11:27:55.000Z","updated":"2020-04-23T12:42:13.210Z","comments":true,"path":"2020/04/23/codeforces1343F-set操作/","link":"","permalink":"https://www.dream-ak.top/2020/04/23/codeforces1343F-set%E6%93%8D%E4%BD%9C/","excerpt":"这道F题说句实在的，题意能把人看蒙了，看懂了倒是挺简单的，反正我一开始把题意看难了。","text":"这道F题说句实在的，题意能把人看蒙了，看懂了倒是挺简单的，反正我一开始把题意看难了。 题目题目大意存在一个长度为$n$的排列$a$，然后给出$n-1$个子排列，其中每个子排列的元素为$[a_l,a_{l+1},…,a_r]$，其中$r$是由$2-n$里面的数字，每一个数字必将出现一次。求原来的排列。 思想看到这个每一个数字必将出现一次，就可能想到一个问题了，如果我把$r$前面所有的数字全部确定了，那么第$r$个数字也应该确定了！证明：假设当前确定了$1$到$r-1$的数字，那么可以发现如果把确定的数字在子排列中标记的话，那么将会出现一段子排列刚好只剩下一个数字没有标记，这就是第r个数字，同时还可以发现，这样的子排列只有一个，因为如果有两个的话，那么第r个数字就有两个，可是只有一个位置，很明显冲突了，可用作剪枝。注意这里只是一个必要条件，它不能充分保证得出的排列一定成立，但是能保证原排列一定符合这个性质，所以我们还需要判断是否符合条件。其时间复杂度为$n^3*log_2 n$ 实现想挺容易的，做起来我真的没想到，$set$这么骚，要不是学了一点面向对象，我差点理解不了。每一个子序列都可以放到一个集合里面，每一次标记都是把这个数字从集合里面删除。判断的时候直接看集合是否相同。介绍几个骚操作：以$set d$为例 *d.begin() 为遍历set set&lt;set&lt;int&gt; &gt; d(q.begin(),q.end()) q在这里为vector&lt;set&lt;int&gt; &gt; q ,这个语句的作用是将q这个数组的所有元素存到d这个集合里面。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include&lt;set&gt;using namespace std;const int N = 2e5+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d&quot;,&amp;t); while(t--)&#123; scanf(&quot;%d&quot;,&amp;n); vector&lt;set&lt;int&gt; &gt; q; vector&lt;int&gt; ans; rep(i,1,n-1)&#123; scanf(&quot;%d&quot;,&amp;m); set&lt;int&gt; cur; rep(j,1,m)&#123; int x; scanf(&quot;%d&quot;,&amp;x); cur.insert(x); &#125; q.push_back(cur); &#125; rep(i,1,n)&#123; ans.clear(); vector&lt;set&lt;int&gt; &gt; p = q; int cur = i; ans.push_back(cur); rep(j,1,n-1)&#123; int pos = 0 , cnt = 0; rep(k,0,n-2)&#123; if(p[k].count(cur)) p[k].erase(cur); if(p[k].size()==1) cnt++,pos = *p[k].begin();//遍历set &#125; if(cnt!=1) break; else cur = pos,ans.push_back(cur); &#125; if(j==n)&#123; set&lt;set&lt;int&gt; &gt; d(q.begin(),q.end());//自动把q数组全部放到set里面 bool ok = true; for(int r=1;r&lt;n;r++)&#123; set&lt;int&gt; f; f.clear(); bool flag = false; for(int l=r;l&gt;=0;l--)&#123; f.insert(ans[l]); //printf(&quot;%d &quot;,ans[l]); if(d.count(f)) &#123; flag = true; break; &#125; &#125; // printf(&quot;yes%d %d\\n&quot;,i,flag); if(!flag) &#123; ok = false; break; &#125; &#125; if(ok)&#123; for(int l=0;l&lt;n;l++)&#123; printf(&quot;%d &quot;,ans[l]); &#125; printf(&quot;\\n&quot;); break; &#125; &#125; &#125; &#125; //system(&quot;pause&quot;); return 0;&#125; 参考资料cf题解","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"next添加邮箱与qq","slug":"next添加邮箱与qq","date":"2020-04-22T03:37:55.000Z","updated":"2020-06-06T03:09:59.085Z","comments":true,"path":"2020/04/22/next添加邮箱与qq/","link":"","permalink":"https://www.dream-ak.top/2020/04/22/next%E6%B7%BB%E5%8A%A0%E9%82%AE%E7%AE%B1%E4%B8%8Eqq/","excerpt":"昨天受大佬启发，感觉还是需要添加一些个人的链接放到博客上面，于是兴冲冲的开始去设置了，最后直接爆炸。","text":"昨天受大佬启发，感觉还是需要添加一些个人的链接放到博客上面，于是兴冲冲的开始去设置了，最后直接爆炸。 next添加邮箱问题我们按照普遍方法在$social$里面添加了地址后，部署到$coding$后发现，在邮件和qq前面自动添加了一堆前缀网址(因为已经修好了，所以展示不出来，如果你也出现了这个问题，你会一眼看出来的)，使原本网址无效了，可能是版本原因还是怎么，查了很久，一直出错，最后没办法改了$hexo$的源码，在这里发出来。 解决方案修改文件位置的话，看下这张图片吧，文件放得太深了。1234567891011121314151617181920212223242526&#123;%- if theme.social %&#125; &lt;div class=&quot;links-of-author motion-element&quot;&gt; &#123;%- for name, link in theme.social %&#125; &lt;span class=&quot;links-of-author-item&quot;&gt; &#123;%- set sidebarURL = link.split(&apos;||&apos;)[0] | trim %&#125;//获取添加的链接 &#123;%- if theme.social_icons.enable %&#125; &#123;%- set sidebarIcon = &apos;&lt;i class=&quot;fa fa-fw fa-&apos; + link.split(&apos;||&apos;)[1] | trim + &apos;&quot;&gt;&lt;/i&gt;&apos; %&#125;//获取添加的小图标 &#123;%- else %&#125; &#123;%- set sidebarIcon = &apos;&apos; %&#125;//没有则为空 &#123;%- endif %&#125; &#123;%- if theme.social_icons.enable and theme.social_icons.icons_only %&#125; &#123;%- set sidebarText = &apos;&apos; %&#125; &#123;%- else %&#125; &#123;%- set sidebarText = name %&#125; &#123;%- endif %&#125; &#123;%- if name == &apos;E-Mail&apos; %&#125;//我添加E-Mail的解决办法 &lt;a href=&quot;&#123;&#123; sidebarURL &#125;&#125;&quot; rel=&quot;alternate&quot; title=&quot;E-Mail&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-fw fa-envelope&quot;&gt;&lt;/i&gt; E-Mail&lt;/a&gt; &#123;%- elif name == &apos;QQ&apos; %&#125;//我添加的QQ解决办法 &lt;a href=&quot;&#123;&#123; sidebarURL &#125;&#125;&quot; rel=&quot;alternate&quot; title=&quot;QQ&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt; &lt;i class=&quot;fa fa-fw fa-qq&quot;&gt;&lt;/i&gt;QQ&lt;/a&gt; &#123;%- else %&#125; &#123;&#123; next_url(sidebarURL, sidebarIcon + sidebarText, &#123;title: name + &apos; → &apos; + sidebarURL&#125;) &#125;&#125;//原本的解决办法，这个貌似只能处理链接为http或https开头的链接 &#123;%- endif %&#125; &lt;/span&gt; &#123;%- endfor %&#125; &lt;/div&gt;&#123;%- endif %&#125;由于本人对于swig一知半解，为深入学习，对这个的理解写在注释了，注释方法可能错了(用的是C语言的注释法)，注意删除(不是不想写对，实在百度不到他的只是方案，有途径大佬会的话，可以留言或私聊我，欢迎斧正，对了也可以告诉我哦)。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.dream-ak.top/tags/hexo/"}]},{"title":"树的直径","slug":"树的直径","date":"2020-04-21T09:42:24.000Z","updated":"2020-04-22T04:29:42.458Z","comments":true,"path":"2020/04/21/树的直径/","link":"","permalink":"https://www.dream-ak.top/2020/04/21/%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","excerpt":"时隔14天，洒家终于有准备开始刷题了，暂时开篇第一个就是树的直径！","text":"时隔14天，洒家终于有准备开始刷题了，暂时开篇第一个就是树的直径！ 树的直径这个时候可能就有朋友问了，什么是树的直径？来看，树的直径就是树上的最长简单路。换个说法，就是树上两点之间最长的距离。我这里介绍一个暴力算法，dfs的 算法思想 首先，我们以任意一点$w$去$dfs$搜出距离根节点最远的点（也可以说是，深度最大的点）任意一个($v$)然后以它做根节点去搜以它为根节点时最大的深度，节点为$u$，此即直径。 简单证明:如果w在直径上，那么u一定是直径的一个端点。反证：若u不是端点，则从直径另一端点到w再到u的距离比直径更长，与假设矛盾。如果w不在直径上，且w到其距最远点u的路径与直径一定有一交点c，那么由上一个证明可知，u是直径的一个端点。如果w到最远点u的路径与直径没有交点，设直径的两端为S与T，那么(w-&gt;u)&gt;(w-&gt;c)+(c-&gt;T)，推出(w-&gt;u)+(S-&gt;c)+(w-&gt;c)&gt;(S-&gt;c)+(c-&gt;T)=(S-&gt;T)与假设矛盾。因此w到最远点u的路径与直径必有交点。S—————-c—————-T | w———u 看个例题warm up求在图里面连一条边后最少的割边。由于是割边，我们可以先缩图成DAG图也就是一颗树，然后求其直径(答案就是：桥的数量-直径)，剖去Tarjan缩图，就是个直径板子。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;string.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int N = 2e5+5;const int M = 2e6+5;typedef long long ll;#define rep(i,a,b) for(i=(a);i&lt;=b;i++)#define pt(a) printf(&quot;%d\\n&quot;,(a))struct ED&#123; int pre,id,w;&#125;ed1[M],ed2[M];int head1[N],head2[N],tot1=0,tot2=0;void add1(int u,int v)&#123; ed1[++tot1].id=v; ed1[tot1].pre=head1[u]; ed1[tot1].w = 1; head1[u]= tot1;&#125;void add2(int u,int v)&#123; ed2[++tot2].id=v; ed2[tot2].pre=head2[u]; head2[u]=tot2;&#125;int clo[N],dfn[N],sta[N],low[N],top=0,vis[N],cnt=0,siz=0;int edge=0;void tarjan(int x)&#123; dfn[x]=++cnt; low[x]=cnt; vis[x]=1; sta[++top]=x; //printf(&quot;dfs %d %d\\n&quot;,x,fa); for(int i=head1[x];i;i=ed1[i].pre)&#123; int v=ed1[i].id; //printf(&quot;dfs %d %d\\n&quot;,x,ed1[i].id); if(ed1[i].w==0) continue; ed1[i].w = 0; ed1[i^1].w = 0; if(!dfn[v])&#123; tarjan(v); low[x]=min(low[x],low[v]); if(dfn[x]&lt;low[v]) edge++; &#125; else if(vis[v])&#123; low[x]=min(low[x],dfn[v]); &#125; &#125; if(dfn[x]==low[x])&#123; clo[x]=++siz; vis[x]=0; int sum=1; while(sta[top]!=x)&#123; clo[sta[top]]=siz; vis[sta[top--]]=0; //printf(&quot;%dsss\\n&quot;,sta[top+1]); sum++; &#125; vis[sta[top--]]=0; //printf(&quot;sum %d %d %d\\n&quot;,sum,x,clo[x]); &#125;&#125;int ans = 0,pos=0;void dfs(int x,int fa)&#123; vis[x]=1; dfn[x] = dfn[fa]+1; for(int i=head2[x];i;i=ed2[i].pre)&#123; if(fa!=ed2[i].id&amp;&amp;vis[ed2[i].id]==0)&#123; //printf(&quot;%d %d %d %dsss\\n&quot;,ed2[i].id,x,fa,dfn[x]); dfs(ed2[i].id,x); &#125; &#125; if(dfn[x]&gt;ans)&#123; ans = dfn[x]; pos = x; &#125;&#125;inline int ReadInt()&#123; char ch = getchar(); int data = 0; while (ch &lt; &apos;0&apos; || ch &gt; &apos;9&apos;) &#123; ch = getchar(); &#125; do &#123; data = data*10 + ch-&apos;0&apos;; ch = getchar(); &#125;while (ch &gt;= &apos;0&apos; &amp;&amp; ch &lt;= &apos;9&apos;); return data;&#125;void init()&#123; top=cnt=siz=edge=0; tot1=tot2=1; memset(vis,0,sizeof(vis)); memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(head2,0,sizeof(head2)); memset(head1,0,sizeof(head1));&#125;int main()&#123; int n,m,i,j,k,t=0; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)!=EOF)&#123; if(!n&amp;&amp;!m) break; init(); rep(i,1,m)&#123; int u,v; u = ReadInt(); v = ReadInt(); add1(u,v); add1(v,u); &#125; tarjan(1); for(int i=1;i&lt;=n;i++) for(int j=head1[i];j;j=ed1[j].pre) &#123; int to=ed1[j].id; if(clo[to]!=clo[i]) &#123;add2(clo[to],clo[i]);add2(clo[i],clo[to]);&#125; &#125; ans = 0; memset(vis,0,sizeof vis); dfn[0]=-1; dfs(1,0); memset(vis,0,sizeof vis); dfn[0]=-1; dfs(pos,0); pt(edge-ans); &#125; return 0;&#125; 多讲一点点，因为下面这个和直径思路差不多 树的重心何谓树的重心？树的重心：找到一个点，其所有的子树中最大的子树节点数最少,那么这个点就是这棵树的重心,删去重心后，生成的多棵树尽可能平衡。树的重心可以通过简单的两次搜索求出，第一遍搜索求出每个结点的子结点数量son[u]，第二遍搜索找出使max{son[u],n-son[u]-1}最小的结点。实际上这两步操作可以在一次遍历中解决。对结点u的每一个儿子v，递归的处理v，求出son[v]，然后判断是否是结点数最多的子树，处理完所有子结点后，判断u是否为重心。1234567891011121314151617181920212223242526272829struct CenterTree&#123; int n; int ans; int siz; int son[maxn]; void dfs(int u,int pa)&#123; son[u]=1; int res=0; for (int i=head[u];i!=-1;i=edges[i].next)&#123; int v=edges[i].to; if (v==pa) continue; if (vis[v]) continue; dfs(v,u); son[u]+=son[v]; res=max(res,son[v]-1); &#125; res=max(res,n-son[u]); if (res&lt;siz)&#123; ans=u; siz=res; &#125; &#125; int getCenter(int x)&#123; ans=0; siz=INF; dfs(x,-1); return ans; &#125;&#125;Cent; 参考文章oi-wiki树的直径、树的重心与树的点分治","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"Java连接数据库","slug":"Java连接数据库","date":"2020-04-07T12:57:27.000Z","updated":"2020-06-06T03:10:03.867Z","comments":true,"path":"2020/04/07/Java连接数据库/","link":"","permalink":"https://www.dream-ak.top/2020/04/07/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"用vscode编译Java一直乱码，我还以为是vscode的问题(毕竟vscode的乱码挺多的)。用回了eclipse以后，发现乱换ide是个不好的习惯，那玩意怎么用啊！于是疯狂捣鼓vscode，终于弄好了Java连接数据库且不乱码了。","text":"用vscode编译Java一直乱码，我还以为是vscode的问题(毕竟vscode的乱码挺多的)。用回了eclipse以后，发现乱换ide是个不好的习惯，那玩意怎么用啊！于是疯狂捣鼓vscode，终于弄好了Java连接数据库且不乱码了。 Java方面报错关于Java方面报错，有个很无语的地方，就是你用控制台输入中文，他会输出空格！一个很诡异的错误，不管怎么调编码格式都没用。找了很久最后看到一个大佬的做法。 第一步：首先在launch.json中关于该文件的地方加上$encoding: “GBK”,$之后你就会发现输入输出都不行了，这时候进行第二步！ 第二步：将launcher.bat文件修改一下，将@chcp.com 65001 &gt; NUL 修改成@chcp.com 936 &gt; NUL。个人建议在被修改语句前加个rem就好了，怕以后出问题，bat的注释符号。 第三步：再次尝试运行，你就会发现好了，输入中文也不会乱码。 MySQL数据库的编码格式看到这里大家都可能明白我强调Java数据库连接且不乱码了。我整了两天一直以为是因为他是gdk编码，怎么传怎么错，学了n久的编码与解码。。。秀的我头皮发麻就在刚才，我发现数据库的编码格式有点诡异。首先我们查看数据库的编码格式 show variables like ‘character_set_database’; 紧接着查看数据表的编码格式 show create table &lt;表名&gt;; 修改数据表的编码格式 alter database &lt;数据库名&gt; character set utf8; 创建表格时定义编码格式： create table tb_books ( name varchar(45) not null, price double not null, bookCount int not null, author varchar(45) not null ) default charset = utf8; 注意这里的编码格式要与$Java$传入参数的编码格式一样！不然会出现乱码，玄学乱码！杀手般的存在。 到了这里大家伙就会发现已经把问题解决的差不多啦。我解决了你们呢？ 关于vscode连接数据库的话，按照$eclipse$的教程其实也不会出多大问题，就是在加入外部包时把整个包放$lib$(没有的，可以自己建一个)文件进去后修改$.classpath$文件路径，增加该路径就差不多加入了。 更新4.20昨天发现按照上述导入后还是用不了，检查了各个地方都没有问题，最后发现在Java dependencies这里点击加号把这个包再导一次，就没事了。(白修一天bug，气煞我也)。 参考文章查看mysql数据库及表编码格式VSCode Java输出中文乱码问题解决导入jdbc外部包导入包 (按照博主说法，可以直接导入，我还没有尝试直接导入)。","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"kmp与exkmp","slug":"kmp与exkmp","date":"2020-04-03T11:41:54.000Z","updated":"2020-05-06T15:20:11.368Z","comments":true,"path":"2020/04/03/kmp与exkmp/","link":"","permalink":"https://www.dream-ak.top/2020/04/03/kmp%E4%B8%8Eexkmp/","excerpt":"思考良久，是时候拾起以前的字符串了，动态规划先放下吧，毕竟人笨，先把部分板子搞定！","text":"思考良久，是时候拾起以前的字符串了，动态规划先放下吧，毕竟人笨，先把部分板子搞定！ 复习kmp算法功能该算法一般用来做字符串匹配，比如在$A$串中寻找与$B$相同的子串。 算法思想朴素思想枚举$A$里面所有长度与$B$相同长度的字符串进行比较，每一个都枚举出来，有的话就一定匹配成功，就会有答案。 时间复杂度分析枚举所有子串，复杂度$O(N*M)$ kmp匹配思想把一个匹配分成两个阶段，我先介绍完两个阶段，最后解释两个阶段的含义以及用途 第一个阶段，对于$B$字符串我们首先对其单独进行一次处理，形成一个$next[]$数组，同时$next[i]$表示前$i-1$个字符的前缀与后缀的最长匹配。“前缀”指除了最后一个字符以外，一个字符串的全部头部组合；“后缀”指除了第一个字符以外，一个字符串的全部尾部组合。 利用朴素枚举匹配，查看在$A$串中以$i$开始的最长匹配长度$max$(也就是A中以$i$开始，$B$中以第1个字符开始，能够匹配的最长相同的字符)。当$max==lenB$($B$字符串的长度)时，那么就可以返回$i$，表示查找成功了。不相等时：那么下一次匹配时$A$的枚举位置就可以直接跳到$(i+len+1)$，$B$的枚举位置就要跳到$len+1$。因为这种情况下$A$串中$i~i+len$与$B$串中$1~len$所包含字符一模一样，就可以直接跳跃 时间复杂度分析：不会画图，在这里我直接给出答案$O(N)$，详细解答 实现第一阶段：继续定义一个$next$数组表示最长前缀与最长后缀的匹配长度，其中$next[i]$表示从第1个字符到第$i-1$个的最长匹配！这个我们对于这个$next$数组实现，用如下代码12345678910111213141516171819void GetNext(string B, int next[])&#123; int B_len = B.size(); int i = 0; // B 的下标 int j = -1; next[0] = -1; while (i &lt; B_len) &#123; if (j == -1 || B[i] == B[j]) &#123; i++; j++; next[i] = j;//相同，就可以更新next[i]了 &#125; else j = next[j];//将j跳转至以第j-1个字符的最长匹配值的位置。为什么可以跳转待会解释 &#125;&#125; 为什么那里是跳转？先看这个图注意这里变量与上面代码变量完全一致，也就是说假设$j$与$i$在如图所示位置，那么当$B[i]==B[j]$时，$next[i]$直接就是$j$了,因为$next[i-1]=j-1$，而$B[i]==B[j]$所以他直接等于$j$。当$B[i]!=B[j]$时，我们怎么办？看下图那么可以发现$next[j]$我们是处理好了的，且$next[j]$表示从$0 \\rightarrow j-1$的最长公共前后缀匹配长度，这里前面第一个椭圆表示$0 \\rightarrow j-1$的最长公共前缀，第二个最长公共后缀，他俩长一样的。对此我们往后看到$next[j]$要表示的值，也就是后面的两个椭圆与前面两个椭圆是什么关系？应该也要是一样的，理由：$0 \\rightarrow j-1$与 $i-j \\rightarrow i-1$是一样的($next[i-1]==j-1$且$a[i-1]==a[j-1]$)，进而得出这四个椭圆包含的字符串是一样的！所以为了求$next[i]$我们经过上面的关系转换，我们就可以不断的使用$next[j]$划分小椭圆来实现。 如果你理解了，我就再提一个问题！求$B$串的最小循环节怎么算？提示：与我这里的椭圆划分有关哦！不过从结论上看不出来。 第二阶段$A$串与$B$串开始匹配先上代码，上面那个都理解了，下面没什么好说的了12345678910111213141516171819202122232425int KMP(string A, string B, int next[])&#123; GetNext(B, next); int i = 0; // A 的下标 int j = 0; // B 的下标 int A_len = A.size(); int B_len = B.size(); while (i &lt; A_len &amp;&amp; B &lt; p_len) // 因为末尾 &apos;\\0&apos; 的存在，所以不会越界 &#123; if (j == -1 || A[i] == B[j]) // B 的第一个字符不匹配或 A[i] == B[j] &#123; i++; j++; &#125; else j = next[j]; // 当前字符匹配失败，跳转到B的最长前后匹配字串位置 &#125; if (j == B_len) // 匹配成功 return i - j; return -1;&#125; 乍一看以为一模一样，实际上呢？就是不需要更新$next$而已，而且这里的跳转也不是为了划分椭圆而是寻找上一次的最大前后缀匹配，并跳到那个位置。 扩展EXkmp算法这个坑有点大了。。。死在补题上。","categories":[{"name":"字符串","slug":"字符串","permalink":"https://www.dream-ak.top/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"lcs与lis","slug":"lcs与lis","date":"2020-03-29T14:06:16.000Z","updated":"2020-03-30T09:59:58.259Z","comments":true,"path":"2020/03/29/lcs与lis/","link":"","permalink":"https://www.dream-ak.top/2020/03/29/lcs%E4%B8%8Elis/","excerpt":"最近看到很多这种lcs与lis得题目，就来写一个关于这种题目的一个总结更新经我仔细思考，之前有以下漏洞： 二分法$lis$已经把树状数组所有功能全部重合，具体写法写到里面了。","text":"最近看到很多这种lcs与lis得题目，就来写一个关于这种题目的一个总结更新经我仔细思考，之前有以下漏洞： 二分法$lis$已经把树状数组所有功能全部重合，具体写法写到里面了。 最长上升子序列顾名思义，就是求最长上升子序列的最大长度，这样的求法一共有三种！分别介绍一下：$n^2$的$dp$写法定义$dp[i]$为从第$i$个数字结尾的上升子序列(该上升子序列一定以$a[i]$结尾)的长度。我们每一次枚举一个$j$，往前枚举$i$找到一个比$a[j]$小的最大的$dp[i]$，更新$dp[j]$。换句话说就是找到前面一个比当前值小且以他结尾的最长上升子序列。代码 12345678910111213int a[MAXN], d[MAXN];int dp() &#123; d[1] = 1; int ans = 1; for (int i = 2; i &lt;= n; i++) &#123; for (int j = 1; j &lt; i; j++) if (a[j] &lt; a[i]) &#123; d[i] = max(d[i], d[j] + 1); ans = max(ans, d[i]); &#125; &#125; return ans;&#125; 二分+贪心法思想对于一个序列，我们枚举一个值，考虑这个值如果在最长$LIS$里面，那么这个值的位置所在的地方是在哪？在前面比该值小的后面。也就是说，这样对于每一个数字，我们都可以知道，如果他在最长上升序列的位置，记录一下最大的位置就是最长长度！ 实现拿一个数组存储在最长上升子序列中第$i$个位置所能出现的最小值，后面不用更新。 举例 2 5 1 3 422 51 5//更新第一个位置的值，使其变小1 3//更新第二个位置的值，使其变小1 3 4 123456789for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, a + i);memset(dp, 0x1f, sizeof dp);//预处理为最大值mx = dp[0];for (int i = 0; i &lt; n; ++i) &#123; pos = lower_bound(dp, dp + n, a[i]) - dp;//找到大于等于a[i]的第一个值，然后把a[pos]变小。 dp[pos] = a[i];//注意此时的dp[1~pos]就是以a[i]结尾的最长上升子序列，树状数组。。。多余了&#125;ans = 0;while (dp[ans] != mx) ++ans; 复杂度$O(Nlog(N))$，该方法也可以$nlogn$求具体最大字串，具体实现可自己想。(提示：参照前向星写法) 树状数组写法不了解树状数组请参考可能好奇上面已经够了呀，干嘛还要这个写法呢？给出一点，他能求出具体的以a[i]结尾的最长上升子序列字符串。(二分法也行，不过已经写了，就不删除了，当思维扩展吧) 思想树状数组可以连续修改一个区间，以及查询一个区间。我们从第一个值开始枚举，每次按照贪心思想，把比他大的值全部更新为当前值！那么就可以得到以$a[i]$结尾的最大上升子序列的具体值了。 实现首先离散化，不懂点击，然后用树状数组查出比第$i$个值大的第一个值得位置，然后对该位置以及以后位置更新为当前值！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;#define REP(i, a, b) for(register int i = (a); i &lt; (b); i++)#define _for(i, a, b) for(register int i = (a); i &lt;= (b); i++)using namespace std;const int MAXN = 1e3 + 10;int a[MAXN], b[MAXN], n, m, ans; int dp[MAXN], f[MAXN];inline int lowbit(int x) &#123; return x &amp; (-x); &#125; void motify(int x, int p)&#123; for(; x &lt;= m; x += lowbit(x)) f[x] = max(f[x], p);&#125;int get_max(int x)&#123; int res = 0; for(; x; x -= lowbit(x)) res = max(res, f[x]); return res;&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); _for(i, 1, n) scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i]; sort(b + 1, b + n + 1); m = unique(b + 1, b + n + 1) - b - 1; _for(i, 1, n) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b; int ans = 0; _for(i, 1, n) &#123; dp[i] = get_max(a[i]) + 1;//查询大于等于a[i]得第一个位置 ans = max(ans, dp[i]);//最长上升子序列 motify(a[i], dp[i]); //把该位置往后得所有值全部更新 &#125; printf(&quot;%d\\n&quot;, ans); return 0;&#125; 这个大家可能不熟悉，写全了。(百度抄的，改成了这样子的) 最长公共子序列这里有两种解决办法 动态规划($n^2$)$dp[i][j]$表示从字符串a的前i个字符与字符串b的前j个字符串的最长公共子序列的长度。说到这里大家伙可能就都知道了，直接贴代码，代码里面解释。123456for(i=1;i&lt;=n+1;i++)&#123; for(j=1;j&lt;=m+1;j++)&#123; if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1]+1;//俩子序列结尾相同时为前面值加一 else dp[i][j]=max(dp[i][j-1],dp[i-1][j]);//不同时为这个。 &#125;&#125;这个路径可以利用转移方程按前向星思路保存路径 $LCS$转$LIS$使用条件，字串里面元素不得出现重复 思想我们按照第一个字串的顺序映射第一个字串元素在第二个子串中的位置(数组C)。那么$LCS$就转为$LIS$了。没看懂的话，我下面解释一下：第一个字串按顺序映射位置，那么当位置单调递增，也就是在第二个字串中按顺序排列的，那么这几个位置就会是最长公共子序列！ 举例假设两个字串 a 1 7 5 4 8 3 9b 1 4 3 5 6 2 8 9 映射后 a 1 7 5 4 8 3 9b 1 4 3 5 6 2 8 9c 1 0 4 2 0 0 7 8 C数组$LIS$得到答案和路径长度4，路径1 4 7 8到B里面就是 $1b[1] 5(b[4]) 8(b[7]) 9(b[8])$ 代码下面是二分法，树状数组请自己改编12345678for(i=1;i&lt;=n+1;i++) vis[a[i]]=i;for(i=1;i&lt;=m+1;i++) b[i]=vis[b[i]];for(i=1;i&lt;=m+1;i++) dp[i]=2e9;for(i=1;i&lt;=m+1;i++)&#123; tot = lower_bound(dp+1,dp+m+1,b[i])-dp; ans=max(ans,tot); dp[tot]=b[i];&#125; 练习题目导弹拦截LCS 参考资料树状数组得最长不下降子序列树状数组离散话oi-wiki","categories":[{"name":"动态规划","slug":"动态规划","permalink":"https://www.dream-ak.top/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"codeforces1307D","slug":"codeforces1307D","date":"2020-03-24T14:07:50.000Z","updated":"2020-03-25T09:02:16.814Z","comments":true,"path":"2020/03/24/codeforces1307D/","link":"","permalink":"https://www.dream-ak.top/2020/03/24/codeforces1307D/","excerpt":"不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。","text":"不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。 题目链接题目大意已知一个连通图，每条边b(无向边)长度都为一，给我们一些点，求在这些点里面任意取两点之间建一条边(长度为一)后，使得从1到n的最短距离最长！求该两点。说白了就是加一条边后形成最长最短路，问在哪里加。 思路对于这一题，毫无疑问我们先要求出该1到其他所有点的最短距离$dis1$，和n到其他所有点的最短距离$dis$。那么最短路一定是$ ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$枚举$a$与$b$找到最大的数字$ans$就好了，但是由于$a$的数字太多了，$O(n^2)$肯定不行，所以这就是该题的最难点，如何找到这个最大值！首先我们可以假设 dis1[a]+dis[b] \\leq dis1[b]+dis[a]推导发现 dis1[a]-dis[a] \\leq dis1[b]-dis[b]也就是说只要左边的差值小于等于右边的差值，那么:$ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$化简为$ans = dis1[a]+dis[b]+1$，可以发现首先对给我们的点按照$dis1[a]-dis[a]$从小到大排序后，开始从前往后枚举点，i为枚举的下标，$ans=max(x+dis[i]+1),x=max(x,dis1[x])$，$x$代表1到枚举过的点之间的最长距离。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include&lt;algorithm&gt;#include &lt;string.h&gt;#include&lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 4e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int p[N];int head[N],tot=0,a[N],vis[N],dis1[N],dis[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void dij(int x)&#123; memset(dis,0x3f,sizeof(dis)); priority_queue&lt;pair&lt;int,int&gt; &gt;q; dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(dis[v]&gt;dis[u]+1)&#123; dis[v]=dis[u]+1; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); for(i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;a[++t]); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; dij(1); for(i=1;i&lt;=n;i++) dis1[i]=dis[i]; //printf(&quot;%dss\\n&quot;,dis1[n]); memset(vis,0,sizeof vis); dij(n); int sum=2e9+9; vector&lt;pair&lt;int,int&gt; &gt; dat; for(i=1;i&lt;=t;i++)&#123; dat.push_back(make_pair(dis1[a[i]]-dis[a[i]],a[i])); &#125; sort(dat.begin(),dat.end()); int mm = -2e9+9,best=0; for(i=0;i&lt;t;i++)&#123; int x = dat[i].second; best = max(best,mm+dis[x]); mm = max(mm,dis1[x]); &#125; printf(&quot;%d\\n&quot;,min(best+1,dis1[n])); //system(&quot;pause&quot;); return 0;&#125; 参考资料cf题解","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"Java的biginteger","slug":"Java的biginteger","date":"2020-03-21T12:31:29.000Z","updated":"2020-03-25T10:11:04.059Z","comments":true,"path":"2020/03/21/Java的biginteger/","link":"","permalink":"https://www.dream-ak.top/2020/03/21/Java%E7%9A%84biginteger/","excerpt":"哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧","text":"哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧 1.赋值：1BigInteger a=new BigInteger(&quot;1&quot;); 1BigInteger b=BigInteger.valueOf(1); 2.运算：① add(); 大整数相加123BigInteger a=new BigInteger(“23”); BigInteger b=new BigInteger(“34”); a. add(b); ②subtract(); 相减③multiply(); 相乘④divide(); 相除取整⑤remainder(); 取余⑥pow(); a.pow(b)=a^b⑦gcd(); 最大公约数⑧abs(); 绝对值⑨negate(); 取反数⑩mod(); a.mod(b)=a%b=a.remainder(b); 3.BigInteger构造函数：一般用到以下两种：BigInteger(String val);将指定字符串转换为十进制表示形式；BigInteger(String val,int radix);将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger 4.基本常量：A=BigInteger.ONE 1B=BigInteger.TEN 10C=BigInteger.ZERO 0 n.compareTo(BigInteger.ZERO)==0 //相当于n==0 if(a[i].compareTo(n)&gt;=0 &amp;&amp;a[i].compareTo(m)&lt;=0) // a[i]&gt;=n &amp;&amp; a[i]&lt;=m 所有比较可以按照string比较规则来比较 参考资料biginteger","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"java对象复习","slug":"java对象复习","date":"2020-03-21T11:31:07.000Z","updated":"2020-03-21T12:49:44.059Z","comments":true,"path":"2020/03/21/java对象复习/","link":"","permalink":"https://www.dream-ak.top/2020/03/21/java%E5%AF%B9%E8%B1%A1%E5%A4%8D%E4%B9%A0/","excerpt":"完辽，没学习的欲望了，拖了几天的总结。","text":"完辽，没学习的欲望了，拖了几天的总结。 抽象类($abstract$)一个方法可以被覆写，那么如果当前类的全部方法都要被子类覆写的话，这个类我们就可以用抽象来代替。这个抽象的方法如果在它的子类里面不对该方法进行覆写的话，直接会报编译错误。那么抽象类的特点： 直接规范了子类的格式 抽象类无法实例化 子类的端口范围不能小于父类的端口范围 抽象方法不能用$private$修饰，因为抽象方法必须被子类重写，而$private$权限对于子类来说是不能访问的，所以就会产生矛盾。 抽象方法也不能用$static$修饰，如果用$static$修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。 抽象类不能被$final$修饰，因为被修饰以后就不能被继承了。 接口(interface)当一个抽象类里面没有字段，全是抽象方法时，我们可以将这个类定义为接口。也就是说，接口里面不得有任何字段，所有方法都必须是抽象方法。也因为都是抽象，所以自动省略了$public abstract$修饰语句对于一个接口来说，可以同时继承多个接口。当用一个具体的类实现一个接口必须要用implement，举例：123456789101112131415161718192021interface Person &#123; void run(); String getName();//自动省略public abstract&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; $default$方法接口之中可以定义$default$方法他的优点： 实现类里面可以不必覆写该方法，但是也可以覆写，方便修改接口。 举个例子12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(&quot;Xiao Ming&quot;); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; $static$静态字段对于一个类的静态字段来说，他在这个字段里面只有一个共享空间，所有的实例都是用这一个变量。举例来看12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); &#125;&#125;class Person &#123; public String name; public int age; public static int number; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;可以发现修改了一个实例里的静态字段以后另外一个实例里的也改变了。 静态方法对于一个类里面的静态方法，可以直接通过类名.方法名进行运行，但是不可以通过this.类名访问。 接口的静态字段因为$interface$是一个纯抽象类，所以它不能定义实例字段。但是，$interface$是可以有静态字段的，并且静态字段必须为$final$类型。也因为全是$final$所以我们可以省略。 静态代码块对于一个静态代码块来说，当我们调用该类的时候会自动将静态代码块运行一次，且仅运行一次。当往后运行时就不会再调用了。一般使用这个功能时我们一般都是用来初始化的。 参考资料abstract廖雪峰","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java多态","slug":"Java多态","date":"2020-03-17T08:20:29.000Z","updated":"2020-03-17T09:27:20.735Z","comments":true,"path":"2020/03/17/Java多态/","link":"","permalink":"https://www.dream-ak.top/2020/03/17/Java%E5%A4%9A%E6%80%81/","excerpt":"这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧","text":"这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧 多态覆写子类对于父类的方法进行的修改就叫覆写(Override)。覆写的方式是在子类中定义一个与父类方法名相同、返回值和参数一样的方法，就会变成覆写。1234## 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。**当一个子类向上转型为父类以后，那么如果父类中有方法被该子类覆写了，调用该方法是会动态调用子类中覆写的方法。**通过这个性质，对于同一个类的同一个方法就会出现不同的实现方式。例如以下代码：public class Main { public static void main(String[] args){ Preson p1 = new Student(); Preson p2 = new Teacher(); p1.speak(); p2.speak(); p1.speak(); }}public class Preson{ public int age=10; void speak() { System.out.println(“父类”); }}public class Student extends Preson{ @Override//覆写 void speak(){ System.out.println(“学生”); }}public class Teacher extends Preson{ @Override//覆写 void speak(){ System.out.println(“老师”); }}```同样都是Person类执行同一个方法输出却是： 学生老师学生 在被子类覆写的方法里面如果想要运行父类方法，可以使用super关键字 final如果不想当前方法不被覆写，可以在方法名前加上final修饰符，就不会被重写了。如果类不想被继承的话，用它就会绝育了。变量用它后就不能修改了。 参考廖雪峰的java教程","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java继承","slug":"Java继承","date":"2020-03-17T06:42:03.000Z","updated":"2020-03-25T11:29:29.708Z","comments":true,"path":"2020/03/17/Java继承/","link":"","permalink":"https://www.dream-ak.top/2020/03/17/Java%E7%BB%A7%E6%89%BF/","excerpt":"对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西","text":"对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西 Java继承$extends$继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让$Student$从$Person$继承时，$Student$就获得了$Person$的所有功能，我们只需要为$Student$编写新增的功能。继承的关键字是extends12345678910111213141516171819202122public class Preson&#123; public int age=10; void speak() &#123; System.out.println(age); &#125;&#125;public class Student extends Preson//继承Preson类&#123; public String meat; void eat(String x)&#123; System.out.println(x); &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; Student p = new Student(); p.age = 1; p.eat(&quot;Apple&quot;); p.speak(); &#125;&#125; 从以上代码可以看出，我们的$Student$类完全可以调用$Person$类的$speak()$方法，也可以自己写方法(譬如$eat()$方法)。在OOP的术语中，我们把$Person$称为超类（super class），父类（parent class），基类（base class），把$Student$称为子类（subclass），扩展类（extended class）。 继承树可以发现上面我们的代码$Person$类是没有$extends$的。不过要注意，他还是有父类，是$Object$类，在Java里面一切不定义extends的类都有一个Object父类但是Object没有父类。了解了这个以后我们来看一下继承树：Student \\rightarrow Preson \\rightarrow Object 注意：继承树的根是$Object$，上一个节点就是他的父类 $protected$继承一大特点：子类无法访问父类的$private$变量或$private$字段，这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把$private$改为$protected$。原因可参考。因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。 构造方法如果父类不含有默认构造方法，那么我们需要使用$super(参数)$去自行构建。含有默认构造方法的话，会自动在构造的时候加一个$super()$。 转型对于Java的继承时我们可以对一个引用变量进行转化。用代码解释一下12345678910Student p0 =new Student();Preson p1 = new Preson();p1 = p0;``` 你会发现他成功了，而且这里的p1会丢失Student类的所有方法和属性，这就是**向上转型(子类向父类转换)**，如果要恢复的话必须要**向下转型(父类向子类转换)**。子类向父类转化是没啥条件的，毕竟父类本身就有子类的部分属性和方法，只不过是更加抽象而已，但是向下转型是有条件的(向下转型时需要判断它是不是要转化的子类类型，不是就会报错)### $instanceof$为了防止向下转型失败，这里提供了$instanceof$关键字来判断是否可以转型。$instanceof$返回$Boolean$值，true代表是后面的类型，false反之。Student p1 = new Student();Preson p2 = new Preson();if(p2 instanceof Student){ p1 = (Student) p2;}```这样就不会报错，防止转型失败 对于一次向上转型来说，对于父类来说，他可以使用父类的所有属性和方法，而子类中定义的所有的方法和属性是没有办法的，但是当子类中对父类方法进行覆写时他就会调用子类覆写后的方法(动态连接)，否则就是调用父类自身方法。 参考廖雪峰的Java教程","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"二分匹配最大独立集","slug":"二分匹配最大独立集","date":"2020-03-12T11:04:03.000Z","updated":"2020-03-12T12:22:08.098Z","comments":true,"path":"2020/03/12/二分匹配最大独立集/","link":"","permalink":"https://www.dream-ak.top/2020/03/12/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/","excerpt":"最近不知为啥老想玩，干脆来打编程游戏算了。。。","text":"最近不知为啥老想玩，干脆来打编程游戏算了。。。 二分匹配图二分图 定义：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。 另一个等价定义：一个图里面不含有奇数条边的环。 匹配：一个匹配是一个边的集合，其中任意两条边都没有公共点。匹配边：一个匹配中，集合里的边是匹配边。匹配点：一个匹配中，集合里的所有点都是匹配点未匹配边：图里的非匹配边未匹配点：图里的非匹配点 最大匹配：一个图里面所有的匹配中，所含匹配边数最大的匹配。 完美匹配：当一个图里面所有点都是匹配点时就是完美匹配，显然一个完美匹配就是最大匹配， 举例来说：如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 匈牙利算法匈牙利算法：用来解决二分图最大匹配问题，时间复杂度$O(NM)$给与两个定义为匈牙利算法服务 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。 思想 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。 在这里我只写出了dfs版本的匈牙利算法 最大独立集(图里所有点-最大匹配点数)题目链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 5e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=0,vis[N],match[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;bool dfs(int x)&#123; vis[x]=1; for (int i = head[x]; ~i; i=ed[i].pre)&#123; int v =ed[i].id; if(!vis[v])&#123;//不在交替路 vis[v]=1;//放入交替路 if(match[v]==-1||dfs(match[v]))&#123;//短路操作，找到第一个非匹配点 match[v]=x;//对边进行交换。 match[x]=v; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; memset(match,-1,sizeof match); memset(head,-1,sizeof head); tot=0; for (i = 0; i &lt; n; i++)&#123; int u,v,t; scanf(&quot;%d: (%d)&quot;,&amp;u,&amp;t); for (j = 0; j &lt; t; j++)&#123; scanf(&quot;%d&quot;,&amp;v); add(u,v); &#125; &#125; int ans=0; for (int i = 0; i &lt; n; i++)&#123; if(match[i]==-1)&#123; memset(vis,0,sizeof (int)*n); if(dfs(i)) ans++; &#125; &#125; printf(&quot;%d\\n&quot;,n-ans); &#125;&#125; 补充定义最小覆盖数 ： 选取最少的点，使任意一条边至少有一个端点被选择最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。最大独立数(集)：选取最多的点，使任意所选两点均不相连。最大匹配数：最大匹配的匹配边的数目。 补充定理定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）&lt;/br&gt;定理2：点数 - 最大匹配数= 最大独立数&lt;/br&gt;定理3：最小路径覆盖数 = 顶点数 - 最大匹配数 参考资料 oi维基 二分图总结 最大匹配 第3个里面有bfs版本的匈牙利以及两个版本的速率比较，内容详细，带图。不过最后定理错了，定理参考第二个。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"scanner类","slug":"scanner类","date":"2020-03-11T12:38:08.000Z","updated":"2020-03-12T08:54:15.947Z","comments":true,"path":"2020/03/11/scanner类/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/scanner%E7%B1%BB/","excerpt":"在做实验时候真的尴尬，我居然把Java的输入法给忘了，我记性真的是狗啊，写一篇博客来记吧。","text":"在做实验时候真的尴尬，我居然把Java的输入法给忘了，我记性真的是狗啊，写一篇博客来记吧。 Scanner首先Scanner对象属于java.util.*包里面构造Scanner类对象，附属于System.in保准输入流里面。 创建Scanner类对象创建Scanner类对象和创建其他对象过程是一样的。1Scanner in = new Scanner(System.in);每一次要输入值的话就调用这个$in$对象就完事了 Scanner对象的方法 in.next()输入字符串，从读到第一个有效字符开始，无效字符结束(包括空格，回车) in.nextLine()输入字符串，从键盘输入第一个字符开始，遇到回车结束 in.nextInt()输入单个整型数字 in.nextFloat输入单个单精度浮点型数字 in.nextDouble输入单个双精度浮点型数字 in.nextLong输入单个长整型数字 in.nextBoolean输入单个布尔型变量 在以上方法前加单词has后可检查后面数字扫描器的下一个标记是否为指定模式例如 in.hasNextInt()则为判断下一个数字是不是int型，是则返回true，否则false； in.close()关闭扫描器 参考文档java的API文档","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"单调栈","slug":"单调栈","date":"2020-03-11T08:05:33.000Z","updated":"2020-03-11T09:35:35.443Z","comments":true,"path":"2020/03/11/单调栈/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！","text":"这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！ 单调栈不懂请点击上面链接学习，我就不介绍什么是单调栈了。 题目可以到上面链接提交测试。 题意 已知一个长度为n的数组，在其中找一个长度为m的子序列，规则如下：首先第一个数字尽量大，然后第二个数字尽量大，第三个数字也要尽量大，等等…. 思想和解法首先按照题意来，我们先求第一个尽量大的值，为了让他能找到m个数字，我们先求1~n-m+1的最大值，那么这个值就会是第一个值，第二个值就是在第一个值的位置到n-m+2的最大值，依次类推，求出所有。可以发现这是一个暴力解法，复杂度是$O(n^2)$ 优化我们利用单调栈实现一个单调不上升栈，那么第一个数就是当栈顶下标到n-m+1时的栈底值。把栈底退出(这个操作用数组模拟吧)，第二个数就是栈顶下标到n-m+2的栈底值，以此类推！ 解释一下：因为单调不上升，那么栈底一定最大，且栈内数字顺序没变！符合题意，当把栈底退出以后第二个值就是栈底的下标到n-m+1的最大值咯。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+5;int sta[N],a[N];int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int l = 0, r = 0; for(i=1;i&lt;=n-m;i++)&#123; while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--; sta[++r] = a[i]; &#125; for(i=n-m+1;i&lt;=n;i++)&#123; while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--; sta[++r] = a[i]; l++; printf(&quot;%d%c&quot;,sta[l],l==m?&apos;\\n&apos;:&apos; &apos;); &#125; &#125;&#125; 相同题型双倍快乐,单调栈的大于改小于就完事了，数据很大，卡O(nlogn)!.秃头快乐","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"Java修饰符","slug":"Java修饰符","date":"2020-03-11T03:03:45.000Z","updated":"2020-03-11T12:18:05.654Z","comments":true,"path":"2020/03/11/Java修饰符/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。","text":"听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。写在前面：本文来自对于这篇文章文章的理解 修饰符修饰符分为一下两种： 访问修饰符 非访问修饰符 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 修饰符 当前类 同一包 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N(解释请看) N default Y Y Y N N private Y N N N N 非访问控制修饰符static 静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final final 变量final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 实践部分：当定义final以后再对final变量修改值编译器会报错！ final 方法父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。 abstract抽象类 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 未完待续transient 修饰符volatile 修饰符synchronized 修饰符","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java对象","slug":"Java对象","date":"2020-03-11T02:11:29.000Z","updated":"2020-03-23T02:12:28.103Z","comments":true,"path":"2020/03/11/Java对象/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/Java%E5%AF%B9%E8%B1%A1/","excerpt":"听课","text":"听课 面向对象基础Java面向对象的基本组成 Java类及类的成员：属性、方法、构造器；代码块、内部类 面向对象三大特征：封装、继承、多态(抽象) 关键字：this、super、static、final、abstract、interface、package、import… 类和对象：类是对一类事物共同特点的统一，而对象就是类的实例。(就像水果和苹果一样)比如：手机需要充电，手机可以打电话，等等都是这个手机就是一个类，华为手机就是一个对象。 类的代码定义格式12345678910[修饰符] class 类名 [父类名] [implements 接口名] &#123; //类体,包括属性和方法 //属性 [修饰符] 数据类型 变量名 [ = 值] //方法 [修饰符] [返回值] 方法名([参数类型 参数名1]，[参数类型 参数名2]...)&#123; 方法体 return 返回值 &#125;&#125; 创建对象一个类不写构造方法时，类会默认一个public Preson()构造方法1类名 对象名 = new 类名(); 在创建对象实例时就把内部字段全部初始化为合适的值时我们需要自定义构造方法。 构造方法在创建类的时候我们同时定义一个方法，同时传入要定义的值，完成初始化123456789101112131415161718public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(18); Preson q = new Preson(28); p.speak(); q.speak(); &#125;&#125;class Preson&#123; //属性 private int age; public preson(int age)&#123; this.age = age; &#125; public void speak()&#123; System.out.println(this.age); &#125;&#125; 以上就可以自定义构造方法了，但是同时也会废弃默认的Preson p = new Preson()构造方法，想要保存的话，我们可以写两个构造方法。如下1类名 对象名 = new 类名(); 在创建对象实例时就把内部字段全部初始化为合适的值时我们需要自定义构造方法。 构造方法在创建类的时候我们同时定义一个方法，同时传入要定义的值，完成初始化123456789101112131415161718192021public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(18); Preson q = new Preson(); p.speak(); q.speak(); &#125;&#125;class Preson&#123; //属性 private int age = -18; public Preson(int age)&#123; this.age = age; &#125; public Preson()&#123; &#125; public void speak()&#123; System.out.println(this.age); &#125;&#125; 方法重载在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。就像如下代码1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(); Preson q = new Preson(); p.speak(18); q.speak(&quot;小明&quot;); p.speak(); &#125;&#125;class Preson&#123; //属性 public int age = 108; public String name; public void speak(int age)&#123; System.out.println(age); &#125; public void speak(String name)&#123; System.out.println(name); &#125; public void speak()&#123; System.out.println(age+name); &#125;&#125; speak方法名就出现了三次，只是各自的参数不同，这就叫方法重载。它存在的意义是让功能类似的方法名字相同，利于记忆，调用更简单。 对于一个变量来说，如果他定义在类里面会自动赋初值0，存储在堆里面，如果在方法体里面定义的话，必须手动赋值，且存储在栈里面","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"蓝桥杯校赛第九题","slug":"蓝桥杯校赛第九题","date":"2020-03-10T12:24:09.000Z","updated":"2020-03-10T13:00:42.768Z","comments":true,"path":"2020/03/10/蓝桥杯校赛第九题/","link":"","permalink":"https://www.dream-ak.top/2020/03/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B9%9D%E9%A2%98/","excerpt":"去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。","text":"去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。 题目是我凭记忆复现的，链接在这里第九题 思路：数据很小，所以第一想法直接把答案全部按照深度优先搜索跑出来，保存下来，然后再交，O(1)输出！深度优先搜索写法：因为每一个数字只与前两个数字有关，那么我们只要每计算一个答案就把这两个数字的答案记录下来，以后在遇到这两个数字就直接使用就好了。(可以学一下记忆化搜索) 实现使用vis二维数组来保存前两个数字，如果vis[x][y]为0的话就没有用过，为0直接就加上就好了12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdlib.h&gt;//#include&lt;windows.h&gt;using namespace std;const int N = 1005;int vis[N][N],a[N];FILE *fp1 = fopen(&quot;D://program//code//acm//oj//testin.txt&quot;,&quot;w+&quot;);FILE *fp2 = fopen(&quot;D://program//code//acm//oj//testout.txt&quot;,&quot;w+&quot;);int dfs(int x,int y)&#123; int ans=0;//求前面两个数字为能产生的数列数量 for(int i=1;i&lt;abs(y-x);i++)&#123; if(vis[y][i]==0)&#123;//没有用过则计算出答案并保存 vis[y][i]=dfs(y,i);//计算呢前前一个数字是i前面第二个数字是y的数列数。 ans=(ans+vis[y][i])%10000; &#125; else ans=(ans+vis[y][i])%10000; &#125; return ans+1;//返回数列值并加上当前值&#125;int main()&#123; int i,j,k,n,m; for(i=1;i&lt;=1000;i++)&#123;//计算以i开始的数列数量 int ans=0; for(j=1;j&lt;=i;j++)&#123; if(vis[i][j]==0)&#123; vis[i][j]=dfs(i,j); ans=(ans+vis[i][j])%10000; &#125; else&#123; ans=(ans+vis[i][j])%10000; &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; system(&quot;pause&quot;); return 0;&#125;上面时间复杂度为因为一个数字开始的话数量与前两个数字有关所以复杂度为O($n^2$)，n个数字是O($n^3$)打出所有答案后复制到另一个程序输出就好了。 AC代码12345678#include&lt;stdio.h&gt;int a[1006]=&#123;1,2,4,7,14,26,53,106,220,452,946,1967,4128,8638,8144,8068,26,8127,3542,3277,3278,7643,5433,5774,8217,4846,687,3097,6887,3556,4840,3454,5378,722,2230,767,1447,1839,4776,7618,7831,6222,5236,7802,5696,1835,1102,9537,1605,1227,3034,2159,1613,6811,3941,6794,5960,4903,75,2158,349,4258,5189,4717,2894,4193,2890,258,2928,6125,2913,1482,8419,7244,1652,3440,2138,9272,4714,3333,3543,8834,6763,9180,1803,4631,6307,9056,3170,8339,6213,1176,3258,272,4257,1893,8020,3682,9531,6961,4145,3086,3455,9057,1346,5768,6907,247,2450,4732,8653,8229,842,3346,9671,7106,3561,4952,9539,1791,6208,6083,8838,7474,6854,198,7300,8219,5912,8884,3976,9650,4821,7317,9720,5572,3834,6326,2281,34,8409,28,445,8155,9846,9944,2504,3954,1639,7243,8502,6926,1609,7449,3769,5695,6683,7531,6275,5827,6184,1982,736,9718,2777,7688,6626,7456,961,5556,7573,6886,4543,3957,2859,4666,9795,305,9052,5350,9827,5445,6970,2599,7566,2848,2987,5179,1537,2392,6375,9621,7376,3301,1357,6545,7838,9390,4284,2631,1814,2566,7666,1110,5694,7595,5000,1290,4735,5994,9401,6475,9012,5877,2867,7912,3509,5505,885,7490,5622,4374,8721,5134,8788,5430,3869,9852,5762,75,5964,262,5565,1599,7525,5388,8612,1143,7938,7580,2953,7901,5629,1456,9852,5216,965,3739,7879,1212,9029,9263,9609,1926,8151,1997,6298,5125,5715,4864,3852,604,7652,313,6248,4077,3875,3816,7046,9525,3798,6959,9366,2216,4463,6546,6367,614,9477,3176,4098,7162,7535,4696,749,2686,8212,9050,255,1389,287,1086,9414,9897,2293,31,9121,4682,7084,8951,834,1051,2236,3712,6426,8642,185,785,8162,6015,658,8923,5741,2551,7629,2095,8882,7695,5629,8684,5116,6362,7701,9441,9403,1108,4395,5688,9466,953,9191,4967,7236,6020,3465,8165,872,4530,3353,7859,1422,1504,6366,126,1246,1530,1777,8970,4590,2195,6920,9086,689,2163,6035,4961,2055,7699,4121,3971,1824,3707,4405,854,6088,6971,1679,1779,7097,5696,2449,2104,3264,796,8595,6183,26,5597,7295,5926,9039,4550,9601,5959,3244,7451,5641,2343,6587,3755,4361,3890,446,8187,1979,7000,7094,8658,1647,6090,8332,4407,4570,2340,3057,5029,5424,2736,4844,2771,5782,5912,3745,2504,2782,7247,1393,5403,7175,9903,1723,7600,7021,4566,9778,5188,46,8542,7915,5043,4983,519,480,8199,1141,73,9316,6248,966,3218,6614,6974,5078,9775,7263,6263,7267,1947,5357,286,674,3876,1985,4731,1850,512,1493,5310,5443,4183,5963,8642,1389,6320,4264,9565,7348,4378,6192,1300,3393,4794,8323,6063,9651,9368,7899,9053,4933,5140,5604,9114,9299,7603,2485,884,7313,4139,9883,1405,9843,7419,1483,2031,8610,4150,3313,6257,3790,1688,994,1357,9660,583,5735,1548,7156,9678,8047,3617,9611,7966,7764,5177,7716,4206,7985,6989,6318,5854,8292,9639,687,370,3252,7104,5813,758,8219,3809,2506,3605,9340,3559,4118,4757,8229,4258,944,1596,4940,622,5832,1270,6948,1744,1125,7895,9348,7601,7426,1975,9611,3722,4143,4979,7904,3221,3817,5755,1798,6549,3463,3190,201,6894,6209,3488,670,7643,7020,6164,5583,5036,6309,8644,7961,3465,7795,1486,4535,3111,5252,4049,4253,7515,1517,6148,2438,1296,8826,7924,7761,9126,6951,7110,7549,1170,8533,793,1633,6451,6261,5887,8694,6447,8993,6398,1289,2925,2362,3935,6744,1358,1743,3937,9942,3696,1601,8295,3086,2595,9554,8566,1465,2109,3474,3950,9216,8948,2020,3536,943,4934,8377,6171,1243,3525,259,3001,4205,4548,4754,2365,8630,4690,7872,5131,3995,2672,728,6532,9785,9379,5865,4774,6660,3721,4451,9085,4771,8008,857,9737,5630,4040,3106,5997,4152,8542,3992,3294,5064,2656,5247,635,1521,3026,1502,9396,2171,7188,2425,9758,2640,8648,9454,274,9471,8972,9301,911,6023,4155,126,7802,2948,5675,6313,69,1374,9925,3685,6901,432,1884,4803,8173,9638,3626,695,4286,3836,8670,8834,1444,5187,6281,2482,8801,7656,9066,5138,5160,9857,906,5235,7243,5281,5103,5826,5023,3637,5607,1204,5697,3422,1192,8753,6087,2083,3256,8201,9853,1886,3953,4732,7351,6387,9148,2299,4843,3891,3572,874,9873,1235,7323,8860,3439,113,5132,6521,1234,7427,4062,1342,2480,641,8802,9788,5336,3649,1301,3268,749,1628,9202,2689,3284,9170,5252,1577,1705,5640,2185,2252,4943,271,5117,8699,2743,8221,2119,3851,701,2740,4247,7037,9764,4445,5848,6135,6166,5328,2584,1131,3005,8817,2783,7749,6112,5567,9688,2549,7929,8650,60,1896,3998,7345,3352,8990,1143,873,1191,5821,9485,5249,3086,8016,9319,4139,3566,8871,7528,7873,4117,1085,7064,8222,5947,4447,1326,5206,12,9703,5711,3951,219,6966,3168,2372,9603,9092,1904,1010,2704,2106,7568,3410,296,6825,9781,637,4465,7953,6861,2142,2035,9743,1921,3051,7424,7112,7676,5245,9531,2284,4498,6423,6977,3106,1367,5696,2003,1291,3025,76,3147,9094,4580,5097,7390,8637,5853,359,3153,4957,6635,5721,3353,2266,3481,7432,3020,7330,1172,5285,1525,2928,5331,8856,2163,5169,1465,4439,1876,7446,2192,5577,726,6599,352,3645,7733,8331,5447,8017,5017,7287,6602,7248,6323,4195,9617,2263,4013,450,4073,6131,3569,9019,1858,9827,8118,4972,7422,9666,5760,9213,2817,7952,3948,8683,3645,6402,3264,1919,9276,2519,190,766,8940,3413,2644,8048,83,9724,7009,3777,9663,2483,5752,4578,8951,5902,2170,9967,894,8556,6049,7254,2746,8962,8317,6848,767,7907,1028,9458,6881,4978,6717,8210,3835,1064,7434,746,9449&#125;;int main()&#123; int x; while(scanf(&quot;%d&quot;,&amp;x)==1)&#123; printf(&quot;%d\\n&quot;,a[x-1]); &#125;&#125; 我的小结emmmm，手机浸水，一边比赛一边晾手机果然写出bug了，第7题血亏！还是不能飘啊。","categories":[{"name":"思维","slug":"思维","permalink":"https://www.dream-ak.top/categories/%E6%80%9D%E7%BB%B4/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"数据库操作","slug":"数据库操作","date":"2020-03-10T01:35:16.000Z","updated":"2020-04-10T15:07:52.782Z","comments":true,"path":"2020/03/10/数据库操作/","link":"","permalink":"https://www.dream-ak.top/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令","text":"最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令 数据库常用命令连接MySQL mysql -h 主机地址 -u 用户名 -p 用户密码如果是本地登录则不需要-h的主机地址如下是Linux服务器打开方式，本地登录没有hwindows打开方式：先要进入如图这个目录，不进入的话该命令会无效的，我就不细说，大家应该都是一个目录里面。退出MySQL输入exit然后回车就完事了修改密码退出MySQL以后在同一个目录使用如下命令 mysqladmin -u root -p密码 password-p密码那里是连起来的，直接回车如图操作命令首先写在前面： 对于一个数据库操作命令都是以一个英文分号”;”结束。 如果你输入命令错误，可以选择先输入一个分号，让他执行错误命令，重新输入。 库的命令 命令 含义 create database name 创建数据库 use database name 选择数据库 show databases 显示所有数据库 drop database name 直接删除数据库，不提醒 具体操作如下： 数据类型这个由于太多我只做简单常用介绍，如想详细了解，点击。 类型 字节长度 含义 int 4字节 整数 bigint 8字节 整数 double 8字节 双精度浮点型 date 3字节 日期值(格式：YYYY:MM:DD) time 3字节 时间值(HH:MM:SS) year 1字节 年份值(YYYY) datetime 8 混合日期和时间值(YYYY:MM::DD HH:MM:SS) char 0-255字节 定长字符串 varchar 0-65535字节 变长字符串 表的命令 命令 含义 create table name(变量 数据类型) 创建表 drop table name 删除表 show tables 查看当前选定数据库包含的表格 数据添加1insert into 表名 (字段1，字段2，...) value (值1，值2，...) 数据修改1update 表名 set (字段1 = 值，字段2 = 值，...) where ... 数据删除1delete from 表名 where ... 数据查询1select * from 表名 where ... 解释一下，这一句，其中的$*$是通配符，它会显示所有列，如果只要显示部分列的话，可以将其改为需要的列名。 $where$语句$where$语句类似于C语言的$if$具有判断功能，其中的逻辑符号如下 符号 意义 not 非 or 或 and 且 语句执行的优先级(无括号)：$not&gt;and&gt;or$同时除了一般的大于、小于、等于的判断语句外增加了一个like语句，可以判断相似。 对表属性的修改下面列表表示对表$person$(其中含有$name$,$age$两个属性) 语法 含义 alter table person drop age 删除$age$列 alter table person add column id varchar(20) not null primary key 增加一个$id$列，字符长度上限为20，非空，且为主键 alter table person alter column age set default 0 将$age$列默认为0 alter table person alter column age drop default 删除$age$列的默认值 介绍两个动态修改属性的关键字 modify用法如下 12ALTER TABLE tbl_nameMODIFY 字段名称 字段类型 [字段属性] [FIRST | AFTER 字段名称] change用法如下 12ALTER TABLE tbl_nameCHANGE 原字段 新字段名称 字段类型 字段属性 [FIRST|AFTER 字段名称] 可以发现后面一个能改字段名称。 参考文章动态修改属性自增长列的设置，回答了非主键可不可以设置子增长列，以及限制。菜鸟驿站","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.dream-ak.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"python文件操作","slug":"python文件操作","date":"2020-03-06T01:41:54.000Z","updated":"2020-03-21T12:46:06.811Z","comments":true,"path":"2020/03/06/python文件操作/","link":"","permalink":"https://www.dream-ak.top/2020/03/06/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。","text":"最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。 文件的一些函数 函数 参数 功能 os.getcwd() 无参数 返回当前工作目录 os.chdir() 地址 修改当前工作目录到指定文件地址 os.listdir() 地址 查看当前目录下所有文件 os.makedirs() 新建文件夹名称 新建文件夹 os.remove(path) 路径 删除文件 os.rmdir(path) 路径 删除空目录，非空目录报错 os.path.join() 要添加的文件路径(字符串) 构建一个在所有系统都能运行的文件路径 os.path.abspath() 路径(可以为相对路径’..’，’.’) 返回绝对路径 os.path.relpath(path,start) start：一个路径，path：路径 返回从start到path的相对路径，没有start参数时默认当前工作目录 os.path.dirname() 路径 返回最后一个斜杠以前的所有字符串 os.path.basename() 路径 返回最后一个斜杠以后的字符串 os.path.getsize(path) 路径 返回该路径下指定文件的字节数 os.path.exists(path) 路径 返回bool值表示路径是否存在 os.path.isdir(path) 路径 返回bool值表示路径是否存在且为目录 os.path.isfile(path) 路径 返回bool值表示路径是否存在且为文件 os.path.rename(str1,str2) 俩路径 重命名str1文件位str2文件 f = open(path,x) 文件路径,x为赋予权限 打开文件，且f为文件引用 f.read() 无参数 返回一个字符串表示文件内容 f.readline 无参数 返回一个list表示文件每一行 f.close 无参数 关闭文件 作死之旅这是我对于py做的第一个小脚本，使用了类与对象，各种文件操作，学习了一波迭代器，生成器，和异常处理，差不多是对于py的一次小应用了。 对于这个脚本的话我这里功能是： 能删除指定后缀文件，只要后缀相同一定删除，无情^-^ 能像linux一样操作但是操作指令不同，支持绝对路径与相对路径的输入 可以随时查看当前目录的文件 随时退出 解决方案： 递归遍历判断是否为目录 用os.path.abspath把相对路径转成绝对路径 os.listdir break 总结：我感觉这个删除脚本十分好用，反正我喜欢，还增加了我对于异常处理的能力，其实是学习了一下，对于迭代器的使用，（一开始不想要递归，毕竟它代价有点大，就学了一下，发现我用不上，菜了）对于文件命令的操作，字符串的处理方式也得到了锻炼，对于py的脚本以后就要开始写其他的了（例如excel操作） 代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osclass Flie(object): def list(self): print(&quot;当前工作目录：&quot;+os.getcwd()) file = os.listdir(os.getcwd()) print(&apos;\\n&apos;.join(file)) pass def goto(self, path): os.chdir(path) pass def pathname(self,name): print(&quot;请输入你将要进入的文件目录&quot;) names = name.split(&quot;\\\\&quot;) x = &apos;\\\\&apos;.join(names) pathnames = os.path.join(x) if os.path.isdir(pathnames): return pathnames pass else : print(&quot;不存在该目录，请重新尝试^-^&quot;) pass def erease(self, pathnam,format): #os.chdir(pathname) pathname=os.path.abspath(pathnam) for i in os.listdir(pathname): print(pathname) pathname1 = os.path.join(pathname,i) if os.path.isdir(pathname1): self.erease(pathname1,format) else: file1 = i.split(&apos;.&apos;) if file1[-1]==format: try: os.remove(pathname1) except FileNotFoundError as identifier: print(&quot;当前错误删除路径&quot;+os.path.join(os.getcwd(),pathname1))if __name__ == &quot;__main__&quot;: print(&quot;准备完毕，请输入：&quot;) os.chdir(&apos;C:\\\\&apos;) print(os.getcwd()) x = Flie() flag = True while flag: operate = input().split() op = operate[0] if op == &quot;goto&quot;: name = x.pathname(str(operate[1])) try: x.goto(name) except TypeError as identifier: continue elif op == &quot;del&quot;: name = x.pathname(str(operate[1])) print(os.path.getsize(name)) x.erease(name,operate[2]) pass elif op == &quot;cls&quot;: os.system(&apos;cls&apos;) print(&quot;当前文件位置：&quot;+os.getcwd()) elif op == &quot;list&quot;: x.list() elif op == &quot;help&quot;: print(&quot;goto + path：表示进入路径&quot;) print(&quot;del + path + str：表示删除该路径下某个特定的文件后缀&quot;) print(&quot;cls：清屏&quot;) print(&quot;list：打印整个目录下文件&quot;) print(&quot;quit：程序退出&quot;) elif op == &quot;quit&quot;: break else : print(&quot;输入格式错误，请输入正确格式或输入help寻求帮助&quot;) pass 有漏洞可以提出来，我已经成功的删除了我刷题时产生的所有exe文件了，嘿嘿嘿。有个缺陷是有可能进不了文件而报错，我是没有去弄这个异常的，有大佬经过时可否提点我一下？","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"最短路径图","slug":"1320B","date":"2020-03-04T10:46:38.000Z","updated":"2020-03-04T14:22:30.815Z","comments":true,"path":"2020/03/04/1320B/","link":"","permalink":"https://www.dream-ak.top/2020/03/04/1320B/","excerpt":"题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！","text":"题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！ 题目链接思路和解法 首先其余点到达定点的最短路怎么求:我们直接反向建图，求定点到每个点的最短路就是该点到达定点的最短路。最短路径保存我给一个思想类似于求最短路的条数的板子，直接套上最短路条数板子，把记录最短路条数的数组改为记录这一个点的上一个点(原图的下一个节点)就好了。 如果不会最短路条数的板子，看这里 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N],ed1[N];int head[N],tot,a[N],vis[N],flag[N],dis[N],head1[N],tot1;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=1; head[u]=tot;&#125;void add1(int u,int v)&#123; ed1[++tot1].pre=head1[u]; ed1[tot1].id=v; head1[u]=tot1;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij(int x)&#123; memset(dis,0x3f,sizeof dis); dis[x]=0; q.push(make_pair(0,x)); while(q.size())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; int i; for(i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].id,w=1; if(dis[v]&gt;dis[u]+1)&#123; head1[v]=-1;//清空该节点的下一个节点 add1(v,u);//建最短路图 dis[v]=dis[u]+1; q.push(make_pair(-dis[v],v)); &#125; else if(dis[v]==dis[u]+1) add1(v,u);//建最短路图 &#125; &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; int u,v; memset(head,-1,sizeof head); memset(head1,-1,sizeof head1); memset(vis,0,sizeof vis); tot=1; tot1=1; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(v,u); &#125; int len; scanf(&quot;%d&quot;,&amp;len); for(i=1;i&lt;=len;i++) scanf(&quot;%d&quot;,&amp;a[i]); dij(a[len]); int mi=0,ma=0; for(i=1;i&lt;len;i++)&#123; int flag1=1; mi++; for(j=head1[a[i]];~j;j=ed1[j].pre)&#123; //printf(&quot;%dvvvv\\n&quot;,ed[j].id); if(ed1[j].id==a[i+1]) mi--; else if(flag1) ma++,flag1=0; &#125; &#125;//统计答案 printf(&quot;%d %d\\n&quot;,mi,ma); &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"交互1305D","slug":"1305D","date":"2020-03-04T10:41:03.000Z","updated":"2020-03-04T14:22:27.833Z","comments":true,"path":"2020/03/04/1305D/","link":"","permalink":"https://www.dream-ak.top/2020/03/04/1305D/","excerpt":"第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！","text":"第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！ 题目链接思想和题解正解：每一次提问叶子节点，求出它们的LCA(w)。 如果w == u或者w == v，则w为树的根。因为相等的话，那么证明两个点在同一条路径上面，且两点的度都为1，而$u \\rightarrow v$ 本身就要消耗一个度，所以w是没有父节点的，w直接为根节点。 不相等则把该点从图上删掉且把该点的父节点的度减一不相等，证明两点不在同一路径，那么他们存在祖先节点，则这两点删掉(不是根留他何用)然后父节点度减一原因是因为他的一个子节点删掉了，父节点度肯定减一呗。 上面的度可以理解为可能为根节点的父节点个数(仅限此题可以这样理解，具体情况，具体分析) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot,w;void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;int vis[N];//表示可能为根节点的父节点个数，直接说是度了。void dfs(int x)&#123; // printf(&quot;%d\\n&quot;,head[x]); for(int i=head[x];i;i=ed[i].pre)&#123; vis[ed[i].id]--; &#125;&#125;int main()&#123; int t,n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; for(i=1;i&lt;n;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); vis[u]++,vis[v]++; &#125; int u=0,v=0; for(j=1;j&lt;=n/2;j++)&#123; //printf(&quot;%d\\n&quot;,j); for(i=1;i&lt;=n;i++)&#123; if(vis[i]==1&amp;&amp;u==0)&#123; u=i; &#125; else if(vis[i]==1)&#123; v=i; break; &#125; &#125; printf(&quot;? %d %d\\n&quot;,u,v); fflush(stdout); scanf(&quot;%d&quot;,&amp;w); if(w==u||w==v)&#123; printf(&quot;! %d\\n&quot;,w); fflush(stdout); return 0; &#125; else&#123; vis[u]=-1,vis[v]=-1;//-1表示删除该点 dfs(u); dfs(v); u=0; &#125; &#125; for(i=1;i&lt;=n;i++)&#123; if(vis[i]&gt;=0)&#123; printf(&quot;! %d\\n&quot;,i); fflush(stdout); &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"求等差数列的值","slug":"求等差数列的值","date":"2020-03-02T12:09:21.000Z","updated":"2020-03-02T12:31:39.413Z","comments":true,"path":"2020/03/02/求等差数列的值/","link":"","permalink":"https://www.dream-ak.top/2020/03/02/%E6%B1%82%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E7%9A%84%E5%80%BC/","excerpt":"在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值","text":"在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值 题目链接对于这个题目的限制来看，他成功的把迭代方法给禁了！ 解决方案利用公差为1和短路的原理递归答案递归的话，很容易想，唯独就是不允许if来特判结束条件，在这里我们可以看到，最后一个值是0，那么我们就可以发现， 如果为0的话，返回0，不是0的话就继续递归 那么我们就可以看到我们可以用短路，把后面不是0的部分用短路解决！如果前面是0则短路后面部分，让它不运行。否则就运行123class Solution: def sumNums(self, n: int) -&gt; int: return n and n+self.sumNums(n-1)由于if 和while被禁了。。。快速加无法实现，pow函数与**不知道实现方法就不写了（如果里面有乘法或除法就丢脸了）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/tags/leetcode/"}]},{"title":"java程序基础","slug":"java","date":"2020-03-02T02:28:49.000Z","updated":"2020-03-22T04:41:12.413Z","comments":true,"path":"2020/03/02/java/","link":"","permalink":"https://www.dream-ak.top/2020/03/02/java/","excerpt":"突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。","text":"突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。 Java程序基础基本单位:Class首先对于Java来说他的基本单位是$Class$而不像C语言基本单位是函数！对于每一个类他的定义一般是：123456789public class Hello&#123; public static void main()&#123;//方法名是main() system.out.println()//system.out.print+line整行输出的意思 //单行注释 /* 多行注释 */ &#125;&#125;这里的public是访问修饰符，表示Class公开 Class的命名规则Class的命名规则与py的Class一样，使用大驼峰规则： HelloNoteBookVRPlayer 方法的命名规则方法名命名规则是小驼峰： maingoodMorningplayVR 变量 直接与C语言相比，Java的int没有变化，long long变成long，用法不变 java整数运算没有误差，与C语言没有什么变化 java浮点数运算有误差，在比较的时候需要表示在一个容错值之中！ java布尔运算的变量名为boolean，且逻辑运算和三元运算符也有相同用法 java字符中和C语言字符差不多，但是由于用的Unicode编码，所以空间占两个字节，显示Unicode编码直接将char放到int就好了，由编码转Unicode编码则加上’\\u’ java字符串中和py的string用法相似，都是不可变变量且多行输出用法一样system.out.print(“””…”””); java数组操作，对于定义一个int[] ns= new int[5]；这样就是定义一个ns数组，可以用ns.length获取数组长度 数组操作遍历 从数组下标从0到lenth-1挨个访问 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int i=0; i&lt;ns.length; i++) &#123; int n = ns[i]; System.out.println(n); &#125; &#125;&#125; 用for each迭代答案 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 排序Arrays.sort(数组名称)按升序排序 命令行参数对于java来说，以main函数为程序入口，main(string[] args)这里的string[]是传入命令行参数的入口来看代码12345678910public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; if (&quot;-version&quot;.equals(arg)) &#123; System.out.println(&quot;v 1.0&quot;); break; &#125; &#125; &#125;&#125; 操作方法：首先我们先编译 javac 待编译文件 java 文件名 传入参数","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"两数相加","slug":"两数相加","date":"2020-03-01T03:43:51.000Z","updated":"2020-03-02T03:48:34.320Z","comments":true,"path":"2020/03/01/两数相加/","link":"","permalink":"https://www.dream-ak.top/2020/03/01/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！","text":"第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！对于这一题，说实在的没有啥算法可言，就是暴力模拟，我第一次了解py的链表，感觉还是值得一刷，就写了一下，解法就过了，没说的，竖式相加，逢十进位123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.定义单链表的意思# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: key=0 pre = ListNode(0) ans = pre while l1!=None and l2!=None: x = ((l1.val+l2.val+key)%10) cur = ListNode(x) pre.next=cur pre=cur key = (l1.val+l2.val+key)//10 l1,l2=l1.next,l2.next while(l1!=None): x = ((l1.val+key)%10) key = (l1.val+key)//10 cur = ListNode(x) pre.next=cur pre=cur l1=l1.next while(l2!=None): x = ((l2.val+key)%10) key = (l2.val+key)//10 cur = ListNode(x) pre.next=cur pre=cur l2=l2.next if key!=0: cur = ListNode(key) pre.next=cur return ans.next","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/tags/leetcode/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-02-29T14:22:23.000Z","updated":"2020-03-26T09:19:37.536Z","comments":true,"path":"2020/02/29/两数之和/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"leetcode计划开始了，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。","text":"leetcode计划开始了，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。 第一题：两数之和题意：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。对于这个题目，因为简单，所以这里提供的解法有如下几种 暴力$O(n*n)$每一次枚举一个i然后从i开始往后找另一个值与之相加为x的数字，找到则直接返回下标。 字典映射对于每一个数字由于只有两个$(x,y)$数字，那么我们假设其中一个数字为$x$，则另一个数字一定是$target-x$通过这个特性，我们可以选择建立一个dict{x:i},x为差值，i为下标，我们每一次假设一个x时则查看前面是否出现过target-x，出现了直接返回就好了，没出现则加入字典。时间复杂度$O(n)$,特别注意，py字典是哈希映射的，不是字典树。32ms12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: num=&#123;&#125; pos=0 for i in nums: x = target - i if num.get(x,-1)!=-1: return [num[x],pos] num[i]=pos pos+=1 二分建立一个$list$存储大小与下标，然后对大小从小到大排序，接下来用二分查找向后查找$target-x$时间复杂度$n*log_2 n$54ms123456789101112131415161718class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: lenth=len(nums) a=[[nums[pos],pos] for pos in range(0,lenth,1)] b = sorted(a,key=lambda x: x[0]) for i in range(0,lenth,1): x = target-b[i][0] l , r = i+1,len(b)-1 while(l&lt;r): mid=(l+r)//2 if b[mid][0]&gt;=x: r=mid elif b[mid][0]&lt;x: l=mid+1 if b[l][0]==x: x = [b[i][1],b[l][1]] y=sorted(x) return y 自我总结对于这一题，我的个人总结是用python实现了一次二分同时学会了排序sorted函数带三个参数： 要排序数组 排序方式，是一个函数写法key=一个函数，这里是lambda x:x[0]按照第一个值排序 reverse反转，让她从小到大与从大到小之间变化","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/categories/leetcode/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"最短路和次短路的数量","slug":"最短路和次短路的数量","date":"2020-02-29T09:54:30.000Z","updated":"2020-03-02T04:40:41.801Z","comments":true,"path":"2020/02/29/最短路和次短路的数量/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"题目链接题意：给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少","text":"题目链接题意：给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少 思想和解法首先看到这个题目，我们第一时间就会想到最短路径数量，直接就暴力跑迪杰斯特拉然后统计一下就完事了，最多加个次短路而已，我们就按照次短路生成的方式，跑迪杰斯特拉，然后记录到达每个点的最短路数量和次短路数量。 优化最短路时就把当前次短路的数量赋值给最短路， 通过次短路优化次短路时就把前一个点的次短路数量赋值给下一个点的数量 操作想法很简单，但是这题如果大量使用空间则会爆优先队列，因此我们要注意对优先队列进行节省空间，对于每一个点能让它少入队，则少让他入队。把优化最短路时最短路和次短路的这两次入队归为一次，就会节省很多空间！所以写法再次修改为如下，分为4个步骤： 优化最短路 等于最短路 优化次短路 等于次短路代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],dis[N],dis2[N],tot=0,num1[N],num2[N];void init()&#123; memset(head,-1,sizeof head); memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); memset(num1,0,sizeof num1); memset(num2,0,sizeof num2); tot=2;&#125;void add(int u,int v,int w)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij(int x)&#123; dis[x]=0; num1[x]=1; q.push(make_pair(0,x)); while(q.size())&#123; int x=q.top().second,w = -q.top().first; //printf(&quot;%d %d\\n&quot;,x,w); q.pop(); int cnt; if(w&gt;dis2[x]) continue; if(w == dis[x]) cnt=num1[x]; else if(w==dis2[x]) cnt=num2[x]; for(int i=head[x];~i;i=ed[i].pre)&#123; int v = ed[i].id,s=ed[i].w; int cost = w + s,d=cnt; if(dis[v]&gt;cost)&#123; dis2[v]=dis[v]; num2[v]=num1[v]; dis[v]=cost; num1[v]=d; //swap(dis[v],cost); //swap(d,num1[v]); q.push(make_pair(-dis[v],v)); //printf(&quot;%d %d sss\\n&quot;,v,num1[v]); &#125; else if(dis[v]==cost)&#123; num1[v]+=d; &#125; else if(dis2[v]==cost)&#123; num2[v]+=d; &#125; else if(dis2[v]&gt;cost)&#123; dis2[v]=cost; num2[v]=d; q.push(make_pair(-cost,v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; int p,q; scanf(&quot;%d %d&quot;,&amp;p,&amp;q); dij(p); int ans=num1[q]; if(dis[q]==dis2[q]-1) ans+=num2[q]; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj3694-tarjan","slug":"poj3694-tarjan","date":"2020-02-29T09:28:47.000Z","updated":"2020-03-02T03:55:29.435Z","comments":true,"path":"2020/02/29/poj3694-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj3694-tarjan/","excerpt":"题目链接题意给一个连通图，问每一次加边以后还有多少条桥！","text":"题目链接题意给一个连通图，问每一次加边以后还有多少条桥！ 思想和解法很明显把连通图缩点成$DAG$图，(对DAG图操作)然后每一次加边后$DAG$图里强连通分量继续缩点！桥的数量就是加边前的数量减去缩掉的边的数量。 操作问题1：缩点想法很简单，操作异想天开，如果用染色法对图进行缩点，最坏情况就是一棵N个结点的树，N-1条边每一次添加一条邻边，复杂度卡到$(1+n)* \\frac{n}{2}$。所以采用并查集动态缩点！ 问题2：路径路径寻找也是一个问题，我们已经$tarjan$缩过一次点了，我们接下来是新建一个图继续跑$tarjan$离线$LCA$吗？注意对于tarjan的LCA算法精髓在于哪里？他那么写的原因是经过了tarjan算法以后每个节点其实都有一个时间戳！而两个点$$之间的$LCA$他们有一个共同的特点，那就是: $LCA$的左子树上的所有点的时间戳都小于右子树的时间戳！ 根据这个特点我们可以直接用记录当前点的父节点然后爬到$LCA$上去。看下代码123456789101112void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--;//缩点成功则桥减一 x=get(pre[x]);//爬向缩点后的父节点 &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--;//缩点成功则桥减一 y=get(pre[y]);//爬向缩点后的父节点 &#125;&#125; 代码282ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 5e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],pre[N],fa[N],dfn[N],low[N],sta[N];int tot=0,edge=0,tim=0;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int vis[N];int get(int x)&#123; if(fa[x]!=x) return fa[x]=get(fa[x]); else return x;&#125;bool join(int x,int y)&#123; int p=get(x),q=get(y); if(p!=q)&#123; fa[p]=q;//指向父节点 return true; &#125; return false;&#125;int num=1;void tarjan(int x,int fath)&#123; low[x]=dfn[x]=++tim; vis[x]=1; int flag=1; for(int i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(v==fath&amp;&amp;flag) &#123;flag=0;continue;&#125; if(!vis[v])&#123; pre[v]=x; tarjan(v,x); low[x]=min(low[v],low[x]); if(low[v]&gt;dfn[x])&#123; edge++; &#125; else&#123; join(v,x); &#125; &#125; else&#123; low[x]=min(low[x],dfn[v]); &#125; &#125;&#125;void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--; x=get(pre[x]); &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--; y=get(pre[y]); &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123; for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++) head[i]=-1,vis[i]=0,dfn[i]=0; tim=edge=tot=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; tarjan(1,1); pre[1]=1; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case %d:\\n&quot;,num++); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); lca(u,v); printf(&quot;%d\\n&quot;,edge); &#125; puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj2763,tarjan","slug":"poj2763-tarjan","date":"2020-02-29T08:44:56.000Z","updated":"2020-02-29T09:26:55.068Z","comments":true,"path":"2020/02/29/poj2763-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj2763-tarjan/","excerpt":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问","text":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问 思想与解法 首先最暴力的想法就是去找到路径然后判断，找路径的办法就是先找到$LCA$然后暴力就完事了，很明显时间复杂度$O(N*Q)$绝对$tle$ 我们思考得到最大利润的方式，首先对于$u \\rightarrow v$可以分解为$u \\rightarrow LCA \\rightarrow v$那么最大利润将会如下三条路径中产生：1.$u \\rightarrow LCA$2.$LCA \\rightarrow v$3.$u \\rightarrow v$这时候可能有很多人会想为什么要把路径3分为路径1与路径2，明显路径3包含1和2啊。 在这里解释一下，如果只观察路径3的话，那么答案就是路径上最大的权值减最小权值，但是，无法记录访问顺序！但是这样分开以后以LCA为参考，获得每个点到$LCA$路径的最大利润，如果$u \\rightarrow v$的最大利润不在点到$LCA$的路径而是穿过路径的时，那么商人一定在$u \\rightarrow LCA$进货，在$LCA \\rightarrow v$出售。直接记录两个路径中的最大最小值然后计算就好了 操作根据分析我们需要四个数组！一个储存路径1的最大利润$up$，一个储存路径2的最大利润$down$，第三个储存路径的最大值$ma$，第四个存储最小值$mi$。然后并查集，把每一个点并到$LCA$上并更新所有数据。最后统计答案，据说卡vector。。并查集的合并操作 12345678910int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125; 卡vector我们就是用链式前向星寸询问，继而离线！$add1$函数由于我们要在合并完以后才能得到答案，所以我的办法是每一次计算完$LCA$，用链式前向星保存在$LCA上(add2)！$访问到时在计算ans。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 3e5+5;struct ED&#123; int pre,id;&#125;ed[N],ed1[N];int head[N],head1[N],tot,tot1,ans[N],fa[N],ma[N],mi[N],vis[N],up[N],down[N],head2[N],tot2=1;struct NUM&#123; int x,y,id,pre;&#125;num[N];void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;void add1(int u,int v)&#123; ed1[++tot1].pre=head1[u]; ed1[tot1].id=v; head1[u]=tot1;&#125;void add2(int u,int x,int y,int id)&#123; num[++tot2].id=id; num[tot2].x=x,num[tot2].y=y; num[tot2].pre=head2[u]; head2[u]=tot2;&#125;int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125;void LCA(int x)&#123; vis[x]=1; int i; for(i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(vis[v]) continue; else &#123; LCA(v); fa[v]=x; &#125; &#125; for(i=head1[x];~i;i=ed1[i].pre)&#123; int v=ed1[i].id; if(vis[v]) &#123; add2(get(v),x,v,i); &#125; &#125; for(i=head2[x];~i;i=num[i].pre)&#123; int u = num[i].x,v=num[i].y,d=num[i].id; get(u),get(v); if(d%2)&#123; ans[d]=ans[d^1]=max(up[v],max(down[u],ma[u]-mi[v])); &#125; else&#123; ans[d]=ans[d^1]=max(down[v],max(up[u],ma[v]-mi[u])); &#125; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); memset(head1,-1,sizeof head1); memset(head2,-1,sizeof head2); memset(vis,0,sizeof vis); tot=tot1=tot2=1;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; int u,v,w; init(); for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;w); down[i]=up[i]=0; ma[i]=mi[i]=w; &#125; for(i=1;i&lt;n;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; int q; scanf(&quot;%d&quot;,&amp;q); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add1(u,v); add1(v,u); &#125; LCA(1); for(i=2;i&lt;=2*q;i+=2)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; &#125;&#125; 总结完美的考察对于并查集，$tarjan$的理解，对于扩展域的使用在这里像极了$dp$，也让我发现自己对于tarjan的不足。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"强连通分量","slug":"强连通分量","date":"2020-02-28T15:36:16.000Z","updated":"2020-02-28T15:59:21.225Z","comments":true,"path":"2020/02/28/强连通分量/","link":"","permalink":"https://www.dream-ak.top/2020/02/28/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。","text":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。 tarjan算法这个算法十分强大，广泛应用于$LCA$，强连通缩点等问题，他的主要思想是给每一个点打上一个时间戳，然后$dfs$去寻找每一个点$u$所能回到的最小时间戳$v$，在这个区间$$内的点是一个连通分量，然后进行缩点，这里的缩点有两种方式。 通过数组映射缩点，同一个连通分量映射同一个值 并查集缩点，同一个连通分量指向同一个根 练习题目hdu1239求加多少条边使整个图变为强连通图 思路：首先缩点，把图变成DAG图以后去看如何加最少的边使图变为强连通！很明显，对于入度为0的点必须加一条边使他能到达，出度为0的边也要加边使得到了他的边能回去，要加的最少的边就是$max(入度为0,出度为0)$； 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N =2e5+5;struct ED&#123; int pre,id;&#125;ed[N*2];int head[N],tot=1;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int dfn[N],low[N],vis[N],dfp,sta[N],cnt=0,siz=0,col[N],in[N],out[N];void tarjan(int x)&#123; dfn[x]=++dfp; low[x]=dfp; vis[x]=1; sta[++cnt]=x; for(int i=head[x];i;i=ed[i].pre)&#123; int u=ed[i].id; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[u],low[x]); &#125; else if(vis[u])&#123; low[x]=min(low[x],dfn[u]); &#125; &#125; if(dfn[x]==low[x])&#123; col[x]=++siz; vis[x]=0; while(sta[cnt]!=x)&#123; vis[sta[cnt]]=0; col[sta[cnt--]]=siz; &#125; cnt--; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; tot=1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(head,0,sizeof head); memset(dfn,0,sizeof dfn); memset(in,0,sizeof in); memset(out,0,sizeof out); memset(low,0,sizeof low); memset(col,0,sizeof col); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); &#125; dfp=0,cnt=0,siz=0; for(i=1;i&lt;=n;i++)&#123; if(dfn[i]==0)&#123; tarjan(i); &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=head[i];j;j=ed[j].pre)&#123; if(col[i]!=col[ed[j].id])&#123; out[col[i]]++; in[col[ed[j].id]]++; &#125; &#125; &#125; int ans1=0,ans2=0; for(i=1;i&lt;=siz;i++)&#123; if(in[i]==0) ans1++; if(out[i]==0) ans2++; &#125; printf(&quot;%d\\n&quot;,max(ans1,ans2)==1?0:max(ans1,ans2)); &#125; &#125;&#125; 总结对于$tarjan$应该灵活使用并查集对其进行各种点集的合并。对于$DAG$来说我们要注意的是要实现强连通只需要计算$max$(出度0，入度0)；关于tarjan的题目之后还会找几个好题再写几次。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"分层图和次短路","slug":"分层图和次短路","date":"2020-02-16T14:34:03.000Z","updated":"2020-02-22T13:30:33.690Z","comments":true,"path":"2020/02/16/分层图和次短路/","link":"","permalink":"https://www.dream-ak.top/2020/02/16/%E5%88%86%E5%B1%82%E5%9B%BE%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。","text":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。 分层图简介分层图是一个最短路的应用，他一般用来计算在一个连通图里面在可以省K条路的情况下，我们能从S到T的最短距离！做法有两种： dp 建分层图 在这里我只介绍做法2 建图我们建立k层图，两层图之间的边免费，图里面的连通情况一致。解释一下：对于k层图，如果由S走到T的话，不管是到达哪一个点，他最多经过K次免费！在这个图上面跑迪杰斯特拉，最后找最小值就好了 讲的抽象，在这里我推荐推荐一篇博客 缺陷空间占用太大，跑了两个题目差不多都是$40M$左右，dp版本会低一些，但时间复杂度不变。计算边的数组大小： 一条边要往连向下一层图同时还要连向本层图，所以一条边实际上要有$(k*2)$条边 代码题目地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int N = 5e5+5;struct ED&#123; int pre,id,w;&#125;ed[N*10];int head[N],tot=1,dis[N];bool vis[N];int s,t;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij()&#123; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[s]=0; q.push(make_pair(0,s)); while(q.size())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; //printf(&quot;%d %d\\n&quot;,u,v); if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k)==3)&#123; s=1,t=n; for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); for(j=1;j&lt;=k;j++)&#123; add(u+j*n,v+j*n,w); add(v+j*n,u+j*n,w); add(u+j*n-n,v+j*n,0); add(v+j*n-n,u+j*n,0); &#125; &#125; dij(); int ans=2e9+9; for(i=0;i&lt;=k;i++)&#123; ans=min(ans,dis[t+i*n]); //printf(&quot;%d\\n&quot;,dis[t+i*n]); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125; 次短路解法 通过最短路来求 通过K短路来求 在这里我只讲通过最短路来求得解法我们得到次短路的过程分为两种 最短路更新得来得来,在更新dis[u]时，原来的$dis[u]$将会是次短路 次短路自身延申得来,在次短路$dis2[u]+min(u \\rightarrow v)$,借此更新最短路 对于这两种情况来看，1与最短路有关，2的更新方式也与迪杰斯特拉很像！所以我们这里就直接跑最短路！用优先队列维护两条路径，最短路和次短路，每一次取里面最短的。无论是最短路上的点，还是次短路上的点，因为次短路影响不了最短路，而最短路影响次短路本身就是需要的 题目：POJ3255123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=1,dis[N],dis2[N],n,m;priority_queue&lt;pair&lt;int,int&gt; &gt; q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij(int x)&#123; memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); dis[x]=0; q.push(make_pair(-dis[x],x)); while(q.size())&#123; int u=q.top().second,w=-q.top().first; q.pop(); if(dis2[u]&lt;w) continue;//这里是剪枝，看注释一。 for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,d=w+ed[i].w; if(d&lt;dis[v])&#123; swap(d,dis[v]);//这里只能是交换，因为dis[v]还要给次短路用 q.push(make_pair(-dis[v],v)); &#125; if(d&lt;dis2[v]&amp;&amp;d&gt;dis[v])&#123; dis2[v]=d; q.push(make_pair(-dis2[v],v)); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,dis2[n]);&#125;int main()&#123; int i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; memset(head,0,sizeof head); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); &#125; dij(1); &#125;&#125; 注释一：因为对于次短路的更新，我们会在优先队列里面增加一些无用边，就像最短路时的vis数组一样的性质，把那些多余的边全部去掉，而这里只需要路径长度小于等于次短路的，所以大于的直接continue！","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"双调欧几里得旅行商问题","slug":"双调欧几里得旅行商问题","date":"2020-02-11T15:37:49.000Z","updated":"2020-02-12T05:31:41.933Z","comments":true,"path":"2020/02/11/双调欧几里得旅行商问题/","link":"","permalink":"https://www.dream-ak.top/2020/02/11/%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/","excerpt":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl","text":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl 题目链接题意，给予n个点的坐标，要求从第1个点走到第n个点然后再走回来且去的时候点的序号单调递增，回来的时候单调递减！ 思路说句实在的我第一眼居然是弗洛伊德然后掉坑底怕都没爬出来。正解是$dp$,怎么$dp$呢 我们假设$dp[i][j]$中$i$为从第i个点回到1号点，$j$为从1号点回到$j$号点，而$dp[i][j]$则是这个过程的最短距离。 按着这个定义来看，$dp[i][j]=dp[j][i]$。解释一下：我们对于这个问题来说$i \\rightarrow 1 \\rightarrow j \\Leftrightarrow j \\rightarrow 1 \\rightarrow i$ 那么首先假设$i&lt;j$的dp方程： $i=j$ 时则有$dp[i][j]=dp[i-1][j]+dis(i-1,j)$解释：i \\rightarrow 1 \\rightarrow j \\Leftrightarrow i \\rightarrow (i-1) \\rightarrow 1 \\rightarrow j $i+1 &lt; j $时，则有$dp[i][j]=dp[i][j-1]$解释：i < j(i只能连小于i的边) \\Rightarrow (j-1) \\rightarrow j $i+1=j$则$dp[i][j]=min(dp[i][j],dp[k][j-1]+dis(k,j))(k=1,2···,j-2 $解释：因为这个时候就是相当于在路径$k \\rightarrow 1 \\rightarrow i$中加一条边$j\\rightarrow k$则会得到$j\\rightarrow 1 \\rightarrow i$且$k!=j-1$因为$(j-1) \\rightarrow 1 \\rightarrow (j-1) \\rightarrow j$一定不会是最短路径，因为$j-1$点重复一次的话，假设是$x \\rightarrow j-1 \\rightarrow j$的长度按照三角形边长来看会发现$x\\rightarrow j$的边长一定小于等于前一条边。 由上三种状态可以发现我们要得到$dp[i][j]$首先就要知道$dp[i][j-1]$和$dp[i-1][j]$那么我们可以先对$j$进行遍历得到$dp[i][j-1]$，然后再从小到大遍历$i$就会得到$dp[i][j]$。 代码12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int N = 300;double dp[N][N];struct ed&#123; double x,y;&#125;a[N];double dis(int i,int j)&#123; return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf %lf&quot;,&amp;a[i].x,&amp;a[i].y); &#125; dp[1][2]=dis(1,2); for(j=3;j&lt;=n;j++)&#123; for(i=1;i&lt;j-1;i++) dp[i][j]=dp[i][j-1]+dis(j,j-1); dp[j-1][j]=2e9+9; for(i=1;i&lt;j-1;i++) dp[j-1][j]=min(dp[j-1][j],dp[i][j-1]+dis(i,j)); dp[j][j]=dp[j-1][j]+dis(j-1,j); &#125; printf(&quot;%.2lf\\n&quot;,dp[n][n]); &#125; &#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束系统复习","slug":"差分约束系统复习","date":"2020-02-09T15:08:02.000Z","updated":"2020-02-10T03:34:32.817Z","comments":true,"path":"2020/02/09/差分约束系统复习/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/","excerpt":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。","text":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。 来个板子：12345678910111213141516171819bool spfa(int t)&#123; int l=1,r=0; que[++r]=0; dis[0]=0; while(l&lt;=r)&#123; int u=que[l++]; int i; vis[u]=0; for(i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; if(dis[u]+w&gt;=dis[v])&#123; dis[v]=dis[u]+w; if(num[v]&gt;t) return false; if(vis[v]==0) que[++r]=v,vis[v]=1,num[v]++;//(num在这里重点注意); &#125; &#125; &#125; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展域","slug":"扩展域","date":"2020-02-09T11:07:38.000Z","updated":"2020-02-10T03:34:07.113Z","comments":true,"path":"2020/02/09/扩展域/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E6%89%A9%E5%B1%95%E5%9F%9F/","excerpt":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！","text":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！ 题目链接题意题意明显就是给$[l,r]$中有奇数个1还是偶数个1，然后看它第一次在哪里自相矛盾了，输出第一次自相矛盾的位置！ 思路首先离散化这个我就不说了，你们百度一下什么原理。假设$[l,r]$中奇数个1表示为1，偶数个1表示为0。那么我们每一次合并$(l-1,r]$这个区间，这样就可以把所有数据都联系起来。合并并查集：如何合并？我们那么我们就可以通过 $x \\rightarrow root1$(根节点)的值$d[x]$ $y \\rightarrow root2$(根节点)的值$d[y]$ 得出$root1 \\rightarrow root2$的值。假设$root1$和$root2$相同则判断一下去看这组数据是否正确。判断方法： $x \\rightarrow root1 = d[x]$ $y \\rightarrow root1 = d[y]$ $x \\rightarrow y = x \\rightarrow root1 \\rightarrow y = d[x]$^$d[y]$ 不同则是： $root1 \\rightarrow root2$的值是 $d[x]$ ^ $d[y]$ ^ $n$（$n$为$x \\rightarrow y$）这个就会得到关系的值 解释$x \\rightarrow y = n$$x \\rightarrow root1 = d[x]$$y \\rightarrow root2 = d[y]$则$root1 \\rightarrow root2 = root1 \\rightarrow x \\rightarrow y\\rightarrow root2 = d[x]$ ^ $d[y]$ ^ $n$ 怎么压缩路径 $x \\rightarrow y = d[x]$$y \\rightarrow root = d[y]$那么 $x \\rightarrow root = d[x]$^$d[y]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5e3+5;int fa[2*N],d[2*N];int get(int x)&#123; if(fa[x]==x) return x; int root = get(fa[x]); d[x]^=d[fa[x]]; return fa[x] = root;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%d&quot;,&amp;n); int l[N],r[N],c[N],a[N*2],b[N*2]; char s[5]; int cnt=0; for(i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d %s&quot;,&amp;l[i],&amp;r[i],s); if(s[0]==&apos;o&apos;) c[i]=1; else c[i]=0; a[++cnt]=--l[i],a[++cnt]=r[i]; &#125; sort(a+1,a+1+cnt); int cnt1=0; for(i=1; i&lt;=cnt; i++) &#123; if(i==1||a[i]!=a[i-1]) b[++cnt1]=a[i]; &#125;//离散化操作，我就不说了 for(i=0; i&lt;=cnt1; i++) fa[i]=i,d[i]=0;//初始化操作 for(i=1; i&lt;=n; i++) &#123; int l1=lower_bound(b+1,b+1+cnt1,l[i])-b; int r1=lower_bound(b+1,b+1+cnt1,r[i])-b; int fl=get(l1),fr=get(r1); if(fl!=fr)//不在同一个集合，不会冲突 &#123; fa[fr]=fl; d[fr]=c[i]^d[r1]^d[l1]; &#125; else//在同一个集合，可能冲突！ &#123; if(d[r1]^d[l1]!=c[i]) &#123; printf(&quot;%d\\n&quot;,i-1); return 0; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,n);//如果全部没错，就输出最后一个答案&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"爬虫","slug":"爬虫","date":"2020-02-08T12:12:03.000Z","updated":"2020-02-11T14:16:08.118Z","comments":true,"path":"2020/02/08/爬虫/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%88%AC%E8%99%AB/","excerpt":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧)","text":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧) 爬虫的四个步骤 获取数据：爬虫根据我们的输入的网址进行访问，让后返回一系列的数据 解析数据：对于数据我们需要把返回的数据进行解析成我们能读懂的表达式 提取数据：从我们需要的地方，我们需要对这些数据进行提炼，获取我们所需要的数据。 保存数据：把我们已经获得的数据保存起来，方便阅读！ 爬虫的原理一般都是这样，而反爬虫一般都是利用js等各种诡异的框架来妨碍我们获取需要的数据，当然还有通过直接封IP的，但是他的误伤率很高，因为IP换人的速度太快，不知道封多久。（等以后真正确定了，再把删除线叉掉） 获取数据我们一般是通过$requests$模块来获取数据。这里说明一下$requests$的功能： 发起get(‘url’,**kw)请求，这是常用的获取数据的方法，kw一共是12个参数！在后面有介绍。 post()提交请求，对应于HTTP的post部分 put()请求，对应于HTTP的PUT部分 patch()，向html网页提交局部修改请求，对应于HTTP的patch delete()，向html网页提交删除请求，对应于HTTP的delete head(),获取头信息的方法，对应于HTTP的get requests()，构造请求，支撑以下所有基础方法 requests的get调用$get(‘url’,params=None,**kwargs)$其中$kwargs$一共有12个参数： $response$对象在对于一个请求后返回的对象就是$response$对象，这种对象支持4种操作 首先编码response.status_code()返回一个状态值，其中200为获取成功 response.context()获取的数据返回。 response.encoding定义了编码，我们可以使用response.apparent_encoding来自动获取编码，也可以自己从网站自己找编码方式 response.text()返回一个字符串 通过headers来模拟浏览器向网站发起请求我们先获得自己的代理然后添加headerget(‘url’,headers = user-agent) 通过修改params参数提交我们在获取网页时加上一个自己想要访问的参数，kw=’want’get(“url”,kw)就会在网页上获得自己想要的数据了哟 解析数据我们获取了一个数据要怎么解析呢？这里我用的是$beautifulsoup$解析的网页。首先$beautifulsoup$不是标准库，所以我们先安装： pip install beautifulsoup4 使用简单我们直接调用就好了text = BeautifulSoup(str,’html.parser’)这样子我们就会把text变成一个BeautifulSoup对象，这样操作的原因BeautifulSoup对象在后面的提取数据中成了必要条件，所以必须要转对象同时str必须为字符串！ 提取数据emmm，这里用beatifulsoup提取数据。这里提取是通过find与find_all来提取他俩的功能是匹配html的标签和属性，把BeautifulSoup对象里符合要求的数据都提取出来。区别在于，find()只提取首个满足要求的数据，而find_all()提取出的是所有满足要求的数据。示例中是class_的原因是与类(class)区别，除了对class属性的匹配以外，还可以与其他的例如style进行匹配哦。这个函数返回的值是一个Tag对象！Tag属性请参考：首先Tag的find和find_all返回的也是Tag对象！Tag.attrs生成一个字典[‘id’:key] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom bs4 import BeautifulSoupimport osimport reimport timedef get(id): headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;&#125; url = &apos;https://movie.douban.com/top250?start=&apos; + str(id) + &apos;&amp;filter=&apos; rem = requests.get(url,headers = headers) rem.encoding = &quot;utf-8&quot; print(rem.status_code) html = rem.text path = os.path.abspath(&apos;.&apos;) #with open(path+&apos;/豆瓣电影/html1.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: # f.write(html) link = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot; class=&quot;&quot;&gt;&apos;,html) num=0 for x in link: time.sleep(1) num+=1 rem = requests.get(x,headers = headers) rem.encoding=&apos;utf-8&apos; html2 = BeautifulSoup(rem.text,&apos;html.parser&apos;) title = html2.find_all(&apos;span&apos;,property=&quot;v:itemreviewed&quot;) print(title[0].text) post = html2.find_all(&apos;span&apos;,class_ = &apos;all hidden&apos;) #print(post) if not post: post=html2.find_all(&apos;span&apos;,property=&quot;v:summary&quot;) playvideo = html2.find_all(&apos;a&apos;,class_=&quot;playBtn&quot;) free = html2.find_all(&apos;span&apos;,class_=&quot;buylink-price&quot;) flag = &apos;￥&apos; for i in free: s = str(i.text) if len(s)==50: flag=&apos;@&apos; with open(path+&apos;/豆瓣电影/&apos;+str(num)+str(flag+title[0].text)+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: for i in post: f.write(str(i.text)+&apos;\\n&apos;) for i in playvideo: i.attrs//生成一个字典[&apos;id&apos;:&quot;key&quot;] f.write(str(i[&apos;data-cn&apos;])) f.write(str(i[&apos;href&apos;])+&apos;\\n&apos;) #print(i[&apos;data-cn&apos;],i[&apos;href&apos;])if __name__ == &quot;__main__&quot;: get(0) 爬虫伦理任何一个领域都有一些公约，那么爬虫也是如此，对于一个网站我们的公约是在网站后面添加一个$robots.txt$，你就可以查阅了。 总结爬虫过程find适用对象最后感谢大佬带我入坑","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"类的学习","slug":"类的学习","date":"2020-02-08T05:33:36.000Z","updated":"2020-03-06T08:37:23.507Z","comments":true,"path":"2020/02/08/类的学习/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！","text":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！ 类什么是类？类就是一种抽象的模板，就像月饼的模具一样，我们要做月饼，那么就有一个模具，在这里我们称之为类。 类的定义类的定义是由一个class定义的，一般应用时我们如下面代码一般定义1234class Cat(object): # 类的属性 # 类的行为 一个类的命名通常采用大驼峰式，也就是第一个字母大写。 对于一个类来说，我们通常定义两种类别的东西，一个叫做类的属性，一个叫做类的行为。既然是一个类那么一定有自己的属性，例如：颜色，外观，味道等等。也会有自己的行为，例如：跑，运，发霉，生锈等等动作。 我们对于一个类定义时后面的参数是类的父类，当没有父类时，我们选择放上$object(python3)$ 类的属性对于一个类的属性写法在这里我们了解下面这个函数$def$ $__init__$ ($self$,自定义参数):这个函数的用途从单词词义来看就知道叫做初始化。我们在声明对象时，我们会默认运行此函数，那么我们就可以用这个来定义默认类的属性，对于$self$这里暂时不解释，提醒一下，类的所有函数都必须含有此参数。 类的行为我们对于这个类的行为可以看成我们要这个类的所有的东西可以做什么，比如我们要月饼都运往安徽，那么我们只需要在模板里面写上一个行为“运往安徽”，那么按照这个模板生成的月饼都会运往安徽咯！写法：12def 函数名(self,自定义参数): xxxxx下面xxx代表具体行为，看上去除了$self$以外和其他的函数没有什么差别了。这样就会产生一个简单的类 对象说了那么久的类，那么对象又是什么呢？那就是一个由月饼模板做的月饼了，直接由模板复制出来的。那么对象有是怎么定义的呢？我们一般采用：对象名 = 类()注意后面有个括号哟。我们对于这个对象有些什么操作呢？因为$python$是动态语言，其实我们可以随时对这个对象进行增加属性！ 看代码1234567891011class Moon(object): def __init__(self): self.price = &quot;10￥&quot; self.to = &quot;安徽&quot; def sold(self,price1): print(&quot;原价：%s&quot; % self.price) print(&quot;售价：%s&quot; % price1) returnif __name__ == &quot;__main__&quot;: moon = Moon() moon.sold(&quot;12￥&quot;) 这样$__init__$就是定义属性,$sold$就是一个行为函数了 数据封装看了一下廖雪峰大神的博客，封装就是执行操作时，不需要对一个类里面的数据进行访问，直接把操作放在类里面，以后调用时就不用考虑类里面的行为咯，像极了我的行为函数啊。hhh","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"zoj2770差分约束","slug":"zoj2770差分约束","date":"2020-02-07T12:54:48.000Z","updated":"2020-02-07T12:57:37.371Z","comments":true,"path":"2020/02/07/zoj2770差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/02/07/zoj2770%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"emmm,好久没刷题，手感都快没了，先来养下手感","text":"emmm,好久没刷题，手感都快没了，先来养下手感 题目链接题意大概就是给我们$n$个营地，$c[i]$表示第$i$个营地最多的人数，第$u$-第$v$个营地一共有$w$个人。问最少有多少人。对于这种题型，我们一般做法是首先确定一个数组表示前面$i$个营地的总人数 挖掘隐藏条件，每一个营地的人数不可能为负数，所以$a[i]-a[i-1]\\geq0$每个营地最多有$i$人，我们可以知道，$a[i]-a[i-1]\\leq c[i]$$u-v$一共最少有$w$人，我们可以得出，$a[u]-a[v-1]\\geq w$ 我们可以把第二个条件化简为 a[i]-a[i-1]\\leq a[i] \\rightarrow a[i-1]-a[i] \\geq -c[i]由上化简，我们就把所有的代数式换成了大于等于的形式，开始建图了题目要求的是最小的人数，那么也就是$min(a[n]-a[0])$那么我们就可以这么建图： 我们按照从被减数向减数建一条边，边权为右边的值。 这样建图有什么好处？因为我们要求的是$min(a[n]-a[0])$，而我们这么建图就会使源点$0$到达的任意一个$v$最长路长度都是最少的人数，为什么是最长路？大于等于符号决定的呀，当大于等于时，只有最长路不会和其他方向的边冲突，小于等于时，我们只有最短路不会和其他方式的边冲突。接下来看代码，spfa版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;//#include&lt;windows.h&gt;using namespace std;const int N = 2e5+5;int deq[N*2],a[N],head[N],tot=0;struct ED&#123; int pre,to,w;&#125;ed[2*N];int vis[N],dis[N],num[N];void spfa(int x)&#123; memset(dis,-1,sizeof dis); memset(vis,0,sizeof vis); memset(deq,0,sizeof deq); memset(num,0,sizeof num); dis[0]=0; int l=1,r=0; deq[++r]=0; while(l&lt;=r)&#123; int u=deq[l]; l++; vis[u]=0; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].to; //printf(&quot;%d %d %d %d %d\\n&quot;,u,v,dis[u],ed[i].w,dis[v]); if(dis[v]&lt;dis[u]+ed[i].w) &#123; dis[v]=dis[u]+ed[i].w; if(vis[v]) continue; deq[++r]=v; num[v]++; if(num[v]&gt;=x) &#123; printf(&quot;Bad Estimations\\n&quot;); return ; &#125; vis[v]=1; //printf(&quot;%d %d\\n&quot;,u,v); &#125; &#125; &#125; if(dis[x]==-1)&#123; printf(&quot;Bad Estimations\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;,dis[x]); &#125;&#125;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].to=v; ed[tot].w=w; head[u]=tot;&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2) &#123; tot=0; for(i=0;i&lt;=n;i++)&#123; head[i]=-1; &#125; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); add(i-1,i,0); add(i,i-1,-a[i]); &#125; int u,v,w; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u-1,v,w); &#125; spfa(n); &#125; //system(&quot;pause&quot;);&#125;不用队列，方便优化","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"python爬取王者数据","slug":"python爬取王者数据","date":"2020-02-06T10:24:34.000Z","updated":"2020-02-08T13:29:30.494Z","comments":true,"path":"2020/02/06/python爬取王者数据/","link":"","permalink":"https://www.dream-ak.top/2020/02/06/python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%80%85%E6%95%B0%E6%8D%AE/","excerpt":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧","text":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧 $requests$首先我们安装这一个requests模块，在终端输入 pip install requests 利用$r=requests.get()$来进行对一个网页的获取，返回一个二进制字符串，为了不把字符转乱码，我们一般使用正确的编码格式，这个编码格式一般在网页上写着！或者使用$r.apparent_encoding$的函数自动获取，不过不保证完全准确！转字符串时可以使用$html=r.text$返回字符串，详情请看爬虫这篇博客 强行爬虫在爬https://www.vmgirls.com 时会发现不允许爬取，那么有一个玄学的爬取方法，这个网站是通过判断代理服务来判断是不是爬虫，在requests时会发送一个爬虫请求，该网站如果发现是爬虫时，那么我们就可以把requests发送的代理服务改掉,通过在$requests(‘https://vmgirls.com/&#39;,headers=&quot;本地代理&quot;)$。本地代理可以在网页上查看！ $re.findall()$我们一般使用这个来获取自己需要的信息。 ()括号内表示需要的信息，没有括号则表示不需要的信息 []匹配时我们需要写一个自己的字符分类，然后去选择自己的信息 findall(r’’,txt)是格式,r后跟着自己的匹配方式。 os文件读写： 对于文件读写我们一般是使用$with$ $open(“文件路径”,’读写方式’,’encoding=编码规则’) as f:$ 对于文件路径可以使用绝对路径，编码规则须和字符串的编码规则相同。 time为了网站的稳定性能我们一般要去使用$time.sleep()$来控制爬取速度。 最后来看一下我们是如何爬取王者的：1234567891011121314151617181920212223242526272829303132import requestsimport reimport osimport timer = requests.get(&apos;https://pvp.qq.com/web201605/herolist.shtml&apos;)r.encoding=&quot;gbk&quot;html = r.texthttp = &quot;https://pvp.qq.com/web201605/&quot;dirs = os.path.abspath(&apos;.&apos;)dir_name = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;([a-z0-9/.]*)&quot; target=&quot;_blank&quot;&gt;&lt;img+\\s&apos;,html)for i in dir_name: time.sleep(1) r = requests.get(http+i) r.encoding=&apos;gbk&apos; html1=r.text hero = re.findall(r&apos;&lt;h2 class=&quot;cover-name&quot;&gt;(.*?)&lt;/h2&gt;&apos;,html1) print(hero) skin = re.findall(r&apos;&lt;ul class=&quot;pic-pf-list pic-pf-list3&quot; data-imgname=&quot;([\\S]*)&quot;&gt;&apos;,html1) skill_name = re.findall(r&apos;&lt;p class=&quot;skill-name&quot;&gt;&lt;b&gt;(.*?)&lt;/b&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&apos;,html1) skill_decs = re.findall(r&apos;&lt;p class=&quot;skill-desc&quot;&gt;(.*?)&lt;/p&gt;&apos;,html1) skill_tips = re.findall(r&apos; &lt;div class=&quot;skill-tips&quot;&gt;(.*?)&lt;/div&gt;&apos;,html1) lens = len(skill_tips) with open(dirs+&apos;/&apos;+&apos;王者荣耀&apos;+&apos;/&apos;+hero[0]+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;) as f: f.write(&quot;英雄名称：&quot;+hero[0]+&apos;\\n&apos;) f.write(&quot;皮肤：&quot;+skin[0]+&apos;\\n\\n&apos;) for j in range(0,lens,1): f.write(&quot;技能名称：&quot;+skill_name[j][0]+&apos;\\n&apos;) f.write(&quot;技能冷却：&quot;+skill_name[j][1]+&apos;\\n&apos;) f.write(&quot;技能消耗：&quot;+skill_name[j][2]+&apos;\\n&apos;) f.write(&quot;技能描述：&quot;+skill_decs[j]+&apos;\\n&apos;) f.write(&quot;技能用途：&quot;+skill_tips[j]+&apos;\\n&apos;) f.write(&apos;\\n&apos;) 还是有点不会写文件的保存格式，呜呜呜，只会狂写编码了。。。最后来看一下效果：","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-02-05T10:48:23.000Z","updated":"2020-02-06T13:01:44.067Z","comments":true,"path":"2020/02/05/正则表达式/","link":"","permalink":"https://www.dream-ak.top/2020/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$","text":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$ 正则表达式匹配方式 字符表达 意义 例子 例子解释 \\d 匹配一个数字 \\d{3} 匹配三个数字 \\w 匹配一个字母 \\w{3} 匹配三个字母 ? 可选匹配，前面括号内符号可以匹配一次或者零次 (wo)?man 匹配man或者woman * 匹配零次或多次 (wo)*man 代表可以匹配man、wowoman等等 + 匹配一次或多次 ((wo)+man) 代表可以匹配woman、wowoman等等 {} 指定匹配次数 (wo){2,5}man 可以匹配wo重复2到5遍的此类字符串 1 管道，指定多种字符模式，返回第一次出现的文本它是一竖 ‘Batman 1 Tina Fey’ 表示查找Batman和Tina Fey的第一次出现的字符 ^ 直接从头开始匹配 ^hello 从头开始匹配hello $ 必须以该字符结束 3$ 必须以3结尾 正则匹配是一种贪心匹配(能长则长)，而花括号的匹配是一种非贪心匹配(能短则短) search：每一次返回第一次找到的字符串 findall：返回整个text的所有的字符串 字符分类字符表达式 字符分类 表达式 \\d 0到9的任何数字 \\D 除0到9的任何数字 \\w 任何字母、数字、下划线字符 \\W 除字母、数字、下划线字符外的任意字符 \\s 空格、制表符、换行符 \\S 除空格、制表符、换行符以外的任意字符 . 匹配除换行以外所有字符 .* 匹配所有字符 建立自己的字符分类 [quit]表达可以匹配quit里面的任意一个字符 [ ^quit ]表达非quit里面任意一个字符的字符可以通过短横来表达字母或数字的范围[a-zA-Z0-9]将匹配所有字母和数字 文本替换正则表达式不仅能找到文本模式，而且能够用新的文本替换掉这些模式。$Regex$对象的 $sub()$方法需要传入两个参数。第一个参数是一个字符串，用于取代发现的匹 配。第二个参数是一个字符串，即 正则表达式。$ sub()$方法返回替换完成后的字符串。举个例子： &gt;&gt;&gt; namesRegex = re.compile(r&#39;Agent \\w+&#39;) &gt;&gt;&gt; namesRegex.sub(&#39;CENSORED&#39;, &#39;Agent Alice gave the secret documents to Agent Bob.&#39;) &#39;CENSORED gave the secret documents to CENSORED.&#39;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python刷题","slug":"python刷题","date":"2020-02-04T05:47:10.000Z","updated":"2020-02-04T05:55:22.525Z","comments":true,"path":"2020/02/04/python刷题/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/python%E5%88%B7%E9%A2%98/","excerpt":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划","text":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划 一行内多次输入1n,m=int(input.slipt()) 这样就可以一行输入两个数了，hhh(抄的) 一行多输出1print(&apos; &apos;.join(map(str,a))) 这个能把一个数组中间加入空格并输出。 看题目现在来看$Nod51$题目：冒办法，我找了半天就只有$codeforce$和$Nod51$支持$python3$了 全排列题面很好懂，解法很好想，就是被输出卡了。。。12345678910111213a = []n,m=map(int,input().split())def dfs(l,r): if m==r: print(&apos; &apos;.join(map(str,a))) return else : for i in range(l+1,n+1,1): a.insert(r,i) dfs(i,r+1) a.pop(r) return dfs(0,0) a序列放前面一点就能被后面函数调用了，hhh，强行全局","categories":[{"name":"python刷题","slug":"python刷题","permalink":"https://www.dream-ak.top/categories/python%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"map与reduce","slug":"map与reduce","date":"2020-02-04T03:19:31.000Z","updated":"2020-02-04T03:21:46.520Z","comments":true,"path":"2020/02/04/map与reduce/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/map%E4%B8%8Ereduce/","excerpt":"","text":"","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"函数","slug":"函数","date":"2020-02-03T09:04:38.000Z","updated":"2020-02-04T02:37:43.781Z","comments":true,"path":"2020/02/03/函数/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E5%87%BD%E6%95%B0/","excerpt":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh","text":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh 函数定义$def$定义一个函数要使用$def$语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。拿一个从$l$加到$r$的和的函数来讲12345678def sum(l,r): sum = 0 for i in range(l,r+1,1): sum += i return suml = int(input(&quot;l=&quot;))r = int(input(&quot;r=&quot;))print(sum(l,r)) $output$l=1r=1005050 位置参数比如上面的参数就叫做位置参数，调用$sum$函数时，必须给予两个固定参数 默认参数看一个代码 1234def mul(a,b = 3): print(a*b)mul(2)mul(2,4) $output$68 这个和上面的参数比较不同点在于，在定义参数的时候对一个参数赋值，这种写法叫做默认参数 特性我们调用函数时，对于默认参数可以选择性增加调用值。更大的符合了用户的情况 注意 对于默认参数我们一般默认，变化大的在前，变化小的在后 且对于默认参数放在位置参数以后 对于默认参数赋值必须赋为不变对象 可变参数可变参数：调用时，输入的长度可以是任意个。在传入以后自动组成一个$tuple$比如我们要对一个$list$或$tuple$进行和运算，由于每一个$list$的长度不定。所以我们需要一个可变参数。来看一个代码 123456789def sum1(*lis): sum = 0 for i in lis: sum += i return suma = [1,2,5,7]b = [5,9,8]print(sum1(*a))print(sum1(*b)) $output$1522 可以发现，好像就是C语言传入指针了，对的，C语言遮掩好像也可以，就是长度问题而已。下面这些要用的时候再补充吧，暂时请参考廖雪峰 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。他的功能，给与用户想给的一些多余的信息，也可以进行收集。 命名关键字参数对于关键字参数进行一定的限制","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"dict和set","slug":"dict和set","date":"2020-02-03T07:01:13.000Z","updated":"2020-02-22T06:45:45.189Z","comments":true,"path":"2020/02/03/dict和set/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/dict%E5%92%8Cset/","excerpt":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧","text":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧 $dict$$dict$的结构这里按照廖雪峰的介绍给出两种方式 按照字典树的方式建立一棵字典树，优点不会出现冲突，可直接使用，缺点相较于哈希来说，查找较慢 直接建立一个哈希表，每一次按照$key$直接哈希地址然后得到答案，优点，查找方便。缺点：容易出现哈希冲突。 $dict$是第二种建立方式，因此$key$的值是唯一的，不可重复，如果重复了那么就会将前面得到的数据丢失冲掉。 $dict$的建立首先来看一段代码 1234a=&#123;&#125;a[&apos;peng&apos;] = 4a[&apos;我&apos;] = 5print(a[&apos;我&apos;]) $output$5 可以看到我们是通过大括号{}来定义一个空$dict$然后添加直接赋值就好了。调用直接访问$key$就行了，但是一定要保证这个$key$存在。判断$key$存在性的办法： $print(‘我’\\ in\\ a) $如果存在，返回$true$。不存在返回false。 $print(a.get( ‘我’,x))$当不存在‘我’时返回$x$值 $dict$的删除这个的删除我们前提是$key$存在,如果存在，我们就可以像$list$一样删除它。 12a.pop(&apos;peng&apos;)print(a.get(&apos;peng&apos;,777)) $output$777 注意$dict$可以用在需要高速查找的很多地方，在$Python$代码中几乎无处不在，正确使用$dict$非常重要，需要牢记的第一条就是$dict$的key必须是不可变对象。 这是因为$dict$根据$key$来计算$value$的存储位置，如果每次计算相同的$key$得出的结果不同，那$dict$内部就完全混乱了。这个通过$key$计算位置的算法称为哈希算法$（Hash）$。 要保证$hash$的正确性，作为$key$的对象就不能变。在$Python$中，字符串、整数等都是不可变的，因此，可以放心地作为$key$。而$list$是可变的，就不能作为$key$ $set$$set$一般用于去重和集合操作，它可以对集合进行”与”、”或”操作. 创建创建一个空$set$1a = set() 创建一个$set$我们一般是要一个$list$做输入集合看一段代码123l = [1,1,5,9,3,8,9]a = set(l)print(a) $output${1, 3, 5, 8, 9} 很明显它自己去重了，同时不要被表面所迷惑$set$是无序的 $set$怎么添加元素？答案下行揭晓$a.add(x)$参数$x$是你要添加的$key$12a.add(2)print(a) $output${1, 2, 3, 5, 8, 9} 删除元素我们一般通过$a.remove(x)$删除,$x$是你要删除的$key$12a.remove(2)print(a) $output${1, 3, 5, 8, 9} 集合操作直接&amp;或者|就好了123b=set([1,2])print(a&amp;b)print(a|b) $output${1}{1, 2, 3, 5, 8, 9} 不可变变量字符串属于不可变变量，同时$list$是一个可变变量。123a = &quot;abc&quot;print(a.replace(&apos;a&apos;,&apos;A&apos;))print(a)","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"条件与循环","slug":"条件与循环","date":"2020-02-03T06:31:15.000Z","updated":"2020-02-04T02:12:54.899Z","comments":true,"path":"2020/02/03/条件与循环/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/","excerpt":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进","text":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进 $if$判断首先我们来看一段代码12345socre=int(input())if score&gt;=60: print(&quot;pass\\n&quot;)else : print(&quot;No pass\\n&quot;)这个就可以把你的分数转化成过和没过了，挂科了没，一目了然！对于这段代码的解释我就对他与C语言的比较了。没有C语言的小括号，$if$后面全是判断一直到$’:’$对于else 我们也需要$’:’$如果进行多次判断由C语言的$else if$ $\\rightarrow$ $elif 判断:$ 循环$for$ … $in$循环这种循环我们一般是用一个变量每一次迭代$in$里面的内容(可以是$list,tuple$等数据结构)，比如 123456789101112131415161718x=(5,2,0)for i in x: print(i)``` &gt; $output$520## $for$ ... $in$ $range(x,y,z)$循环我们看这个循环 其中省略号代表变量，我们假设为$i$现在来解释一下参数1. $x$代表$i$的初始值2. $y$代表$i$的上界或下界,**不得小于等于$y$**3. $z$代表$i$的步进大小每一次加上多少来看一段代码 for i in range(3,1,-1): print(i)``` $output$32","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"list和tuple","slug":"list和tuple","date":"2020-02-02T13:34:09.000Z","updated":"2020-02-03T06:52:06.529Z","comments":true,"path":"2020/02/02/list和tuple/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/list%E5%92%8Ctuple/","excerpt":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。","text":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。 $list$这种数据类型使列表 $list$是一种有序的集合，可以随时添加和删除其中的元素。对于这个我们可以看下面这个例子12a=[&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;]print(a) $ output$:$[‘s’, ‘a’, ‘r’, ‘s’]$ 而一个$list$的长度怎么看？还记得看字符串长度的$len$函数吗？我们就是通过$len$来查看list的长度1print(len(a)) $output:$4 同时我们还可以通过像C语言一样的手法访问下标来查看元素，同样不能越上界123print(a[0])print(a[3])print(a[-1]) $output$sss应该发现了，可以有负数，-1的意思就是倒数第一个咯。但是也不能超过$list$的长度 $list$包含的数据类型$list$里面包含的数据类型可以混合加入例如我们可以在一个list里面放入数字、字符串甚至是一个$list$也行！ $list$的操作删除123a.pop(0)print(a)print(a[0]) $output:$$[‘a’, ‘r’, ‘s’]$$a$ 我们可以看到，要删除第i个数字就是直接$pop(i)$，同时会把后面的往前面移动 插入123a.insert(0,a)print(a)print(a[0]) $output:$$[‘s’, ‘a’, ‘r’, ‘s’]$$s$每一次插入，我们都是把第$i$个元素之后往后移动，然后插入 增加$a.append(strr)$默认从尾部增加元素 $tuple$$tuple$也是一种有序列表，它的特点是一旦初始化成功后就不得修改 定义12a = (&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;);print(a) $output$(‘s’, ‘a’, ‘r’, ‘s’) 大家可能发现了，$list$的定义时中括号$[]$而$tuple$是$()$注意我们定义空$tuple$时我们是$a=()$,但是如果定义一个元素时例如$a=(1,)$时，我们注意要打逗号，不然会被误解为$a=1$为$int$型变量 意义$tuple$因其不可修改的性质所以从安全角度上来说比$list$更加安全，我们一般能用$tuple$绝不用$list$ 一个“可变的”$tuple$首先注意引号，他还是不可变的，可为什么又可以变呢？我们尝试如下定义 $a=(‘a’,’b’,[‘a’,’b’])$ 可以发现这一个$tuple$所指向的内容含有字符和一个$list$$tuple$里面的内容的确不可以变，但$list$改变了之后list的地址还是不变的，所以就改了撒，看不懂可评论。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python字符串和数组元组","slug":"python字符串","date":"2020-02-02T12:21:42.000Z","updated":"2020-02-04T03:26:12.993Z","comments":true,"path":"2020/02/02/python字符串/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记","text":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记 字符串对于$python3$的编码格式是一个$Unicode$编码 $unicode$编码粗略解释一下，详情请访问廖雪峰的笔记： $Unicode$解决了各国语言的编码冲突，利用两个字节。$UTF-8$编码是因为$Unicode$对于空间来说浪费高，所以折中出现了utf-8编码 应用场景在计算机内存中，统一使用$Unicode$编码，当需要保存到硬盘或者需要传输的时候，就转换为$UTF-8$编码。 用记事本编辑的时候，从文件读取的$UTF-8$字符被转换为$Unicode$字符到内存里，编辑完成后，保存的时候再把$Unicode$转换为$UTF-8$保存到文件。 浏览网页的时候，服务器会把动态生成的$Unicode$内容转换为$UTF-8$再传输到浏览器：正文$python3$的字符串是$Unicode$编码，也就是适合各种语言啦 对于单个字符来说，我们支持$ord()$获得字符整数表示，$chr()$把编码转为 12print(chr(20320))print(ord(&apos;你&apos;)) 输出你20320 $len$计算字符串的字符数$len(str)$返回一个整数，表示$str$所含有的字符数12strr=&quot;我爱你&quot;print(len(strr)) $output:$3 格式化输出$python$的格式化和C语言的大致相同|占位符|替换内容||:-:|:-:||%s|字符串||%d|整数||%f|浮点数||%x|16进制整数|不过有个区别我表示的重点提醒：print(“%s” % strr),不像C语言中间用逗号分隔顺带一个妙招，当你忘了要用什么的时候可以使用%s哦，他会自动转字符串，hhh1print(&quot;%s %s&quot; % (520,False)) 注意事项 对于$python$里的字符中不能直接相加，需要先把它用$ord$转成数字然后再用$chr$转回来！ 对于字符串里面字符修改必须使用$repalce(old,new,count)$进行生成新的字符串对象！ 12345678def index(head): head=str(head) if head[0]&gt;=&apos;a&apos;and head[0]&lt;=&apos;z&apos;: return head.replace(head[0],chr(ord(head[0])-32),1)#返回一个新的字符串对象 return headL1 = [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;]L2 = map(index,L1)print(list(L2))","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python启动","slug":"python启动","date":"2020-02-02T08:27:48.000Z","updated":"2020-02-02T12:38:36.259Z","comments":true,"path":"2020/02/02/python启动/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%90%AF%E5%8A%A8/","excerpt":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭","text":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭 python基础python编码格式python的编码格式是按照缩进方式，代码就像下面这个一样：12345a = 100if a &gt;= 0: print(a)else: print(-a)和C语言的差别是c语言用大括号等价于这里的缩进 python的注释 python的注释是通过#,以#开头全部注释掉每遇到一个’$:$’号都会进行自动缩进，视为一个代码块python大小写敏感。 数据类型int范围和C语言的$longlong$一致，应用方式和C语言用法一致 string字符串，他的用法和C语言的字符串用法类似，但是增加了$a[-x]$表示从后开始第x个字符，一般是由’或者”组成。 转换在一个字符串(仅包含数字)前加上int则会自动转换为int型数据类型,如下代码检测1234a = &apos;123456&apos;print(type(a))a=int(a)print(type(a)) 输入python的输入使input();在输入的时候加上提示的话就是在input(“hello world”);12a = input(&quot;please input a math:&quot;)print(a)注意input输入的东西为字符串,以下验证12a=input()print(type(a));对于这种情况我们一般直接在input前面加上一个int就好了12a=int(input())print(type(a)) 换行与C语言相似的是我们一样可以采用”\\n”换行，但增加了一个…换行的方式1print(&quot;hhh...hhh...hhh&quot;)今日份复习到此结束，hhh，晚上在介绍一下其他的基础。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"迪杰斯特拉堆优化","slug":"迪杰斯特拉堆优化","date":"2020-02-01T06:53:49.000Z","updated":"2020-02-02T08:29:07.601Z","comments":true,"path":"2020/02/01/迪杰斯特拉堆优化/","link":"","permalink":"https://www.dream-ak.top/2020/02/01/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%A0%86%E4%BC%98%E5%8C%96/","excerpt":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃","text":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃 原理来说原理的话我建议可以讲一下迪杰斯特拉的算法思想，利用贪心，每一次走距离当前点$u$最近的点$v$，那么我们由原点到$v$一定会是最近的，因为$u$一开始就是最近的，那么dis[u]+min(u\\rightarrow v)\\leq dis[u]+!min(u\\rightarrow v)根据这个我们可以知道我们只需 维护一个最小堆来得到当前最小的$dis[u]$得到$u$的位置，然后找到$u$能到的点$v$的最短路径，得到$dis[v]$然后加入堆 循环1操作直到堆为空就好了。代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=0,dis[N],vis[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij_heap(int x)&#123; int i; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(i=head[u];i;i=ed[i].pre)&#123; if(dis[u]+ed[i].w&lt;=dis[ed[i].id])&#123; dis[ed[i].id]=dis[u]+w; q.push(-dis[ed[i].id],ed[i].id);//这里用负数使最大堆变最小堆 &#125; &#125; &#125;&#125;int main()&#123; dij_heap(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束","slug":"差分约束","date":"2020-01-30T13:33:49.000Z","updated":"2020-02-29T08:45:34.596Z","comments":true,"path":"2020/01/30/差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh","text":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh 一般形式差分约束题一般是给出大量的一些不等式 a_i-b_i\\leq x \\rightarrow a_i\\leq x + b_i由上面这个不等式我们应该可以联想到最短路的不等式 dis[u]\\leq dis[v] + x(u \\rightarrow v)因此，我们可以将差分约束化成一个最短路来求，我们的$dis[u]$保存由远点到$u$的可以选择的最大范围!==为什么是最大范围？==我们每一次选择的是$min(u \\rightarrow v)$，那么一开始我们就会选择一个从原点$s$最小的范围，且没有其他路径会是她变得更小(三角形)，那么这个由原点出发的范围将会是$s \\rightarrow u$的范围，选择最大的话，就是这个范围啦。 求最长路当求最大的范围时是最短路，已经说过了，但是如果求最小范围呢？看一下基本形式 a_i-b_i\\geq x \\rightarrow a_i \\geq x + b_i这个又是什么意思呢？试着把$a_i，b_i$也当作两个点，那么这就是 dis[a_i]\\geq dis[b_i] + x也就是最长路的样子啦 最长路实现最长路的办法，我们试着用最短路的办法去试 floyd $O(n^3)$很明显暴力枚举下面肯定是可以的，但是复杂度实在太高，放弃 dijstra基于贪心的算法，我们最长路的贪心是做不到的，从三角形来看是很明显的，遂继续放弃 bellman_ford差不多就是暴力对所有的边进行n-1次遍历了==一条最长路最多经过$n-1$次松弛==，在这里最长路也是这样啊，时间复杂度的话，我们可以考虑已经死了的 spfa呀，死了不要紧我们可以优化spfa玄学优化 双端队列优化，一个非常常见的优化，当边权小于队首时从队首加入，否则队尾！ 双端慢了？没事我们可以数组模拟，强行加速！ 啊，还是tle？淡定加容错优化，我们首先把所有边权加起来开个根号后加上一个容错值$x$然后当当前边权小于队首边权加上容错时从队首加入，否则队尾，继续强行加速！ 听说还是tle？emmm，等死吧","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"vscode背景配置","slug":"vscode背景配置","date":"2020-01-30T13:00:23.000Z","updated":"2020-06-06T03:10:27.681Z","comments":true,"path":"2020/01/30/vscode背景配置/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/vscode%E8%83%8C%E6%99%AF%E9%85%8D%E7%BD%AE/","excerpt":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！","text":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！ 安装background扩展商店安装就好了这里会弹出code损坏，莫急，往下看 下载 Fix vscode checksum扩展商店下载好以后按下ctrl+shift+p输入 Fix checksum 选择apply就行了 配置插件管理员运行vscode，打开以后按如下图操作打开setting.json 编辑setting.json1234567891011121314151617181920&#123; &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;file:///E:background/vscode.png&quot;//你的图片的绝对路径 ], &quot;background.style&quot;: &#123; &quot;content&quot;: &quot;&apos;&apos;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;background-position&quot;: &quot;50% 50%&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 &#125;, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;&#125; 接下来可能会要求你重启就完成了","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"vscode配置c","slug":"vscode配置c","date":"2020-01-28T16:45:47.000Z","updated":"2020-06-06T03:10:32.402Z","comments":true,"path":"2020/01/29/vscode配置c/","link":"","permalink":"https://www.dream-ak.top/2020/01/29/vscode%E9%85%8D%E7%BD%AEc/","excerpt":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。","text":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。 1.下载DEV也许有人会问不是vscode嘛？为啥下载这个，因为vscode是编辑器我们需要下载一个编译器，我们就把DEV里面的mingw单独拿出来添加环境变量，提供编译环境。下载网址：1https://dl.pconline.com.cn/download/908942-1.html进入后点击普通下载，安装好。 2.配置环境变量1.右击电脑属性后2.进入高级设置点击环境变量3.在系统变量Path里面增加mingw64/bin的路径声明一下mingw64/bin就在之前下的DEV文件里面，桌面右击快捷方式打开文件所在地址就可以找到该文件了从左至右逐一执行后点击确定。打开cmd输入gcc如果返回的是gcc: fatal error: no input filescompilation terminated.那么环境就配好了，否则重启一下电脑再试一下，再不行的话就是环境配置失败，再来吧 3.下载vscode下载地址1https://code.visualstudio.com/Download下载过程中一路确定就好了。声明：安装路径不得含有中文！不然之后的操作会有玄学错误，gdb退出代码为-3 汉化chinese 汉化工具打开vscode工具，使用快捷键组合【command+Shift+p】，在搜索框中输入“configure display language”，点击确定后；修改locale.json文件下的属性“locale”为“zh-CN”; 重启vscode工具 安装插件c/c++ c配置必须的vscode-icons美化图标工具chinese 汉化工具Bracket Pair Colorizer 一起安装算了beautify 美化工具 4.文件配置1.我们首先写一个test.cpp文件代码里面必须含有一个输入getchar或者scanf都行,不然后面看不到输出效果，直接说返回值为1 launch文件2.从左到右操作，创建launch.json文件3.使用gdb创建之后点击gcc.exe生成一个文件，在该文件里面添加下面这段代码1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gdb.exe&quot;,//gdb.exe的文件地址 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;//与task.json一致 &#125; ]&#125;两个要注意的地方1.miDebuggerPath这是你的gdb.exe文件地址，注意要修改正确！（好像还有一个gdb32.exe你看那一个成功用那个吧）2.externalConsole这里是true！ tasks.json文件这个文件我们手动添加，在.vscode文件里面创建tasks.json注意别打错了添加如下代码12345678910111213141516171819&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++.exe build active file&quot;, &quot;command&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe&quot;,//g++.exe的位置 &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot;//bin文件夹位置 &#125; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;上面代码两个地方需要修改，请仔细看！ “command”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe”,//g++.exe的位置 “cwd”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin”//bin文件夹位置此时再回到test.cpp里面按F5运行一下，应该能输出了。到此环境安装结束！撒花","categories":[{"name":"环境配置","slug":"环境配置","permalink":"https://www.dream-ak.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2020-01-28T03:19:55.000Z","updated":"2020-04-30T11:36:40.727Z","comments":true,"path":"2020/01/28/欧拉函数/","link":"","permalink":"https://www.dream-ak.top/2020/01/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数","text":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数 欧拉函数的性质 公式 解释 $ φ(x * y) = φ(x) * φ(y) $ 当且(x,y)==1 $ φ(x) = x - 1 $ 当且仅当x为质数时 $ φ(n) = (p-1) * p^{k-1} $ $ φ(n)=n∗∏(1−1/p_i) $ pi是n的质因子 $ a^{φ(m)}==1%m $ 当且仅当(a,m)==1 $ s = n * (φ(n)/2) $ s：小于n且与n互质的数之和 $ φ(n * p)=φ(n) * p $ 当p为质数且n%p==0 $ φ(n * p)=φ(n) * (p-1) $ 当p为质数且n%p!=0 计算欧拉值的打表代码,时间复杂度O(n)123456789101112phi[1]=1; for(int i=2;i&lt;n;i++)&#123; if(vis[i]==0) pri[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;1ll*i*pri[j]&lt;n;j++)&#123; vis[i*pri[j]]=1;//标记此点经过非质数 if(i%pri[j]==0) &#123; phi[i*pri[j]]=phi[i]*pri[j];//性质7 break; &#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1);//性质8 &#125; &#125; 用性质4计算单个欧拉值1234567891011121314int ph(int n)&#123; int res=n,i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; res=res-res/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) res=res-res/n; return res;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[]},{"title":"割点与割边","slug":"割点","date":"2020-01-20T14:21:29.000Z","updated":"2020-02-28T15:37:11.655Z","comments":true,"path":"2020/01/20/割点/","link":"","permalink":"https://www.dream-ak.top/2020/01/20/%E5%89%B2%E7%82%B9/","excerpt":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。","text":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。易得割点是2号点。 具体操作：121.用dfs给每一个点打上一个时间戳，把每一个点的时间戳保存至num【】里面；2.通过dfs来统计每一个点能到达的最小的时间戳。&lt;br&gt; 割点的判定方式： 如果存在一个点他的子节点能到达的最小时间戳大于等于父节点的时间戳那么这个点是一个割点。(也就是不能回到祖先，那么当前点就是割点咯) 假设一个点存在两个子节点，那么该点就是割点。我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。更新 low 的伪代码如下：1234如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);否则low[u] = min(low[u], num[v]);//这里是num[v]而不是low[v]的原因是如下图//按照节点编号从小到大遍历，4节点先到1，如果是low[v]的话，节点6的low值等于1，很明显是不可以的，所以是num 例题板子题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;const int N=2e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=1,cnt=0;int vis[N],num[N],low[N],inde,res,flag[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void tarjan(int u,int fa)&#123; vis[u]=1; low[u]=num[u]=++inde; int ch=0,i; for(i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(!vis[v])&#123; ch++; tarjan(v,u); low[u]=min(low[u],low[v]); if(fa!=u&amp;&amp;low[v]&gt;=num[u]&amp;&amp;!flag[u]) flag[u]=1,res++; &#125; else if(v!=fa)&#123; low[u]=min(low[u],num[v]);//这里非常关键，如果写成low[u]=min(low[u],low[v])在题目里面会wa &#125; &#125; if(ch&gt;= 2&amp;&amp;fa==u&amp;&amp;!flag[u])&#123; flag[u]=1; res++; &#125;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) head[i]=0,vis[i]=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; for(i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; inde=0; tarjan(i,i); &#125; &#125; printf(&quot;%d\\n&quot;,res); for(i=1;i&lt;=n;i++)&#123; if(flag[i]) printf(&quot;%d &quot;,i); &#125; return 0;&#125; 割边对于割边其实与割点差不多只有判断条件变了一丢丢，也就是$low[v]&gt;dfn[u]$时边$$一定是割边。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2020-01-14T11:59:52.000Z","updated":"2020-02-15T04:09:06.300Z","comments":true,"path":"2020/01/14/扩展欧几里得/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"扩展欧几里得应用：计算逆元，解方程","text":"扩展欧几里得应用：计算逆元，解方程 证明方式：首先贝祖原理我大概就不解释了，直接照搬结论： $ax+by=(a,b)$;贝祖原理 $ax+by=(b,a \\% b) $;辗转相除法 假设解为$x1$,$y1$则有$a * x1+b * y1=(b,a\\%b)$ 由3式从右往左代替可得$b * x1+(a\\%b) * y1=(b,a\\%b)$;$b * x1 + (a-(a/b) * b) * y1 = (b,a\\%b)$;$a * y1 +b * (x1 - (a/b) * y1) = a * x + b * y$由上可知$x = y1,y = x1 - (a/b) * y1$。 对于上式，我们可以比较一下欧几里得求最大公约数的算法： $(a,b)=(b,a\\%b)$，一直到b等于0时结束递归，而当b等于0时的x=1,y=0; 然后又可以通过上面代数式4回退时计算出x与y的值！ 代码123456789101112ll x,y;ll ex_gcd(ll a,ll b)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll ans=ex_gcd(b,a%b); ll t=x; x=y; y=t-a/b * y; return ans;&#125; 应用逆元当求一个数字x对于p的逆元时，我们将其写成代数式将是如下形式： a * x=1%p; 对其进行化简可得a * x+y * p=1，已知x,p求a就好了化简成这样以后再看，简直就是扩展欧几里得板子！","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-02-07T13:16:21.688Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"欧拉筛欧拉函数打表简单版！","text":"欧拉筛欧拉函数打表简单版！ 欧拉筛证明：首先介绍一下算术基本原理：$x=p_1^{e1} p_2^{e_2} p_3^{e_3}$…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道任意一个合数都是由一个质数乘以一个其他数字组成！所以我们可以通过枚举一个质数和一个其他非$1$的正整数来判断来其他合数。但是为了提高其运算速率，我们想要对于任意一个合数仅判断一次时我们可以考虑，采用其最小的质数就行了，因为最小的质数只有一个且另一个非$1$正整数数仅用一次，那么任意一个合数只会判断一次咯 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;枚举非1正整数 if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123;//枚举素数 vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;//原因在下注明 &#125; &#125;&#125; break的原因是如果该循环继续下去的话(i*pri[j]的最小素数其实不是pri[j]，而是之前能被整除的那个素数，不break的话，一个合数的判断次数就会增加)","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2020-02-03T06:52:06.528Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://www.dream-ak.top/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.983Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；","text":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}