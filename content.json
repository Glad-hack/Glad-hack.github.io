{"meta":{"title":"孤独行者","subtitle":"心有不甘，却无以为继","description":"屡败屡战，终有一胜！","author":"无向秃","url":"https://www.dream-ak.top","root":"/"},"pages":[{"title":"折腾&自闭","date":"2019-11-26T11:57:02.000Z","updated":"2020-02-02T12:29:03.898Z","comments":true,"path":"tags/index.html","permalink":"https://www.dream-ak.top/tags/index.html","excerpt":"","text":""},{"title":"折腾&自闭","date":"2019-11-26T10:37:58.000Z","updated":"2020-02-02T12:35:36.651Z","comments":true,"path":"categories/index.html","permalink":"https://www.dream-ak.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"codeforces1307D","slug":"codeforces1307D","date":"2020-03-24T14:07:50.000Z","updated":"2020-03-25T09:02:16.814Z","comments":true,"path":"2020/03/24/codeforces1307D/","link":"","permalink":"https://www.dream-ak.top/2020/03/24/codeforces1307D/","excerpt":"不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。","text":"不得不说，这个最短路实在是有点精妙了，看题解差点没看懂。 题目链接题目大意已知一个连通图，每条边b(无向边)长度都为一，给我们一些点，求在这些点里面任意取两点之间建一条边(长度为一)后，使得从1到n的最短距离最长！求该两点。说白了就是加一条边后形成最长最短路，问在哪里加。 思路对于这一题，毫无疑问我们先要求出该1到其他所有点的最短距离$dis1$，和n到其他所有点的最短距离$dis$。那么最短路一定是$ ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$枚举$a$与$b$找到最大的数字$ans$就好了，但是由于$a$的数字太多了，$O(n^2)$肯定不行，所以这就是该题的最难点，如何找到这个最大值！首先我们可以假设 dis1[a]+dis[b] \\leq dis1[b]+dis[a]推导发现 dis1[a]-dis[a] \\leq dis1[b]-dis[b]也就是说只要左边的差值小于等于右边的差值，那么:$ans = min(dis1[a]+dis[b]+1,dis1[b]+dis[a]+1)$化简为$ans = dis1[a]+dis[b]+1$，可以发现首先对给我们的点按照$dis1[a]-dis[a]$从小到大排序后，开始从前往后枚举点，i为枚举的下标，$ans=max(x+dis[i]+1),x=max(x,dis1[x])$，$x$代表1到枚举过的点之间的最长距离。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;#include&lt;algorithm&gt;#include &lt;string.h&gt;#include&lt;vector&gt;#include &lt;queue&gt;using namespace std;const int N = 4e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int p[N];int head[N],tot=0,a[N],vis[N],dis1[N],dis[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void dij(int x)&#123; memset(dis,0x3f,sizeof(dis)); priority_queue&lt;pair&lt;int,int&gt; &gt;q; dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(dis[v]&gt;dis[u]+1)&#123; dis[v]=dis[u]+1; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k,t=0; scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k); for(i=1;i&lt;=k;i++) scanf(&quot;%d&quot;,&amp;a[++t]); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; dij(1); for(i=1;i&lt;=n;i++) dis1[i]=dis[i]; //printf(&quot;%dss\\n&quot;,dis1[n]); memset(vis,0,sizeof vis); dij(n); int sum=2e9+9; vector&lt;pair&lt;int,int&gt; &gt; dat; for(i=1;i&lt;=t;i++)&#123; dat.push_back(make_pair(dis1[a[i]]-dis[a[i]],a[i])); &#125; sort(dat.begin(),dat.end()); int mm = -2e9+9,best=0; for(i=0;i&lt;t;i++)&#123; int x = dat[i].second; best = max(best,mm+dis[x]); mm = max(mm,dis1[x]); &#125; printf(&quot;%d\\n&quot;,min(best+1,dis1[n])); //system(&quot;pause&quot;); return 0;&#125; 参考资料cf题解","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"Java的biginteger","slug":"Java的biginteger","date":"2020-03-21T12:31:29.000Z","updated":"2020-03-25T10:11:04.059Z","comments":true,"path":"2020/03/21/Java的biginteger/","link":"","permalink":"https://www.dream-ak.top/2020/03/21/Java%E7%9A%84biginteger/","excerpt":"哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧","text":"哈哈哈，终于开始Java的大数模拟，以前以为python大数好，不知为啥看了以后直接有点不相信他了(时间复杂度)，所以还是看Java吧 1.赋值：1BigInteger a=new BigInteger(&quot;1&quot;); 1BigInteger b=BigInteger.valueOf(1); 2.运算：① add(); 大整数相加123BigInteger a=new BigInteger(“23”); BigInteger b=new BigInteger(“34”); a. add(b); ②subtract(); 相减③multiply(); 相乘④divide(); 相除取整⑤remainder(); 取余⑥pow(); a.pow(b)=a^b⑦gcd(); 最大公约数⑧abs(); 绝对值⑨negate(); 取反数⑩mod(); a.mod(b)=a%b=a.remainder(b); 3.BigInteger构造函数：一般用到以下两种：BigInteger(String val);将指定字符串转换为十进制表示形式；BigInteger(String val,int radix);将指定基数的 BigInteger 的字符串表示形式转换为 BigInteger 4.基本常量：A=BigInteger.ONE 1B=BigInteger.TEN 10C=BigInteger.ZERO 0 n.compareTo(BigInteger.ZERO)==0 //相当于n==0 if(a[i].compareTo(n)&gt;=0 &amp;&amp;a[i].compareTo(m)&lt;=0) // a[i]&gt;=n &amp;&amp; a[i]&lt;=m 所有比较可以按照string比较规则来比较 参考资料biginteger","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"java对象复习","slug":"java对象复习","date":"2020-03-21T11:31:07.000Z","updated":"2020-03-21T12:49:44.059Z","comments":true,"path":"2020/03/21/java对象复习/","link":"","permalink":"https://www.dream-ak.top/2020/03/21/java%E5%AF%B9%E8%B1%A1%E5%A4%8D%E4%B9%A0/","excerpt":"完辽，没学习的欲望了，拖了几天的总结。","text":"完辽，没学习的欲望了，拖了几天的总结。 抽象类($abstract$)一个方法可以被覆写，那么如果当前类的全部方法都要被子类覆写的话，这个类我们就可以用抽象来代替。这个抽象的方法如果在它的子类里面不对该方法进行覆写的话，直接会报编译错误。那么抽象类的特点： 直接规范了子类的格式 抽象类无法实例化 子类的端口范围不能小于父类的端口范围 抽象方法不能用$private$修饰，因为抽象方法必须被子类重写，而$private$权限对于子类来说是不能访问的，所以就会产生矛盾。 抽象方法也不能用$static$修饰，如果用$static$修饰了，那么我们就可以直接通过类名调用了，而抽象方法压根没有主体，没有任何业务逻辑，这样就毫无意义了。 抽象类不能被$final$修饰，因为被修饰以后就不能被继承了。 接口(interface)当一个抽象类里面没有字段，全是抽象方法时，我们可以将这个类定义为接口。也就是说，接口里面不得有任何字段，所有方法都必须是抽象方法。也因为都是抽象，所以自动省略了$public abstract$修饰语句对于一个接口来说，可以同时继承多个接口。当用一个具体的类实现一个接口必须要用implement，举例：123456789101112131415161718192021interface Person &#123; void run(); String getName();//自动省略public abstract&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(this.name + &quot; run&quot;); &#125; @Override public String getName() &#123; return this.name; &#125;&#125; $default$方法接口之中可以定义$default$方法他的优点： 实现类里面可以不必覆写该方法，但是也可以覆写，方便修改接口。 举个例子12345678910111213141516171819202122232425public class Main &#123; public static void main(String[] args) &#123; Person p = new Student(&quot;Xiao Ming&quot;); p.run(); &#125;&#125;interface Person &#123; String getName(); default void run() &#123; System.out.println(getName() + &quot; run&quot;); &#125;&#125;class Student implements Person &#123; private String name; public Student(String name) &#123; this.name = name; &#125; public String getName() &#123; return this.name; &#125;&#125; $static$静态字段对于一个类的静态字段来说，他在这个字段里面只有一个共享空间，所有的实例都是用这一个变量。举例来看12345678910111213141516171819202122public class Main &#123; public static void main(String[] args) &#123; Person ming = new Person(&quot;Xiao Ming&quot;, 12); Person hong = new Person(&quot;Xiao Hong&quot;, 15); ming.number = 88; System.out.println(hong.number); hong.number = 99; System.out.println(ming.number); &#125;&#125;class Person &#123; public String name; public int age; public static int number; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125;&#125;可以发现修改了一个实例里的静态字段以后另外一个实例里的也改变了。 静态方法对于一个类里面的静态方法，可以直接通过类名.方法名进行运行，但是不可以通过this.类名访问。 接口的静态字段因为$interface$是一个纯抽象类，所以它不能定义实例字段。但是，$interface$是可以有静态字段的，并且静态字段必须为$final$类型。也因为全是$final$所以我们可以省略。 静态代码块对于一个静态代码块来说，当我们调用该类的时候会自动将静态代码块运行一次，且仅运行一次。当往后运行时就不会再调用了。一般使用这个功能时我们一般都是用来初始化的。 参考资料abstract廖雪峰","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java多态","slug":"Java多态","date":"2020-03-17T08:20:29.000Z","updated":"2020-03-17T09:27:20.735Z","comments":true,"path":"2020/03/17/Java多态/","link":"","permalink":"https://www.dream-ak.top/2020/03/17/Java%E5%A4%9A%E6%80%81/","excerpt":"这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧","text":"这个在上一篇，继承的最后一点说了一丢丢，当时还不知道就是多态，小尴尬，双倍快乐吧 多态覆写子类对于父类的方法进行的修改就叫覆写(Override)。覆写的方式是在子类中定义一个与父类方法名相同、返回值和参数一样的方法，就会变成覆写。1234## 多态多态是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。**当一个子类向上转型为父类以后，那么如果父类中有方法被该子类覆写了，调用该方法是会动态调用子类中覆写的方法。**通过这个性质，对于同一个类的同一个方法就会出现不同的实现方式。例如以下代码：public class Main { public static void main(String[] args){ Preson p1 = new Student(); Preson p2 = new Teacher(); p1.speak(); p2.speak(); p1.speak(); }}public class Preson{ public int age=10; void speak() { System.out.println(“父类”); }}public class Student extends Preson{ @Override//覆写 void speak(){ System.out.println(“学生”); }}public class Teacher extends Preson{ @Override//覆写 void speak(){ System.out.println(“老师”); }}```同样都是Person类执行同一个方法输出却是： 学生老师学生 在被子类覆写的方法里面如果想要运行父类方法，可以使用super关键字 final如果不想当前方法不被覆写，可以在方法名前加上final修饰符，就不会被重写了。如果类不想被继承的话，用它就会绝育了。变量用它后就不能修改了。 参考廖雪峰的java教程","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java继承","slug":"Java继承","date":"2020-03-17T06:42:03.000Z","updated":"2020-03-25T11:29:29.708Z","comments":true,"path":"2020/03/17/Java继承/","link":"","permalink":"https://www.dream-ak.top/2020/03/17/Java%E7%BB%A7%E6%89%BF/","excerpt":"对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西","text":"对于Java继承的存在意义的话，可以把代码规模减少，加快编码速度咯。正确的使用继承和多态就会出现很多不可思议的东西 Java继承$extends$继承是面向对象编程中非常强大的一种机制，它首先可以复用代码。当我们让$Student$从$Person$继承时，$Student$就获得了$Person$的所有功能，我们只需要为$Student$编写新增的功能。继承的关键字是extends12345678910111213141516171819202122public class Preson&#123; public int age=10; void speak() &#123; System.out.println(age); &#125;&#125;public class Student extends Preson//继承Preson类&#123; public String meat; void eat(String x)&#123; System.out.println(x); &#125;&#125;public class Main &#123; public static void main(String[] args)&#123; Student p = new Student(); p.age = 1; p.eat(&quot;Apple&quot;); p.speak(); &#125;&#125; 从以上代码可以看出，我们的$Student$类完全可以调用$Person$类的$speak()$方法，也可以自己写方法(譬如$eat()$方法)。在OOP的术语中，我们把$Person$称为超类（super class），父类（parent class），基类（base class），把$Student$称为子类（subclass），扩展类（extended class）。 继承树可以发现上面我们的代码$Person$类是没有$extends$的。不过要注意，他还是有父类，是$Object$类，在Java里面一切不定义extends的类都有一个Object父类但是Object没有父类。了解了这个以后我们来看一下继承树：Student \\rightarrow Preson \\rightarrow Object 注意：继承树的根是$Object$，上一个节点就是他的父类 $protected$继承一大特点：子类无法访问父类的$private$变量或$private$字段，这使得继承的作用被削弱了。为了让子类可以访问父类的字段，我们需要把$private$改为$protected$。原因可参考。因此，protected关键字可以把字段和方法的访问权限控制在继承树内部，一个protected字段和方法可以被其子类，以及子类的子类所访问。 构造方法如果父类不含有默认构造方法，那么我们需要使用$super(参数)$去自行构建。含有默认构造方法的话，会自动在构造的时候加一个$super()$。 转型对于Java的继承时我们可以对一个引用变量进行转化。用代码解释一下12345678910Student p0 =new Student();Preson p1 = new Preson();p1 = p0;``` 你会发现他成功了，而且这里的p1会丢失Student类的所有方法和属性，这就是**向上转型(子类向父类转换)**，如果要恢复的话必须要**向下转型(父类向子类转换)**。子类向父类转化是没啥条件的，毕竟父类本身就有子类的部分属性和方法，只不过是更加抽象而已，但是向下转型是有条件的(向下转型时需要判断它是不是要转化的子类类型，不是就会报错)### $instanceof$为了防止向下转型失败，这里提供了$instanceof$关键字来判断是否可以转型。$instanceof$返回$Boolean$值，true代表是后面的类型，false反之。Student p1 = new Student();Preson p2 = new Preson();if(p2 instanceof Student){ p1 = (Student) p2;}```这样就不会报错，防止转型失败 对于一次向上转型来说，对于父类来说，他可以使用父类的所有属性和方法，而子类中定义的所有的方法和属性是没有办法的，但是当子类中对父类方法进行覆写时他就会调用子类覆写后的方法(动态连接)，否则就是调用父类自身方法。 参考廖雪峰的Java教程","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"二分匹配最大独立集","slug":"二分匹配最大独立集","date":"2020-03-12T11:04:03.000Z","updated":"2020-03-12T12:22:08.098Z","comments":true,"path":"2020/03/12/二分匹配最大独立集/","link":"","permalink":"https://www.dream-ak.top/2020/03/12/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E6%9C%80%E5%A4%A7%E7%8B%AC%E7%AB%8B%E9%9B%86/","excerpt":"最近不知为啥老想玩，干脆来打编程游戏算了。。。","text":"最近不知为啥老想玩，干脆来打编程游戏算了。。。 二分匹配图二分图 定义：把一个图的顶点划分为两个不相交集 U 和V ，使得每一条边都分别连接U、V中的顶点。如果存在这样的划分，则此图为一个二分图。 另一个等价定义：一个图里面不含有奇数条边的环。 匹配：一个匹配是一个边的集合，其中任意两条边都没有公共点。匹配边：一个匹配中，集合里的边是匹配边。匹配点：一个匹配中，集合里的所有点都是匹配点未匹配边：图里的非匹配边未匹配点：图里的非匹配点 最大匹配：一个图里面所有的匹配中，所含匹配边数最大的匹配。 完美匹配：当一个图里面所有点都是匹配点时就是完美匹配，显然一个完美匹配就是最大匹配， 举例来说：如果在某一对男孩和女孩之间存在相连的边，就意味着他们彼此喜欢。是否可能让所有男孩和女孩两两配对，使得每对儿都互相喜欢呢？图论中，这就是完美匹配问题。如果换一个说法：最多有多少互相喜欢的男孩/女孩可以配对儿？这就是最大匹配问题。 匈牙利算法匈牙利算法：用来解决二分图最大匹配问题，时间复杂度$O(NM)$给与两个定义为匈牙利算法服务 交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。 增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。 思想 增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。 我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。 在这里我只写出了dfs版本的匈牙利算法 最大独立集(图里所有点-最大匹配点数)题目链接1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 5e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=0,vis[N],match[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;bool dfs(int x)&#123; vis[x]=1; for (int i = head[x]; ~i; i=ed[i].pre)&#123; int v =ed[i].id; if(!vis[v])&#123;//不在交替路 vis[v]=1;//放入交替路 if(match[v]==-1||dfs(match[v]))&#123;//短路操作，找到第一个非匹配点 match[v]=x;//对边进行交换。 match[x]=v; return true; &#125; &#125; &#125; return false;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; memset(match,-1,sizeof match); memset(head,-1,sizeof head); tot=0; for (i = 0; i &lt; n; i++)&#123; int u,v,t; scanf(&quot;%d: (%d)&quot;,&amp;u,&amp;t); for (j = 0; j &lt; t; j++)&#123; scanf(&quot;%d&quot;,&amp;v); add(u,v); &#125; &#125; int ans=0; for (int i = 0; i &lt; n; i++)&#123; if(match[i]==-1)&#123; memset(vis,0,sizeof (int)*n); if(dfs(i)) ans++; &#125; &#125; printf(&quot;%d\\n&quot;,n-ans); &#125;&#125; 补充定义最小覆盖数 ： 选取最少的点，使任意一条边至少有一个端点被选择最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。最大独立数(集)：选取最多的点，使任意所选两点均不相连。最大匹配数：最大匹配的匹配边的数目。 补充定理定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理）&lt;/br&gt;定理2：点数 - 最大匹配数= 最大独立数&lt;/br&gt;定理3：最小路径覆盖数 = 顶点数 - 最大匹配数 参考资料 oi维基 二分图总结 最大匹配 第3个里面有bfs版本的匈牙利以及两个版本的速率比较，内容详细，带图。不过最后定理错了，定理参考第二个。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"scanner类","slug":"scanner类","date":"2020-03-11T12:38:08.000Z","updated":"2020-03-12T08:54:15.947Z","comments":true,"path":"2020/03/11/scanner类/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/scanner%E7%B1%BB/","excerpt":"在做实验时候真的尴尬，我居然把Java的输入法给忘了，我记性真的是狗啊，写一篇博客来记吧。","text":"在做实验时候真的尴尬，我居然把Java的输入法给忘了，我记性真的是狗啊，写一篇博客来记吧。 Scanner首先Scanner对象属于java.util.*包里面构造Scanner类对象，附属于System.in保准输入流里面。 创建Scanner类对象创建Scanner类对象和创建其他对象过程是一样的。1Scanner in = new Scanner(System.in);每一次要输入值的话就调用这个$in$对象就完事了 Scanner对象的方法 in.next()输入字符串，从读到第一个有效字符开始，无效字符结束(包括空格，回车) in.nextLine()输入字符串，从键盘输入第一个字符开始，遇到回车结束 in.nextInt()输入单个整型数字 in.nextFloat输入单个单精度浮点型数字 in.nextDouble输入单个双精度浮点型数字 in.nextLong输入单个长整型数字 in.nextBoolean输入单个布尔型变量 在以上方法前加单词has后可检查后面数字扫描器的下一个标记是否为指定模式例如 in.hasNextInt()则为判断下一个数字是不是int型，是则返回true，否则false； in.close()关闭扫描器 参考文档java的API文档","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"单调栈","slug":"单调栈","date":"2020-03-11T08:05:33.000Z","updated":"2020-03-11T09:35:35.443Z","comments":true,"path":"2020/03/11/单调栈/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/%E5%8D%95%E8%B0%83%E6%A0%88/","excerpt":"这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！","text":"这个题目方法貌似很多，但是我在这里介绍一个方法目前已知最快的，利用单调栈！ 单调栈不懂请点击上面链接学习，我就不介绍什么是单调栈了。 题目可以到上面链接提交测试。 题意 已知一个长度为n的数组，在其中找一个长度为m的子序列，规则如下：首先第一个数字尽量大，然后第二个数字尽量大，第三个数字也要尽量大，等等…. 思想和解法首先按照题意来，我们先求第一个尽量大的值，为了让他能找到m个数字，我们先求1~n-m+1的最大值，那么这个值就会是第一个值，第二个值就是在第一个值的位置到n-m+2的最大值，依次类推，求出所有。可以发现这是一个暴力解法，复杂度是$O(n^2)$ 优化我们利用单调栈实现一个单调不上升栈，那么第一个数就是当栈顶下标到n-m+1时的栈底值。把栈底退出(这个操作用数组模拟吧)，第二个数就是栈顶下标到n-m+2的栈底值，以此类推！ 解释一下：因为单调不上升，那么栈底一定最大，且栈内数字顺序没变！符合题意，当把栈底退出以后第二个值就是栈底的下标到n-m+1的最大值咯。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1e5+5;int sta[N],a[N];int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int l = 0, r = 0; for(i=1;i&lt;=n-m;i++)&#123; while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--; sta[++r] = a[i]; &#125; for(i=n-m+1;i&lt;=n;i++)&#123; while(l&lt;r&amp;&amp;a[i]&gt;sta[r]) r--; sta[++r] = a[i]; l++; printf(&quot;%d%c&quot;,sta[l],l==m?&apos;\\n&apos;:&apos; &apos;); &#125; &#125;&#125; 相同题型双倍快乐,单调栈的大于改小于就完事了，数据很大，卡O(nlogn)!.秃头快乐","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"Java修饰符","slug":"Java修饰符","date":"2020-03-11T03:03:45.000Z","updated":"2020-03-11T12:18:05.654Z","comments":true,"path":"2020/03/11/Java修饰符/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/Java%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。","text":"听课听了一会，发现Java对于修饰符的用途过多，先来了解一下。写在前面：本文来自对于这篇文章文章的理解 修饰符修饰符分为一下两种： 访问修饰符 非访问修饰符 访问控制修饰符Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 修饰符 当前类 同一包 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N(解释请看) N default Y Y Y N N private Y N N N N 非访问控制修饰符static 静态变量：static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 静态方法：static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 final final 变量final 表示”最后的、最终的”含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。 实践部分：当定义final以后再对final变量修改值编译器会报错！ final 方法父类中的 final 方法可以被子类继承，但是不能被子类重写。声明 final 方法的主要目的是防止该方法的内容被修改。 abstract抽象类 抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。 一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。 抽象类可以包含抽象方法和非抽象方法。 抽象方法 抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。 抽象方法不能被声明成 final 和 static。 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。 未完待续transient 修饰符volatile 修饰符synchronized 修饰符","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"Java对象","slug":"Java对象","date":"2020-03-11T02:11:29.000Z","updated":"2020-03-23T02:12:28.103Z","comments":true,"path":"2020/03/11/Java对象/","link":"","permalink":"https://www.dream-ak.top/2020/03/11/Java%E5%AF%B9%E8%B1%A1/","excerpt":"听课","text":"听课 面向对象基础Java面向对象的基本组成 Java类及类的成员：属性、方法、构造器；代码块、内部类 面向对象三大特征：封装、继承、多态(抽象) 关键字：this、super、static、final、abstract、interface、package、import… 类和对象：类是对一类事物共同特点的统一，而对象就是类的实例。(就像水果和苹果一样)比如：手机需要充电，手机可以打电话，等等都是这个手机就是一个类，华为手机就是一个对象。 类的代码定义格式12345678910[修饰符] class 类名 [父类名] [implements 接口名] &#123; //类体,包括属性和方法 //属性 [修饰符] 数据类型 变量名 [ = 值] //方法 [修饰符] [返回值] 方法名([参数类型 参数名1]，[参数类型 参数名2]...)&#123; 方法体 return 返回值 &#125;&#125; 创建对象一个类不写构造方法时，类会默认一个public Preson()构造方法1类名 对象名 = new 类名(); 在创建对象实例时就把内部字段全部初始化为合适的值时我们需要自定义构造方法。 构造方法在创建类的时候我们同时定义一个方法，同时传入要定义的值，完成初始化123456789101112131415161718public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(18); Preson q = new Preson(28); p.speak(); q.speak(); &#125;&#125;class Preson&#123; //属性 private int age; public preson(int age)&#123; this.age = age; &#125; public void speak()&#123; System.out.println(this.age); &#125;&#125; 以上就可以自定义构造方法了，但是同时也会废弃默认的Preson p = new Preson()构造方法，想要保存的话，我们可以写两个构造方法。如下1类名 对象名 = new 类名(); 在创建对象实例时就把内部字段全部初始化为合适的值时我们需要自定义构造方法。 构造方法在创建类的时候我们同时定义一个方法，同时传入要定义的值，完成初始化123456789101112131415161718192021public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(18); Preson q = new Preson(); p.speak(); q.speak(); &#125;&#125;class Preson&#123; //属性 private int age = -18; public Preson(int age)&#123; this.age = age; &#125; public Preson()&#123; &#125; public void speak()&#123; System.out.println(this.age); &#125;&#125; 方法重载在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。就像如下代码1234567891011121314151617181920212223public class Main &#123; public static void main(String[] args)&#123; Preson p = new Preson(); Preson q = new Preson(); p.speak(18); q.speak(&quot;小明&quot;); p.speak(); &#125;&#125;class Preson&#123; //属性 public int age = 108; public String name; public void speak(int age)&#123; System.out.println(age); &#125; public void speak(String name)&#123; System.out.println(name); &#125; public void speak()&#123; System.out.println(age+name); &#125;&#125; speak方法名就出现了三次，只是各自的参数不同，这就叫方法重载。它存在的意义是让功能类似的方法名字相同，利于记忆，调用更简单。 对于一个变量来说，如果他定义在类里面会自动赋初值0，存储在堆里面，如果在方法体里面定义的话，必须手动赋值，且存储在栈里面","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"蓝桥杯校赛第九题","slug":"蓝桥杯校赛第九题","date":"2020-03-10T12:24:09.000Z","updated":"2020-03-10T13:00:42.768Z","comments":true,"path":"2020/03/10/蓝桥杯校赛第九题/","link":"","permalink":"https://www.dream-ak.top/2020/03/10/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A0%A1%E8%B5%9B%E7%AC%AC%E4%B9%9D%E9%A2%98/","excerpt":"去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。","text":"去年蓝桥杯炸了，如果今天省赛，我可能又炸了。。。 题目是我凭记忆复现的，链接在这里第九题 思路：数据很小，所以第一想法直接把答案全部按照深度优先搜索跑出来，保存下来，然后再交，O(1)输出！深度优先搜索写法：因为每一个数字只与前两个数字有关，那么我们只要每计算一个答案就把这两个数字的答案记录下来，以后在遇到这两个数字就直接使用就好了。(可以学一下记忆化搜索) 实现使用vis二维数组来保存前两个数字，如果vis[x][y]为0的话就没有用过，为0直接就加上就好了12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;#include&lt;stdlib.h&gt;//#include&lt;windows.h&gt;using namespace std;const int N = 1005;int vis[N][N],a[N];FILE *fp1 = fopen(&quot;D://program//code//acm//oj//testin.txt&quot;,&quot;w+&quot;);FILE *fp2 = fopen(&quot;D://program//code//acm//oj//testout.txt&quot;,&quot;w+&quot;);int dfs(int x,int y)&#123; int ans=0;//求前面两个数字为能产生的数列数量 for(int i=1;i&lt;abs(y-x);i++)&#123; if(vis[y][i]==0)&#123;//没有用过则计算出答案并保存 vis[y][i]=dfs(y,i);//计算呢前前一个数字是i前面第二个数字是y的数列数。 ans=(ans+vis[y][i])%10000; &#125; else ans=(ans+vis[y][i])%10000; &#125; return ans+1;//返回数列值并加上当前值&#125;int main()&#123; int i,j,k,n,m; for(i=1;i&lt;=1000;i++)&#123;//计算以i开始的数列数量 int ans=0; for(j=1;j&lt;=i;j++)&#123; if(vis[i][j]==0)&#123; vis[i][j]=dfs(i,j); ans=(ans+vis[i][j])%10000; &#125; else&#123; ans=(ans+vis[i][j])%10000; &#125; &#125; printf(&quot;%d\\n&quot;,ans); &#125; system(&quot;pause&quot;); return 0;&#125;上面时间复杂度为因为一个数字开始的话数量与前两个数字有关所以复杂度为O($n^2$)，n个数字是O($n^3$)打出所有答案后复制到另一个程序输出就好了。 AC代码12345678#include&lt;stdio.h&gt;int a[1006]=&#123;1,2,4,7,14,26,53,106,220,452,946,1967,4128,8638,8144,8068,26,8127,3542,3277,3278,7643,5433,5774,8217,4846,687,3097,6887,3556,4840,3454,5378,722,2230,767,1447,1839,4776,7618,7831,6222,5236,7802,5696,1835,1102,9537,1605,1227,3034,2159,1613,6811,3941,6794,5960,4903,75,2158,349,4258,5189,4717,2894,4193,2890,258,2928,6125,2913,1482,8419,7244,1652,3440,2138,9272,4714,3333,3543,8834,6763,9180,1803,4631,6307,9056,3170,8339,6213,1176,3258,272,4257,1893,8020,3682,9531,6961,4145,3086,3455,9057,1346,5768,6907,247,2450,4732,8653,8229,842,3346,9671,7106,3561,4952,9539,1791,6208,6083,8838,7474,6854,198,7300,8219,5912,8884,3976,9650,4821,7317,9720,5572,3834,6326,2281,34,8409,28,445,8155,9846,9944,2504,3954,1639,7243,8502,6926,1609,7449,3769,5695,6683,7531,6275,5827,6184,1982,736,9718,2777,7688,6626,7456,961,5556,7573,6886,4543,3957,2859,4666,9795,305,9052,5350,9827,5445,6970,2599,7566,2848,2987,5179,1537,2392,6375,9621,7376,3301,1357,6545,7838,9390,4284,2631,1814,2566,7666,1110,5694,7595,5000,1290,4735,5994,9401,6475,9012,5877,2867,7912,3509,5505,885,7490,5622,4374,8721,5134,8788,5430,3869,9852,5762,75,5964,262,5565,1599,7525,5388,8612,1143,7938,7580,2953,7901,5629,1456,9852,5216,965,3739,7879,1212,9029,9263,9609,1926,8151,1997,6298,5125,5715,4864,3852,604,7652,313,6248,4077,3875,3816,7046,9525,3798,6959,9366,2216,4463,6546,6367,614,9477,3176,4098,7162,7535,4696,749,2686,8212,9050,255,1389,287,1086,9414,9897,2293,31,9121,4682,7084,8951,834,1051,2236,3712,6426,8642,185,785,8162,6015,658,8923,5741,2551,7629,2095,8882,7695,5629,8684,5116,6362,7701,9441,9403,1108,4395,5688,9466,953,9191,4967,7236,6020,3465,8165,872,4530,3353,7859,1422,1504,6366,126,1246,1530,1777,8970,4590,2195,6920,9086,689,2163,6035,4961,2055,7699,4121,3971,1824,3707,4405,854,6088,6971,1679,1779,7097,5696,2449,2104,3264,796,8595,6183,26,5597,7295,5926,9039,4550,9601,5959,3244,7451,5641,2343,6587,3755,4361,3890,446,8187,1979,7000,7094,8658,1647,6090,8332,4407,4570,2340,3057,5029,5424,2736,4844,2771,5782,5912,3745,2504,2782,7247,1393,5403,7175,9903,1723,7600,7021,4566,9778,5188,46,8542,7915,5043,4983,519,480,8199,1141,73,9316,6248,966,3218,6614,6974,5078,9775,7263,6263,7267,1947,5357,286,674,3876,1985,4731,1850,512,1493,5310,5443,4183,5963,8642,1389,6320,4264,9565,7348,4378,6192,1300,3393,4794,8323,6063,9651,9368,7899,9053,4933,5140,5604,9114,9299,7603,2485,884,7313,4139,9883,1405,9843,7419,1483,2031,8610,4150,3313,6257,3790,1688,994,1357,9660,583,5735,1548,7156,9678,8047,3617,9611,7966,7764,5177,7716,4206,7985,6989,6318,5854,8292,9639,687,370,3252,7104,5813,758,8219,3809,2506,3605,9340,3559,4118,4757,8229,4258,944,1596,4940,622,5832,1270,6948,1744,1125,7895,9348,7601,7426,1975,9611,3722,4143,4979,7904,3221,3817,5755,1798,6549,3463,3190,201,6894,6209,3488,670,7643,7020,6164,5583,5036,6309,8644,7961,3465,7795,1486,4535,3111,5252,4049,4253,7515,1517,6148,2438,1296,8826,7924,7761,9126,6951,7110,7549,1170,8533,793,1633,6451,6261,5887,8694,6447,8993,6398,1289,2925,2362,3935,6744,1358,1743,3937,9942,3696,1601,8295,3086,2595,9554,8566,1465,2109,3474,3950,9216,8948,2020,3536,943,4934,8377,6171,1243,3525,259,3001,4205,4548,4754,2365,8630,4690,7872,5131,3995,2672,728,6532,9785,9379,5865,4774,6660,3721,4451,9085,4771,8008,857,9737,5630,4040,3106,5997,4152,8542,3992,3294,5064,2656,5247,635,1521,3026,1502,9396,2171,7188,2425,9758,2640,8648,9454,274,9471,8972,9301,911,6023,4155,126,7802,2948,5675,6313,69,1374,9925,3685,6901,432,1884,4803,8173,9638,3626,695,4286,3836,8670,8834,1444,5187,6281,2482,8801,7656,9066,5138,5160,9857,906,5235,7243,5281,5103,5826,5023,3637,5607,1204,5697,3422,1192,8753,6087,2083,3256,8201,9853,1886,3953,4732,7351,6387,9148,2299,4843,3891,3572,874,9873,1235,7323,8860,3439,113,5132,6521,1234,7427,4062,1342,2480,641,8802,9788,5336,3649,1301,3268,749,1628,9202,2689,3284,9170,5252,1577,1705,5640,2185,2252,4943,271,5117,8699,2743,8221,2119,3851,701,2740,4247,7037,9764,4445,5848,6135,6166,5328,2584,1131,3005,8817,2783,7749,6112,5567,9688,2549,7929,8650,60,1896,3998,7345,3352,8990,1143,873,1191,5821,9485,5249,3086,8016,9319,4139,3566,8871,7528,7873,4117,1085,7064,8222,5947,4447,1326,5206,12,9703,5711,3951,219,6966,3168,2372,9603,9092,1904,1010,2704,2106,7568,3410,296,6825,9781,637,4465,7953,6861,2142,2035,9743,1921,3051,7424,7112,7676,5245,9531,2284,4498,6423,6977,3106,1367,5696,2003,1291,3025,76,3147,9094,4580,5097,7390,8637,5853,359,3153,4957,6635,5721,3353,2266,3481,7432,3020,7330,1172,5285,1525,2928,5331,8856,2163,5169,1465,4439,1876,7446,2192,5577,726,6599,352,3645,7733,8331,5447,8017,5017,7287,6602,7248,6323,4195,9617,2263,4013,450,4073,6131,3569,9019,1858,9827,8118,4972,7422,9666,5760,9213,2817,7952,3948,8683,3645,6402,3264,1919,9276,2519,190,766,8940,3413,2644,8048,83,9724,7009,3777,9663,2483,5752,4578,8951,5902,2170,9967,894,8556,6049,7254,2746,8962,8317,6848,767,7907,1028,9458,6881,4978,6717,8210,3835,1064,7434,746,9449&#125;;int main()&#123; int x; while(scanf(&quot;%d&quot;,&amp;x)==1)&#123; printf(&quot;%d\\n&quot;,a[x-1]); &#125;&#125; 我的小结emmmm，手机浸水，一边比赛一边晾手机果然写出bug了，第7题血亏！还是不能飘啊。","categories":[{"name":"思维","slug":"思维","permalink":"https://www.dream-ak.top/categories/%E6%80%9D%E7%BB%B4/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"数据库操作","slug":"数据库操作","date":"2020-03-10T01:35:16.000Z","updated":"2020-03-12T08:55:05.070Z","comments":true,"path":"2020/03/10/数据库操作/","link":"","permalink":"https://www.dream-ak.top/2020/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/","excerpt":"最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令","text":"最近搭建了一个服务器，需要管理数据库了，嗯，其实还有是我数据库也开了课，就一起学吧。这一片单纯介绍数据库常见常用命令 数据库常用命令连接MySQL mysql -h 主机地址 -u 用户名 -p 用户密码如果是本地登录则不需要-h的主机地址如下是Linux服务器打开方式，本地登录没有hwindows打开方式：先要进入如图这个目录，不进入的话该命令会无效的，我就不细说，大家应该都是一个目录里面。退出MySQL输入exit然后回车就完事了修改密码退出MySQL以后在同一个目录使用如下命令 mysqlsdmin -u root -p密码 password-p密码那里是连起来的，直接回车如图操作命令首先写在前面： 对于一个数据库操作命令都是以一个英文分号”;”结束。 如果你输入命令错误，可以选择先输入一个分号，让他执行错误命令，重新输入。 库的命令 命令 含义 create database name 创建数据库 use database name 选择数据库 show databases 显示所有数据库 drop database name 直接删除数据库，不提醒 具体操作如下： 数据类型这个由于太多我只做简单常用介绍，如想详细了解，点击。 类型 字节长度 含义 int 4字节 整数 bigint 8字节 整数 double 8字节 双精度浮点型 date 3字节 日期值(格式：YYYY:MM:DD) time 3字节 时间值(HH:MM:SS) year 1字节 年份值(YYYY) datetime 8 混合日期和时间值(YYYY:MM::DD HH:MM:SS) char 0-255字节 定长字符串 varchar 0-65535字节 变长字符串 表的命令 命令 含义 create table name(变量 数据类型) 创建表 drop table name 删除表 show tables 查看当前选定数据库包含表格 insert into name(变量名) values (变量值) 在name表格插入数据 select (变量名或者*) from name 从name表格中查看变量名的所有数据(*代表查看所有数据)","categories":[{"name":"数据库","slug":"数据库","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://www.dream-ak.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"python文件操作","slug":"python文件操作","date":"2020-03-06T01:41:54.000Z","updated":"2020-03-21T12:46:06.811Z","comments":true,"path":"2020/03/06/python文件操作/","link":"","permalink":"https://www.dream-ak.top/2020/03/06/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。","text":"最近刷题刷的一堆exe文件，实在太多了，我就写了一个脚本操作，用来删除一个文件目录下的所有exe文件，嗯，因为是电脑，所以删错了不管，用的时候再小心吧。 文件的一些函数 函数 参数 功能 os.getcwd() 无参数 返回当前工作目录 os.chdir() 地址 修改当前工作目录到指定文件地址 os.listdir() 地址 查看当前目录下所有文件 os.makedirs() 新建文件夹名称 新建文件夹 os.remove(path) 路径 删除文件 os.rmdir(path) 路径 删除空目录，非空目录报错 os.path.join() 要添加的文件路径(字符串) 构建一个在所有系统都能运行的文件路径 os.path.abspath() 路径(可以为相对路径’..’，’.’) 返回绝对路径 os.path.relpath(path,start) start：一个路径，path：路径 返回从start到path的相对路径，没有start参数时默认当前工作目录 os.path.dirname() 路径 返回最后一个斜杠以前的所有字符串 os.path.basename() 路径 返回最后一个斜杠以后的字符串 os.path.getsize(path) 路径 返回该路径下指定文件的字节数 os.path.exists(path) 路径 返回bool值表示路径是否存在 os.path.isdir(path) 路径 返回bool值表示路径是否存在且为目录 os.path.isfile(path) 路径 返回bool值表示路径是否存在且为文件 os.path.rename(str1,str2) 俩路径 重命名str1文件位str2文件 f = open(path,x) 文件路径,x为赋予权限 打开文件，且f为文件引用 f.read() 无参数 返回一个字符串表示文件内容 f.readline 无参数 返回一个list表示文件每一行 f.close 无参数 关闭文件 作死之旅这是我对于py做的第一个小脚本，使用了类与对象，各种文件操作，学习了一波迭代器，生成器，和异常处理，差不多是对于py的一次小应用了。 对于这个脚本的话我这里功能是： 能删除指定后缀文件，只要后缀相同一定删除，无情^-^ 能像linux一样操作但是操作指令不同，支持绝对路径与相对路径的输入 可以随时查看当前目录的文件 随时退出 解决方案： 递归遍历判断是否为目录 用os.path.abspath把相对路径转成绝对路径 os.listdir break 总结：我感觉这个删除脚本十分好用，反正我喜欢，还增加了我对于异常处理的能力，其实是学习了一下，对于迭代器的使用，（一开始不想要递归，毕竟它代价有点大，就学了一下，发现我用不上，菜了）对于文件命令的操作，字符串的处理方式也得到了锻炼，对于py的脚本以后就要开始写其他的了（例如excel操作） 代码块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osclass Flie(object): def list(self): print(&quot;当前工作目录：&quot;+os.getcwd()) file = os.listdir(os.getcwd()) print(&apos;\\n&apos;.join(file)) pass def goto(self, path): os.chdir(path) pass def pathname(self,name): print(&quot;请输入你将要进入的文件目录&quot;) names = name.split(&quot;\\\\&quot;) x = &apos;\\\\&apos;.join(names) pathnames = os.path.join(x) if os.path.isdir(pathnames): return pathnames pass else : print(&quot;不存在该目录，请重新尝试^-^&quot;) pass def erease(self, pathnam,format): #os.chdir(pathname) pathname=os.path.abspath(pathnam) for i in os.listdir(pathname): print(pathname) pathname1 = os.path.join(pathname,i) if os.path.isdir(pathname1): self.erease(pathname1,format) else: file1 = i.split(&apos;.&apos;) if file1[-1]==format: try: os.remove(pathname1) except FileNotFoundError as identifier: print(&quot;当前错误删除路径&quot;+os.path.join(os.getcwd(),pathname1))if __name__ == &quot;__main__&quot;: print(&quot;准备完毕，请输入：&quot;) os.chdir(&apos;C:\\\\&apos;) print(os.getcwd()) x = Flie() flag = True while flag: operate = input().split() op = operate[0] if op == &quot;goto&quot;: name = x.pathname(str(operate[1])) try: x.goto(name) except TypeError as identifier: continue elif op == &quot;del&quot;: name = x.pathname(str(operate[1])) print(os.path.getsize(name)) x.erease(name,operate[2]) pass elif op == &quot;cls&quot;: os.system(&apos;cls&apos;) print(&quot;当前文件位置：&quot;+os.getcwd()) elif op == &quot;list&quot;: x.list() elif op == &quot;help&quot;: print(&quot;goto + path：表示进入路径&quot;) print(&quot;del + path + str：表示删除该路径下某个特定的文件后缀&quot;) print(&quot;cls：清屏&quot;) print(&quot;list：打印整个目录下文件&quot;) print(&quot;quit：程序退出&quot;) elif op == &quot;quit&quot;: break else : print(&quot;输入格式错误，请输入正确格式或输入help寻求帮助&quot;) pass 有漏洞可以提出来，我已经成功的删除了我刷题时产生的所有exe文件了，嘿嘿嘿。有个缺陷是有可能进不了文件而报错，我是没有去弄这个异常的，有大佬经过时可否提点我一下？","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"最短路径图","slug":"1320B","date":"2020-03-04T10:46:38.000Z","updated":"2020-03-04T14:22:30.815Z","comments":true,"path":"2020/03/04/1320B/","link":"","permalink":"https://www.dream-ak.top/2020/03/04/1320B/","excerpt":"题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！","text":"题意给我们一个图和一条路径询问从当前点到下一个点是否为最短路径上的一个点！ 题目链接思路和解法 首先其余点到达定点的最短路怎么求:我们直接反向建图，求定点到每个点的最短路就是该点到达定点的最短路。最短路径保存我给一个思想类似于求最短路的条数的板子，直接套上最短路条数板子，把记录最短路条数的数组改为记录这一个点的上一个点(原图的下一个节点)就好了。 如果不会最短路条数的板子，看这里 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N=2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N],ed1[N];int head[N],tot,a[N],vis[N],flag[N],dis[N],head1[N],tot1;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=1; head[u]=tot;&#125;void add1(int u,int v)&#123; ed1[++tot1].pre=head1[u]; ed1[tot1].id=v; head1[u]=tot1;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij(int x)&#123; memset(dis,0x3f,sizeof dis); dis[x]=0; q.push(make_pair(0,x)); while(q.size())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; int i; for(i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].id,w=1; if(dis[v]&gt;dis[u]+1)&#123; head1[v]=-1;//清空该节点的下一个节点 add1(v,u);//建最短路图 dis[v]=dis[u]+1; q.push(make_pair(-dis[v],v)); &#125; else if(dis[v]==dis[u]+1) add1(v,u);//建最短路图 &#125; &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; int u,v; memset(head,-1,sizeof head); memset(head1,-1,sizeof head1); memset(vis,0,sizeof vis); tot=1; tot1=1; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(v,u); &#125; int len; scanf(&quot;%d&quot;,&amp;len); for(i=1;i&lt;=len;i++) scanf(&quot;%d&quot;,&amp;a[i]); dij(a[len]); int mi=0,ma=0; for(i=1;i&lt;len;i++)&#123; int flag1=1; mi++; for(j=head1[a[i]];~j;j=ed1[j].pre)&#123; //printf(&quot;%dvvvv\\n&quot;,ed[j].id); if(ed1[j].id==a[i+1]) mi--; else if(flag1) ma++,flag1=0; &#125; &#125;//统计答案 printf(&quot;%d %d\\n&quot;,mi,ma); &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"交互1305D","slug":"1305D","date":"2020-03-04T10:41:03.000Z","updated":"2020-03-04T14:22:27.833Z","comments":true,"path":"2020/03/04/1305D/","link":"","permalink":"https://www.dream-ak.top/2020/03/04/1305D/","excerpt":"第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！","text":"第一次做交互题，题目很简单，就是不熟悉流程，搞得我还蛮兴奋。每一次提问两个点返回他们的LCA，最后能得到树的根，询问次数必须小于n/2！ 题目链接思想和题解正解：每一次提问叶子节点，求出它们的LCA(w)。 如果w == u或者w == v，则w为树的根。因为相等的话，那么证明两个点在同一条路径上面，且两点的度都为1，而$u \\rightarrow v$ 本身就要消耗一个度，所以w是没有父节点的，w直接为根节点。 不相等则把该点从图上删掉且把该点的父节点的度减一不相等，证明两点不在同一路径，那么他们存在祖先节点，则这两点删掉(不是根留他何用)然后父节点度减一原因是因为他的一个子节点删掉了，父节点度肯定减一呗。 上面的度可以理解为可能为根节点的父节点个数(仅限此题可以这样理解，具体情况，具体分析) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot,w;void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;int vis[N];//表示可能为根节点的父节点个数，直接说是度了。void dfs(int x)&#123; // printf(&quot;%d\\n&quot;,head[x]); for(int i=head[x];i;i=ed[i].pre)&#123; vis[ed[i].id]--; &#125;&#125;int main()&#123; int t,n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; for(i=1;i&lt;n;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); vis[u]++,vis[v]++; &#125; int u=0,v=0; for(j=1;j&lt;=n/2;j++)&#123; //printf(&quot;%d\\n&quot;,j); for(i=1;i&lt;=n;i++)&#123; if(vis[i]==1&amp;&amp;u==0)&#123; u=i; &#125; else if(vis[i]==1)&#123; v=i; break; &#125; &#125; printf(&quot;? %d %d\\n&quot;,u,v); fflush(stdout); scanf(&quot;%d&quot;,&amp;w); if(w==u||w==v)&#123; printf(&quot;! %d\\n&quot;,w); fflush(stdout); return 0; &#125; else&#123; vis[u]=-1,vis[v]=-1;//-1表示删除该点 dfs(u); dfs(v); u=0; &#125; &#125; for(i=1;i&lt;=n;i++)&#123; if(vis[i]&gt;=0)&#123; printf(&quot;! %d\\n&quot;,i); fflush(stdout); &#125; &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"求等差数列的值","slug":"求等差数列的值","date":"2020-03-02T12:09:21.000Z","updated":"2020-03-02T12:31:39.413Z","comments":true,"path":"2020/03/02/求等差数列的值/","link":"","permalink":"https://www.dream-ak.top/2020/03/02/%E6%B1%82%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E7%9A%84%E5%80%BC/","excerpt":"在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值","text":"在不用乘除，if,while,for 三目运算符的情况下求从1开始的等差数列的值 题目链接对于这个题目的限制来看，他成功的把迭代方法给禁了！ 解决方案利用公差为1和短路的原理递归答案递归的话，很容易想，唯独就是不允许if来特判结束条件，在这里我们可以看到，最后一个值是0，那么我们就可以发现， 如果为0的话，返回0，不是0的话就继续递归 那么我们就可以看到我们可以用短路，把后面不是0的部分用短路解决！如果前面是0则短路后面部分，让它不运行。否则就运行123class Solution: def sumNums(self, n: int) -&gt; int: return n and n+self.sumNums(n-1)由于if 和while被禁了。。。快速加无法实现，pow函数与**不知道实现方法就不写了（如果里面有乘法或除法就丢脸了）","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/tags/leetcode/"}]},{"title":"java程序基础","slug":"java","date":"2020-03-02T02:28:49.000Z","updated":"2020-03-22T04:41:12.413Z","comments":true,"path":"2020/03/02/java/","link":"","permalink":"https://www.dream-ak.top/2020/03/02/java/","excerpt":"突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。","text":"突然学校开学了，那我就勉为其难开始学习一波Java吧，这里还是写一些对于廖雪峰大神博客的理解和课堂的理解。 Java程序基础基本单位:Class首先对于Java来说他的基本单位是$Class$而不像C语言基本单位是函数！对于每一个类他的定义一般是：123456789public class Hello&#123; public static void main()&#123;//方法名是main() system.out.println()//system.out.print+line整行输出的意思 //单行注释 /* 多行注释 */ &#125;&#125;这里的public是访问修饰符，表示Class公开 Class的命名规则Class的命名规则与py的Class一样，使用大驼峰规则： HelloNoteBookVRPlayer 方法的命名规则方法名命名规则是小驼峰： maingoodMorningplayVR 变量 直接与C语言相比，Java的int没有变化，long long变成long，用法不变 java整数运算没有误差，与C语言没有什么变化 java浮点数运算有误差，在比较的时候需要表示在一个容错值之中！ java布尔运算的变量名为boolean，且逻辑运算和三元运算符也有相同用法 java字符中和C语言字符差不多，但是由于用的Unicode编码，所以空间占两个字节，显示Unicode编码直接将char放到int就好了，由编码转Unicode编码则加上’\\u’ java字符串中和py的string用法相似，都是不可变变量且多行输出用法一样system.out.print(“””…”””); java数组操作，对于定义一个int[] ns= new int[5]；这样就是定义一个ns数组，可以用ns.length获取数组长度 数组操作遍历 从数组下标从0到lenth-1挨个访问 123456789public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int i=0; i&lt;ns.length; i++) &#123; int n = ns[i]; System.out.println(n); &#125; &#125;&#125; 用for each迭代答案 12345678public class Main &#123; public static void main(String[] args) &#123; int[] ns = &#123; 1, 4, 9, 16, 25 &#125;; for (int n : ns) &#123; System.out.println(n); &#125; &#125;&#125; 排序Arrays.sort(数组名称)按升序排序 命令行参数对于java来说，以main函数为程序入口，main(string[] args)这里的string[]是传入命令行参数的入口来看代码12345678910public class Main &#123; public static void main(String[] args) &#123; for (String arg : args) &#123; if (&quot;-version&quot;.equals(arg)) &#123; System.out.println(&quot;v 1.0&quot;); break; &#125; &#125; &#125;&#125; 操作方法：首先我们先编译 javac 待编译文件 java 文件名 传入参数","categories":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://www.dream-ak.top/tags/Java/"}]},{"title":"两数相加","slug":"两数相加","date":"2020-03-01T03:43:51.000Z","updated":"2020-03-02T03:48:34.320Z","comments":true,"path":"2020/03/01/两数相加/","link":"","permalink":"https://www.dream-ak.top/2020/03/01/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","excerpt":"第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！","text":"第二题，说句实在的，用py模拟的链表，因为不熟悉力扣的测试样例wa了n久，难顶！对于这一题，说实在的没有啥算法可言，就是暴力模拟，我第一次了解py的链表，感觉还是值得一刷，就写了一下，解法就过了，没说的，竖式相加，逢十进位123456789101112131415161718192021222324252627282930313233343536# Definition for singly-linked list.定义单链表的意思# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: key=0 pre = ListNode(0) ans = pre while l1!=None and l2!=None: x = ((l1.val+l2.val+key)%10) cur = ListNode(x) pre.next=cur pre=cur key = (l1.val+l2.val+key)//10 l1,l2=l1.next,l2.next while(l1!=None): x = ((l1.val+key)%10) key = (l1.val+key)//10 cur = ListNode(x) pre.next=cur pre=cur l1=l1.next while(l2!=None): x = ((l2.val+key)%10) key = (l2.val+key)//10 cur = ListNode(x) pre.next=cur pre=cur l2=l2.next if key!=0: cur = ListNode(key) pre.next=cur return ans.next","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/tags/leetcode/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-02-29T14:22:23.000Z","updated":"2020-02-29T15:08:11.588Z","comments":true,"path":"2020/02/29/两数之和/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"leetcode计划开始了，以后每天刷1道力扣题打卡，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。","text":"leetcode计划开始了，以后每天刷1道力扣题打卡，尽量不用ACM本命C与C++(除非实在不会用java或python来写了)。 第一题：两数之和题意：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。对于这个题目，因为简单，所以这里提供的解法有如下几种 暴力$O(n*n)$每一次枚举一个i然后从i开始往后找另一个值与之相加为x的数字，找到则直接返回下标。 字典映射对于每一个数字由于只有两个$(x,y)$数字，那么我们假设其中一个数字为$x$，则另一个数字一定是$target-x$通过这个特性，我们可以选择建立一个dict{x:i},x为差值，i为下标，我们每一次假设一个x时则查看前面是否出现过target-x，出现了直接返回就好了，没出现则加入字典。时间复杂度$O(n*log_2n)$字典的查询自带$log_2$32ms12345678910class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: num=&#123;&#125; pos=0 for i in nums: x = target - i if num.get(x,-1)!=-1: return [num[x],pos] num[i]=pos pos+=1 二分建立一个$list$存储大小与下标，然后对大小从小到大排序，接下来用二分查找向后查找$target-x$时间复杂度$n*log_2 n$54ms123456789101112131415161718class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: lenth=len(nums) a=[[nums[pos],pos] for pos in range(0,lenth,1)] b = sorted(a,key=lambda x: x[0]) for i in range(0,lenth,1): x = target-b[i][0] l , r = i+1,len(b)-1 while(l&lt;r): mid=(l+r)//2 if b[mid][0]&gt;=x: r=mid elif b[mid][0]&lt;x: l=mid+1 if b[l][0]==x: x = [b[i][1],b[l][1]] y=sorted(x) return y 自我总结对于这一题，我的个人总结是用python实现了一次二分同时学会了排序sorted函数带三个参数： 要排序数组 排序方式，是一个函数写法key=一个函数，这里是lambda x:x[0]按照第一个值排序 reverse反转，让她从小到大与从大到小之间变化","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://www.dream-ak.top/categories/leetcode/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"最短路和次短路的数量","slug":"最短路和次短路的数量","date":"2020-02-29T09:54:30.000Z","updated":"2020-03-02T04:40:41.801Z","comments":true,"path":"2020/02/29/最短路和次短路的数量/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"题目链接题意：给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少","text":"题目链接题意：给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少 思想和解法首先看到这个题目，我们第一时间就会想到最短路径数量，直接就暴力跑迪杰斯特拉然后统计一下就完事了，最多加个次短路而已，我们就按照次短路生成的方式，跑迪杰斯特拉，然后记录到达每个点的最短路数量和次短路数量。 优化最短路时就把当前次短路的数量赋值给最短路， 通过次短路优化次短路时就把前一个点的次短路数量赋值给下一个点的数量 操作想法很简单，但是这题如果大量使用空间则会爆优先队列，因此我们要注意对优先队列进行节省空间，对于每一个点能让它少入队，则少让他入队。把优化最短路时最短路和次短路的这两次入队归为一次，就会节省很多空间！所以写法再次修改为如下，分为4个步骤： 优化最短路 等于最短路 优化次短路 等于次短路代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],dis[N],dis2[N],tot=0,num1[N],num2[N];void init()&#123; memset(head,-1,sizeof head); memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); memset(num1,0,sizeof num1); memset(num2,0,sizeof num2); tot=2;&#125;void add(int u,int v,int w)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij(int x)&#123; dis[x]=0; num1[x]=1; q.push(make_pair(0,x)); while(q.size())&#123; int x=q.top().second,w = -q.top().first; //printf(&quot;%d %d\\n&quot;,x,w); q.pop(); int cnt; if(w&gt;dis2[x]) continue; if(w == dis[x]) cnt=num1[x]; else if(w==dis2[x]) cnt=num2[x]; for(int i=head[x];~i;i=ed[i].pre)&#123; int v = ed[i].id,s=ed[i].w; int cost = w + s,d=cnt; if(dis[v]&gt;cost)&#123; dis2[v]=dis[v]; num2[v]=num1[v]; dis[v]=cost; num1[v]=d; //swap(dis[v],cost); //swap(d,num1[v]); q.push(make_pair(-dis[v],v)); //printf(&quot;%d %d sss\\n&quot;,v,num1[v]); &#125; else if(dis[v]==cost)&#123; num1[v]+=d; &#125; else if(dis2[v]==cost)&#123; num2[v]+=d; &#125; else if(dis2[v]&gt;cost)&#123; dis2[v]=cost; num2[v]=d; q.push(make_pair(-cost,v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; int p,q; scanf(&quot;%d %d&quot;,&amp;p,&amp;q); dij(p); int ans=num1[q]; if(dis[q]==dis2[q]-1) ans+=num2[q]; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj3694-tarjan","slug":"poj3694-tarjan","date":"2020-02-29T09:28:47.000Z","updated":"2020-03-02T03:55:29.435Z","comments":true,"path":"2020/02/29/poj3694-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj3694-tarjan/","excerpt":"题目链接题意给一个连通图，问每一次加边以后还有多少条桥！","text":"题目链接题意给一个连通图，问每一次加边以后还有多少条桥！ 思想和解法很明显把连通图缩点成$DAG$图，(对DAG图操作)然后每一次加边后$DAG$图里强连通分量继续缩点！桥的数量就是加边前的数量减去缩掉的边的数量。 操作问题1：缩点想法很简单，操作异想天开，如果用染色法对图进行缩点，最坏情况就是一棵N个结点的树，N-1条边每一次添加一条邻边，复杂度卡到$(1+n)* \\frac{n}{2}$。所以采用并查集动态缩点！ 问题2：路径路径寻找也是一个问题，我们已经$tarjan$缩过一次点了，我们接下来是新建一个图继续跑$tarjan$离线$LCA$吗？注意对于tarjan的LCA算法精髓在于哪里？他那么写的原因是经过了tarjan算法以后每个节点其实都有一个时间戳！而两个点$$之间的$LCA$他们有一个共同的特点，那就是: $LCA$的左子树上的所有点的时间戳都小于右子树的时间戳！ 根据这个特点我们可以直接用记录当前点的父节点然后爬到$LCA$上去。看下代码123456789101112void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--;//缩点成功则桥减一 x=get(pre[x]);//爬向缩点后的父节点 &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--;//缩点成功则桥减一 y=get(pre[y]);//爬向缩点后的父节点 &#125;&#125; 代码282ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 5e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],pre[N],fa[N],dfn[N],low[N],sta[N];int tot=0,edge=0,tim=0;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int vis[N];int get(int x)&#123; if(fa[x]!=x) return fa[x]=get(fa[x]); else return x;&#125;bool join(int x,int y)&#123; int p=get(x),q=get(y); if(p!=q)&#123; fa[p]=q;//指向父节点 return true; &#125; return false;&#125;int num=1;void tarjan(int x,int fath)&#123; low[x]=dfn[x]=++tim; vis[x]=1; int flag=1; for(int i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(v==fath&amp;&amp;flag) &#123;flag=0;continue;&#125; if(!vis[v])&#123; pre[v]=x; tarjan(v,x); low[x]=min(low[v],low[x]); if(low[v]&gt;dfn[x])&#123; edge++; &#125; else&#123; join(v,x); &#125; &#125; else&#123; low[x]=min(low[x],dfn[v]); &#125; &#125;&#125;void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--; x=get(pre[x]); &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--; y=get(pre[y]); &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123; for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++) head[i]=-1,vis[i]=0,dfn[i]=0; tim=edge=tot=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; tarjan(1,1); pre[1]=1; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case %d:\\n&quot;,num++); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); lca(u,v); printf(&quot;%d\\n&quot;,edge); &#125; puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj2763,tarjan","slug":"poj2763-tarjan","date":"2020-02-29T08:44:56.000Z","updated":"2020-02-29T09:26:55.068Z","comments":true,"path":"2020/02/29/poj2763-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj2763-tarjan/","excerpt":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问","text":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问 思想与解法 首先最暴力的想法就是去找到路径然后判断，找路径的办法就是先找到$LCA$然后暴力就完事了，很明显时间复杂度$O(N*Q)$绝对$tle$ 我们思考得到最大利润的方式，首先对于$u \\rightarrow v$可以分解为$u \\rightarrow LCA \\rightarrow v$那么最大利润将会如下三条路径中产生：1.$u \\rightarrow LCA$2.$LCA \\rightarrow v$3.$u \\rightarrow v$这时候可能有很多人会想为什么要把路径3分为路径1与路径2，明显路径3包含1和2啊。 在这里解释一下，如果只观察路径3的话，那么答案就是路径上最大的权值减最小权值，但是，无法记录访问顺序！但是这样分开以后以LCA为参考，获得每个点到$LCA$路径的最大利润，如果$u \\rightarrow v$的最大利润不在点到$LCA$的路径而是穿过路径的时，那么商人一定在$u \\rightarrow LCA$进货，在$LCA \\rightarrow v$出售。直接记录两个路径中的最大最小值然后计算就好了 操作根据分析我们需要四个数组！一个储存路径1的最大利润$up$，一个储存路径2的最大利润$down$，第三个储存路径的最大值$ma$，第四个存储最小值$mi$。然后并查集，把每一个点并到$LCA$上并更新所有数据。最后统计答案，据说卡vector。。并查集的合并操作 12345678910int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125; 卡vector我们就是用链式前向星寸询问，继而离线！$add1$函数由于我们要在合并完以后才能得到答案，所以我的办法是每一次计算完$LCA$，用链式前向星保存在$LCA上(add2)！$访问到时在计算ans。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 3e5+5;struct ED&#123; int pre,id;&#125;ed[N],ed1[N];int head[N],head1[N],tot,tot1,ans[N],fa[N],ma[N],mi[N],vis[N],up[N],down[N],head2[N],tot2=1;struct NUM&#123; int x,y,id,pre;&#125;num[N];void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;void add1(int u,int v)&#123; ed1[++tot1].pre=head1[u]; ed1[tot1].id=v; head1[u]=tot1;&#125;void add2(int u,int x,int y,int id)&#123; num[++tot2].id=id; num[tot2].x=x,num[tot2].y=y; num[tot2].pre=head2[u]; head2[u]=tot2;&#125;int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125;void LCA(int x)&#123; vis[x]=1; int i; for(i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(vis[v]) continue; else &#123; LCA(v); fa[v]=x; &#125; &#125; for(i=head1[x];~i;i=ed1[i].pre)&#123; int v=ed1[i].id; if(vis[v]) &#123; add2(get(v),x,v,i); &#125; &#125; for(i=head2[x];~i;i=num[i].pre)&#123; int u = num[i].x,v=num[i].y,d=num[i].id; get(u),get(v); if(d%2)&#123; ans[d]=ans[d^1]=max(up[v],max(down[u],ma[u]-mi[v])); &#125; else&#123; ans[d]=ans[d^1]=max(down[v],max(up[u],ma[v]-mi[u])); &#125; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); memset(head1,-1,sizeof head1); memset(head2,-1,sizeof head2); memset(vis,0,sizeof vis); tot=tot1=tot2=1;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; int u,v,w; init(); for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;w); down[i]=up[i]=0; ma[i]=mi[i]=w; &#125; for(i=1;i&lt;n;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; int q; scanf(&quot;%d&quot;,&amp;q); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add1(u,v); add1(v,u); &#125; LCA(1); for(i=2;i&lt;=2*q;i+=2)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; &#125;&#125; 总结完美的考察对于并查集，$tarjan$的理解，对于扩展域的使用在这里像极了$dp$，也让我发现自己对于tarjan的不足。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"强连通分量","slug":"强连通分量","date":"2020-02-28T15:36:16.000Z","updated":"2020-02-28T15:59:21.225Z","comments":true,"path":"2020/02/28/强连通分量/","link":"","permalink":"https://www.dream-ak.top/2020/02/28/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。","text":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。 tarjan算法这个算法十分强大，广泛应用于$LCA$，强连通缩点等问题，他的主要思想是给每一个点打上一个时间戳，然后$dfs$去寻找每一个点$u$所能回到的最小时间戳$v$，在这个区间$$内的点是一个连通分量，然后进行缩点，这里的缩点有两种方式。 通过数组映射缩点，同一个连通分量映射同一个值 并查集缩点，同一个连通分量指向同一个根 练习题目hdu1239求加多少条边使整个图变为强连通图 思路：首先缩点，把图变成DAG图以后去看如何加最少的边使图变为强连通！很明显，对于入度为0的点必须加一条边使他能到达，出度为0的边也要加边使得到了他的边能回去，要加的最少的边就是$max(入度为0,出度为0)$； 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N =2e5+5;struct ED&#123; int pre,id;&#125;ed[N*2];int head[N],tot=1;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int dfn[N],low[N],vis[N],dfp,sta[N],cnt=0,siz=0,col[N],in[N],out[N];void tarjan(int x)&#123; dfn[x]=++dfp; low[x]=dfp; vis[x]=1; sta[++cnt]=x; for(int i=head[x];i;i=ed[i].pre)&#123; int u=ed[i].id; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[u],low[x]); &#125; else if(vis[u])&#123; low[x]=min(low[x],dfn[u]); &#125; &#125; if(dfn[x]==low[x])&#123; col[x]=++siz; vis[x]=0; while(sta[cnt]!=x)&#123; vis[sta[cnt]]=0; col[sta[cnt--]]=siz; &#125; cnt--; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; tot=1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(head,0,sizeof head); memset(dfn,0,sizeof dfn); memset(in,0,sizeof in); memset(out,0,sizeof out); memset(low,0,sizeof low); memset(col,0,sizeof col); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); &#125; dfp=0,cnt=0,siz=0; for(i=1;i&lt;=n;i++)&#123; if(dfn[i]==0)&#123; tarjan(i); &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=head[i];j;j=ed[j].pre)&#123; if(col[i]!=col[ed[j].id])&#123; out[col[i]]++; in[col[ed[j].id]]++; &#125; &#125; &#125; int ans1=0,ans2=0; for(i=1;i&lt;=siz;i++)&#123; if(in[i]==0) ans1++; if(out[i]==0) ans2++; &#125; printf(&quot;%d\\n&quot;,max(ans1,ans2)==1?0:max(ans1,ans2)); &#125; &#125;&#125; 总结对于$tarjan$应该灵活使用并查集对其进行各种点集的合并。对于$DAG$来说我们要注意的是要实现强连通只需要计算$max$(出度0，入度0)；关于tarjan的题目之后还会找几个好题再写几次。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"分层图和次短路","slug":"分层图和次短路","date":"2020-02-16T14:34:03.000Z","updated":"2020-02-22T13:30:33.690Z","comments":true,"path":"2020/02/16/分层图和次短路/","link":"","permalink":"https://www.dream-ak.top/2020/02/16/%E5%88%86%E5%B1%82%E5%9B%BE%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。","text":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。 分层图简介分层图是一个最短路的应用，他一般用来计算在一个连通图里面在可以省K条路的情况下，我们能从S到T的最短距离！做法有两种： dp 建分层图 在这里我只介绍做法2 建图我们建立k层图，两层图之间的边免费，图里面的连通情况一致。解释一下：对于k层图，如果由S走到T的话，不管是到达哪一个点，他最多经过K次免费！在这个图上面跑迪杰斯特拉，最后找最小值就好了 讲的抽象，在这里我推荐推荐一篇博客 缺陷空间占用太大，跑了两个题目差不多都是$40M$左右，dp版本会低一些，但时间复杂度不变。计算边的数组大小： 一条边要往连向下一层图同时还要连向本层图，所以一条边实际上要有$(k*2)$条边 代码题目地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int N = 5e5+5;struct ED&#123; int pre,id,w;&#125;ed[N*10];int head[N],tot=1,dis[N];bool vis[N];int s,t;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij()&#123; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[s]=0; q.push(make_pair(0,s)); while(q.size())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; //printf(&quot;%d %d\\n&quot;,u,v); if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k)==3)&#123; s=1,t=n; for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); for(j=1;j&lt;=k;j++)&#123; add(u+j*n,v+j*n,w); add(v+j*n,u+j*n,w); add(u+j*n-n,v+j*n,0); add(v+j*n-n,u+j*n,0); &#125; &#125; dij(); int ans=2e9+9; for(i=0;i&lt;=k;i++)&#123; ans=min(ans,dis[t+i*n]); //printf(&quot;%d\\n&quot;,dis[t+i*n]); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125; 次短路解法 通过最短路来求 通过K短路来求 在这里我只讲通过最短路来求得解法我们得到次短路的过程分为两种 最短路更新得来得来,在更新dis[u]时，原来的$dis[u]$将会是次短路 次短路自身延申得来,在次短路$dis2[u]+min(u \\rightarrow v)$,借此更新最短路 对于这两种情况来看，1与最短路有关，2的更新方式也与迪杰斯特拉很像！所以我们这里就直接跑最短路！用优先队列维护两条路径，最短路和次短路，每一次取里面最短的。无论是最短路上的点，还是次短路上的点，因为次短路影响不了最短路，而最短路影响次短路本身就是需要的 题目：POJ3255123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=1,dis[N],dis2[N],n,m;priority_queue&lt;pair&lt;int,int&gt; &gt; q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij(int x)&#123; memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); dis[x]=0; q.push(make_pair(-dis[x],x)); while(q.size())&#123; int u=q.top().second,w=-q.top().first; q.pop(); if(dis2[u]&lt;w) continue;//这里是剪枝，看注释一。 for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,d=w+ed[i].w; if(d&lt;dis[v])&#123; swap(d,dis[v]);//这里只能是交换，因为dis[v]还要给次短路用 q.push(make_pair(-dis[v],v)); &#125; if(d&lt;dis2[v]&amp;&amp;d&gt;dis[v])&#123; dis2[v]=d; q.push(make_pair(-dis2[v],v)); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,dis2[n]);&#125;int main()&#123; int i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; memset(head,0,sizeof head); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); &#125; dij(1); &#125;&#125; 注释一：因为对于次短路的更新，我们会在优先队列里面增加一些无用边，就像最短路时的vis数组一样的性质，把那些多余的边全部去掉，而这里只需要路径长度小于等于次短路的，所以大于的直接continue！","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"双调欧几里得旅行商问题","slug":"双调欧几里得旅行商问题","date":"2020-02-11T15:37:49.000Z","updated":"2020-02-12T05:31:41.933Z","comments":true,"path":"2020/02/11/双调欧几里得旅行商问题/","link":"","permalink":"https://www.dream-ak.top/2020/02/11/%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/","excerpt":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl","text":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl 题目链接题意，给予n个点的坐标，要求从第1个点走到第n个点然后再走回来且去的时候点的序号单调递增，回来的时候单调递减！ 思路说句实在的我第一眼居然是弗洛伊德然后掉坑底怕都没爬出来。正解是$dp$,怎么$dp$呢 我们假设$dp[i][j]$中$i$为从第i个点回到1号点，$j$为从1号点回到$j$号点，而$dp[i][j]$则是这个过程的最短距离。 按着这个定义来看，$dp[i][j]=dp[j][i]$。解释一下：我们对于这个问题来说$i \\rightarrow 1 \\rightarrow j \\Leftrightarrow j \\rightarrow 1 \\rightarrow i$ 那么首先假设$i&lt;j$的dp方程： $i=j$ 时则有$dp[i][j]=dp[i-1][j]+dis(i-1,j)$解释：i \\rightarrow 1 \\rightarrow j \\Leftrightarrow i \\rightarrow (i-1) \\rightarrow 1 \\rightarrow j $i+1 &lt; j $时，则有$dp[i][j]=dp[i][j-1]$解释：i < j(i只能连小于i的边) \\Rightarrow (j-1) \\rightarrow j $i+1=j$则$dp[i][j]=min(dp[i][j],dp[k][j-1]+dis(k,j))(k=1,2···,j-2 $解释：因为这个时候就是相当于在路径$k \\rightarrow 1 \\rightarrow i$中加一条边$j\\rightarrow k$则会得到$j\\rightarrow 1 \\rightarrow i$且$k!=j-1$因为$(j-1) \\rightarrow 1 \\rightarrow (j-1) \\rightarrow j$一定不会是最短路径，因为$j-1$点重复一次的话，假设是$x \\rightarrow j-1 \\rightarrow j$的长度按照三角形边长来看会发现$x\\rightarrow j$的边长一定小于等于前一条边。 由上三种状态可以发现我们要得到$dp[i][j]$首先就要知道$dp[i][j-1]$和$dp[i-1][j]$那么我们可以先对$j$进行遍历得到$dp[i][j-1]$，然后再从小到大遍历$i$就会得到$dp[i][j]$。 代码12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int N = 300;double dp[N][N];struct ed&#123; double x,y;&#125;a[N];double dis(int i,int j)&#123; return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf %lf&quot;,&amp;a[i].x,&amp;a[i].y); &#125; dp[1][2]=dis(1,2); for(j=3;j&lt;=n;j++)&#123; for(i=1;i&lt;j-1;i++) dp[i][j]=dp[i][j-1]+dis(j,j-1); dp[j-1][j]=2e9+9; for(i=1;i&lt;j-1;i++) dp[j-1][j]=min(dp[j-1][j],dp[i][j-1]+dis(i,j)); dp[j][j]=dp[j-1][j]+dis(j-1,j); &#125; printf(&quot;%.2lf\\n&quot;,dp[n][n]); &#125; &#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束系统复习","slug":"差分约束系统复习","date":"2020-02-09T15:08:02.000Z","updated":"2020-02-10T03:34:32.817Z","comments":true,"path":"2020/02/09/差分约束系统复习/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/","excerpt":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。","text":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。 来个板子：12345678910111213141516171819bool spfa(int t)&#123; int l=1,r=0; que[++r]=0; dis[0]=0; while(l&lt;=r)&#123; int u=que[l++]; int i; vis[u]=0; for(i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; if(dis[u]+w&gt;=dis[v])&#123; dis[v]=dis[u]+w; if(num[v]&gt;t) return false; if(vis[v]==0) que[++r]=v,vis[v]=1,num[v]++;//(num在这里重点注意); &#125; &#125; &#125; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展域","slug":"扩展域","date":"2020-02-09T11:07:38.000Z","updated":"2020-02-10T03:34:07.113Z","comments":true,"path":"2020/02/09/扩展域/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E6%89%A9%E5%B1%95%E5%9F%9F/","excerpt":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！","text":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！ 题目链接题意题意明显就是给$[l,r]$中有奇数个1还是偶数个1，然后看它第一次在哪里自相矛盾了，输出第一次自相矛盾的位置！ 思路首先离散化这个我就不说了，你们百度一下什么原理。假设$[l,r]$中奇数个1表示为1，偶数个1表示为0。那么我们每一次合并$(l-1,r]$这个区间，这样就可以把所有数据都联系起来。合并并查集：如何合并？我们那么我们就可以通过 $x \\rightarrow root1$(根节点)的值$d[x]$ $y \\rightarrow root2$(根节点)的值$d[y]$ 得出$root1 \\rightarrow root2$的值。假设$root1$和$root2$相同则判断一下去看这组数据是否正确。判断方法： $x \\rightarrow root1 = d[x]$ $y \\rightarrow root1 = d[y]$ $x \\rightarrow y = x \\rightarrow root1 \\rightarrow y = d[x]$^$d[y]$ 不同则是： $root1 \\rightarrow root2$的值是 $d[x]$ ^ $d[y]$ ^ $n$（$n$为$x \\rightarrow y$）这个就会得到关系的值 解释$x \\rightarrow y = n$$x \\rightarrow root1 = d[x]$$y \\rightarrow root2 = d[y]$则$root1 \\rightarrow root2 = root1 \\rightarrow x \\rightarrow y\\rightarrow root2 = d[x]$ ^ $d[y]$ ^ $n$ 怎么压缩路径 $x \\rightarrow y = d[x]$$y \\rightarrow root = d[y]$那么 $x \\rightarrow root = d[x]$^$d[y]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5e3+5;int fa[2*N],d[2*N];int get(int x)&#123; if(fa[x]==x) return x; int root = get(fa[x]); d[x]^=d[fa[x]]; return fa[x] = root;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%d&quot;,&amp;n); int l[N],r[N],c[N],a[N*2],b[N*2]; char s[5]; int cnt=0; for(i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d %s&quot;,&amp;l[i],&amp;r[i],s); if(s[0]==&apos;o&apos;) c[i]=1; else c[i]=0; a[++cnt]=--l[i],a[++cnt]=r[i]; &#125; sort(a+1,a+1+cnt); int cnt1=0; for(i=1; i&lt;=cnt; i++) &#123; if(i==1||a[i]!=a[i-1]) b[++cnt1]=a[i]; &#125;//离散化操作，我就不说了 for(i=0; i&lt;=cnt1; i++) fa[i]=i,d[i]=0;//初始化操作 for(i=1; i&lt;=n; i++) &#123; int l1=lower_bound(b+1,b+1+cnt1,l[i])-b; int r1=lower_bound(b+1,b+1+cnt1,r[i])-b; int fl=get(l1),fr=get(r1); if(fl!=fr)//不在同一个集合，不会冲突 &#123; fa[fr]=fl; d[fr]=c[i]^d[r1]^d[l1]; &#125; else//在同一个集合，可能冲突！ &#123; if(d[r1]^d[l1]!=c[i]) &#123; printf(&quot;%d\\n&quot;,i-1); return 0; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,n);//如果全部没错，就输出最后一个答案&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"爬虫","slug":"爬虫","date":"2020-02-08T12:12:03.000Z","updated":"2020-02-11T14:16:08.118Z","comments":true,"path":"2020/02/08/爬虫/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%88%AC%E8%99%AB/","excerpt":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧)","text":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧) 爬虫的四个步骤 获取数据：爬虫根据我们的输入的网址进行访问，让后返回一系列的数据 解析数据：对于数据我们需要把返回的数据进行解析成我们能读懂的表达式 提取数据：从我们需要的地方，我们需要对这些数据进行提炼，获取我们所需要的数据。 保存数据：把我们已经获得的数据保存起来，方便阅读！ 爬虫的原理一般都是这样，而反爬虫一般都是利用js等各种诡异的框架来妨碍我们获取需要的数据，当然还有通过直接封IP的，但是他的误伤率很高，因为IP换人的速度太快，不知道封多久。（等以后真正确定了，再把删除线叉掉） 获取数据我们一般是通过$requests$模块来获取数据。这里说明一下$requests$的功能： 发起get(‘url’,**kw)请求，这是常用的获取数据的方法，kw一共是12个参数！在后面有介绍。 post()提交请求，对应于HTTP的post部分 put()请求，对应于HTTP的PUT部分 patch()，向html网页提交局部修改请求，对应于HTTP的patch delete()，向html网页提交删除请求，对应于HTTP的delete head(),获取头信息的方法，对应于HTTP的get requests()，构造请求，支撑以下所有基础方法 requests的get调用$get(‘url’,params=None,**kwargs)$其中$kwargs$一共有12个参数： $response$对象在对于一个请求后返回的对象就是$response$对象，这种对象支持4种操作 首先编码response.status_code()返回一个状态值，其中200为获取成功 response.context()获取的数据返回。 response.encoding定义了编码，我们可以使用response.apparent_encoding来自动获取编码，也可以自己从网站自己找编码方式 response.text()返回一个字符串 通过headers来模拟浏览器向网站发起请求我们先获得自己的代理然后添加headerget(‘url’,headers = user-agent) 通过修改params参数提交我们在获取网页时加上一个自己想要访问的参数，kw=’want’get(“url”,kw)就会在网页上获得自己想要的数据了哟 解析数据我们获取了一个数据要怎么解析呢？这里我用的是$beautifulsoup$解析的网页。首先$beautifulsoup$不是标准库，所以我们先安装： pip install beautifulsoup4 使用简单我们直接调用就好了text = BeautifulSoup(str,’html.parser’)这样子我们就会把text变成一个BeautifulSoup对象，这样操作的原因BeautifulSoup对象在后面的提取数据中成了必要条件，所以必须要转对象同时str必须为字符串！ 提取数据emmm，这里用beatifulsoup提取数据。这里提取是通过find与find_all来提取他俩的功能是匹配html的标签和属性，把BeautifulSoup对象里符合要求的数据都提取出来。区别在于，find()只提取首个满足要求的数据，而find_all()提取出的是所有满足要求的数据。示例中是class_的原因是与类(class)区别，除了对class属性的匹配以外，还可以与其他的例如style进行匹配哦。这个函数返回的值是一个Tag对象！Tag属性请参考：首先Tag的find和find_all返回的也是Tag对象！Tag.attrs生成一个字典[‘id’:key] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom bs4 import BeautifulSoupimport osimport reimport timedef get(id): headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;&#125; url = &apos;https://movie.douban.com/top250?start=&apos; + str(id) + &apos;&amp;filter=&apos; rem = requests.get(url,headers = headers) rem.encoding = &quot;utf-8&quot; print(rem.status_code) html = rem.text path = os.path.abspath(&apos;.&apos;) #with open(path+&apos;/豆瓣电影/html1.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: # f.write(html) link = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot; class=&quot;&quot;&gt;&apos;,html) num=0 for x in link: time.sleep(1) num+=1 rem = requests.get(x,headers = headers) rem.encoding=&apos;utf-8&apos; html2 = BeautifulSoup(rem.text,&apos;html.parser&apos;) title = html2.find_all(&apos;span&apos;,property=&quot;v:itemreviewed&quot;) print(title[0].text) post = html2.find_all(&apos;span&apos;,class_ = &apos;all hidden&apos;) #print(post) if not post: post=html2.find_all(&apos;span&apos;,property=&quot;v:summary&quot;) playvideo = html2.find_all(&apos;a&apos;,class_=&quot;playBtn&quot;) free = html2.find_all(&apos;span&apos;,class_=&quot;buylink-price&quot;) flag = &apos;￥&apos; for i in free: s = str(i.text) if len(s)==50: flag=&apos;@&apos; with open(path+&apos;/豆瓣电影/&apos;+str(num)+str(flag+title[0].text)+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: for i in post: f.write(str(i.text)+&apos;\\n&apos;) for i in playvideo: i.attrs//生成一个字典[&apos;id&apos;:&quot;key&quot;] f.write(str(i[&apos;data-cn&apos;])) f.write(str(i[&apos;href&apos;])+&apos;\\n&apos;) #print(i[&apos;data-cn&apos;],i[&apos;href&apos;])if __name__ == &quot;__main__&quot;: get(0) 爬虫伦理任何一个领域都有一些公约，那么爬虫也是如此，对于一个网站我们的公约是在网站后面添加一个$robots.txt$，你就可以查阅了。 总结爬虫过程find适用对象最后感谢大佬带我入坑","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"类的学习","slug":"类的学习","date":"2020-02-08T05:33:36.000Z","updated":"2020-03-06T08:37:23.507Z","comments":true,"path":"2020/02/08/类的学习/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！","text":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！ 类什么是类？类就是一种抽象的模板，就像月饼的模具一样，我们要做月饼，那么就有一个模具，在这里我们称之为类。 类的定义类的定义是由一个class定义的，一般应用时我们如下面代码一般定义1234class Cat(object): # 类的属性 # 类的行为 一个类的命名通常采用大驼峰式，也就是第一个字母大写。 对于一个类来说，我们通常定义两种类别的东西，一个叫做类的属性，一个叫做类的行为。既然是一个类那么一定有自己的属性，例如：颜色，外观，味道等等。也会有自己的行为，例如：跑，运，发霉，生锈等等动作。 我们对于一个类定义时后面的参数是类的父类，当没有父类时，我们选择放上$object(python3)$ 类的属性对于一个类的属性写法在这里我们了解下面这个函数$def$ $__init__$ ($self$,自定义参数):这个函数的用途从单词词义来看就知道叫做初始化。我们在声明对象时，我们会默认运行此函数，那么我们就可以用这个来定义默认类的属性，对于$self$这里暂时不解释，提醒一下，类的所有函数都必须含有此参数。 类的行为我们对于这个类的行为可以看成我们要这个类的所有的东西可以做什么，比如我们要月饼都运往安徽，那么我们只需要在模板里面写上一个行为“运往安徽”，那么按照这个模板生成的月饼都会运往安徽咯！写法：12def 函数名(self,自定义参数): xxxxx下面xxx代表具体行为，看上去除了$self$以外和其他的函数没有什么差别了。这样就会产生一个简单的类 对象说了那么久的类，那么对象又是什么呢？那就是一个由月饼模板做的月饼了，直接由模板复制出来的。那么对象有是怎么定义的呢？我们一般采用：对象名 = 类()注意后面有个括号哟。我们对于这个对象有些什么操作呢？因为$python$是动态语言，其实我们可以随时对这个对象进行增加属性！ 看代码1234567891011class Moon(object): def __init__(self): self.price = &quot;10￥&quot; self.to = &quot;安徽&quot; def sold(self,price1): print(&quot;原价：%s&quot; % self.price) print(&quot;售价：%s&quot; % price1) returnif __name__ == &quot;__main__&quot;: moon = Moon() moon.sold(&quot;12￥&quot;) 这样$__init__$就是定义属性,$sold$就是一个行为函数了 数据封装看了一下廖雪峰大神的博客，封装就是执行操作时，不需要对一个类里面的数据进行访问，直接把操作放在类里面，以后调用时就不用考虑类里面的行为咯，像极了我的行为函数啊。hhh","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"zoj2770差分约束","slug":"zoj2770差分约束","date":"2020-02-07T12:54:48.000Z","updated":"2020-02-07T12:57:37.371Z","comments":true,"path":"2020/02/07/zoj2770差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/02/07/zoj2770%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"emmm,好久没刷题，手感都快没了，先来养下手感","text":"emmm,好久没刷题，手感都快没了，先来养下手感 题目链接题意大概就是给我们$n$个营地，$c[i]$表示第$i$个营地最多的人数，第$u$-第$v$个营地一共有$w$个人。问最少有多少人。对于这种题型，我们一般做法是首先确定一个数组表示前面$i$个营地的总人数 挖掘隐藏条件，每一个营地的人数不可能为负数，所以$a[i]-a[i-1]\\geq0$每个营地最多有$i$人，我们可以知道，$a[i]-a[i-1]\\leq c[i]$$u-v$一共最少有$w$人，我们可以得出，$a[u]-a[v-1]\\geq w$ 我们可以把第二个条件化简为 a[i]-a[i-1]\\leq a[i] \\rightarrow a[i-1]-a[i] \\geq -c[i]由上化简，我们就把所有的代数式换成了大于等于的形式，开始建图了题目要求的是最小的人数，那么也就是$min(a[n]-a[0])$那么我们就可以这么建图： 我们按照从被减数向减数建一条边，边权为右边的值。 这样建图有什么好处？因为我们要求的是$min(a[n]-a[0])$，而我们这么建图就会使源点$0$到达的任意一个$v$最长路长度都是最少的人数，为什么是最长路？大于等于符号决定的呀，当大于等于时，只有最长路不会和其他方向的边冲突，小于等于时，我们只有最短路不会和其他方式的边冲突。接下来看代码，spfa版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;//#include&lt;windows.h&gt;using namespace std;const int N = 2e5+5;int deq[N*2],a[N],head[N],tot=0;struct ED&#123; int pre,to,w;&#125;ed[2*N];int vis[N],dis[N],num[N];void spfa(int x)&#123; memset(dis,-1,sizeof dis); memset(vis,0,sizeof vis); memset(deq,0,sizeof deq); memset(num,0,sizeof num); dis[0]=0; int l=1,r=0; deq[++r]=0; while(l&lt;=r)&#123; int u=deq[l]; l++; vis[u]=0; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].to; //printf(&quot;%d %d %d %d %d\\n&quot;,u,v,dis[u],ed[i].w,dis[v]); if(dis[v]&lt;dis[u]+ed[i].w) &#123; dis[v]=dis[u]+ed[i].w; if(vis[v]) continue; deq[++r]=v; num[v]++; if(num[v]&gt;=x) &#123; printf(&quot;Bad Estimations\\n&quot;); return ; &#125; vis[v]=1; //printf(&quot;%d %d\\n&quot;,u,v); &#125; &#125; &#125; if(dis[x]==-1)&#123; printf(&quot;Bad Estimations\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;,dis[x]); &#125;&#125;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].to=v; ed[tot].w=w; head[u]=tot;&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2) &#123; tot=0; for(i=0;i&lt;=n;i++)&#123; head[i]=-1; &#125; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); add(i-1,i,0); add(i,i-1,-a[i]); &#125; int u,v,w; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u-1,v,w); &#125; spfa(n); &#125; //system(&quot;pause&quot;);&#125;不用队列，方便优化","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"python爬取王者数据","slug":"python爬取王者数据","date":"2020-02-06T10:24:34.000Z","updated":"2020-02-08T13:29:30.494Z","comments":true,"path":"2020/02/06/python爬取王者数据/","link":"","permalink":"https://www.dream-ak.top/2020/02/06/python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%80%85%E6%95%B0%E6%8D%AE/","excerpt":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧","text":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧 $requests$首先我们安装这一个requests模块，在终端输入 pip install requests 利用$r=requests.get()$来进行对一个网页的获取，返回一个二进制字符串，为了不把字符转乱码，我们一般使用正确的编码格式，这个编码格式一般在网页上写着！或者使用$r.apparent_encoding$的函数自动获取，不过不保证完全准确！转字符串时可以使用$html=r.text$返回字符串，详情请看爬虫这篇博客 强行爬虫在爬https://www.vmgirls.com 时会发现不允许爬取，那么有一个玄学的爬取方法，这个网站是通过判断代理服务来判断是不是爬虫，在requests时会发送一个爬虫请求，该网站如果发现是爬虫时，那么我们就可以把requests发送的代理服务改掉,通过在$requests(‘https://vmgirls.com/&#39;,headers=&quot;本地代理&quot;)$。本地代理可以在网页上查看！ $re.findall()$我们一般使用这个来获取自己需要的信息。 ()括号内表示需要的信息，没有括号则表示不需要的信息 []匹配时我们需要写一个自己的字符分类，然后去选择自己的信息 findall(r’’,txt)是格式,r后跟着自己的匹配方式。 os文件读写： 对于文件读写我们一般是使用$with$ $open(“文件路径”,’读写方式’,’encoding=编码规则’) as f:$ 对于文件路径可以使用绝对路径，编码规则须和字符串的编码规则相同。 time为了网站的稳定性能我们一般要去使用$time.sleep()$来控制爬取速度。 最后来看一下我们是如何爬取王者的：1234567891011121314151617181920212223242526272829303132import requestsimport reimport osimport timer = requests.get(&apos;https://pvp.qq.com/web201605/herolist.shtml&apos;)r.encoding=&quot;gbk&quot;html = r.texthttp = &quot;https://pvp.qq.com/web201605/&quot;dirs = os.path.abspath(&apos;.&apos;)dir_name = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;([a-z0-9/.]*)&quot; target=&quot;_blank&quot;&gt;&lt;img+\\s&apos;,html)for i in dir_name: time.sleep(1) r = requests.get(http+i) r.encoding=&apos;gbk&apos; html1=r.text hero = re.findall(r&apos;&lt;h2 class=&quot;cover-name&quot;&gt;(.*?)&lt;/h2&gt;&apos;,html1) print(hero) skin = re.findall(r&apos;&lt;ul class=&quot;pic-pf-list pic-pf-list3&quot; data-imgname=&quot;([\\S]*)&quot;&gt;&apos;,html1) skill_name = re.findall(r&apos;&lt;p class=&quot;skill-name&quot;&gt;&lt;b&gt;(.*?)&lt;/b&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&apos;,html1) skill_decs = re.findall(r&apos;&lt;p class=&quot;skill-desc&quot;&gt;(.*?)&lt;/p&gt;&apos;,html1) skill_tips = re.findall(r&apos; &lt;div class=&quot;skill-tips&quot;&gt;(.*?)&lt;/div&gt;&apos;,html1) lens = len(skill_tips) with open(dirs+&apos;/&apos;+&apos;王者荣耀&apos;+&apos;/&apos;+hero[0]+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;) as f: f.write(&quot;英雄名称：&quot;+hero[0]+&apos;\\n&apos;) f.write(&quot;皮肤：&quot;+skin[0]+&apos;\\n\\n&apos;) for j in range(0,lens,1): f.write(&quot;技能名称：&quot;+skill_name[j][0]+&apos;\\n&apos;) f.write(&quot;技能冷却：&quot;+skill_name[j][1]+&apos;\\n&apos;) f.write(&quot;技能消耗：&quot;+skill_name[j][2]+&apos;\\n&apos;) f.write(&quot;技能描述：&quot;+skill_decs[j]+&apos;\\n&apos;) f.write(&quot;技能用途：&quot;+skill_tips[j]+&apos;\\n&apos;) f.write(&apos;\\n&apos;) 还是有点不会写文件的保存格式，呜呜呜，只会狂写编码了。。。最后来看一下效果：","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-02-05T10:48:23.000Z","updated":"2020-02-06T13:01:44.067Z","comments":true,"path":"2020/02/05/正则表达式/","link":"","permalink":"https://www.dream-ak.top/2020/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$","text":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$ 正则表达式匹配方式 字符表达 意义 例子 例子解释 \\d 匹配一个数字 \\d{3} 匹配三个数字 \\w 匹配一个字母 \\w{3} 匹配三个字母 ? 可选匹配，前面括号内符号可以匹配一次或者零次 (wo)?man 匹配man或者woman * 匹配零次或多次 (wo)*man 代表可以匹配man、wowoman等等 + 匹配一次或多次 ((wo)+man) 代表可以匹配woman、wowoman等等 {} 指定匹配次数 (wo){2,5}man 可以匹配wo重复2到5遍的此类字符串 1 管道，指定多种字符模式，返回第一次出现的文本它是一竖 ‘Batman 1 Tina Fey’ 表示查找Batman和Tina Fey的第一次出现的字符 ^ 直接从头开始匹配 ^hello 从头开始匹配hello $ 必须以该字符结束 3$ 必须以3结尾 正则匹配是一种贪心匹配(能长则长)，而花括号的匹配是一种非贪心匹配(能短则短) search：每一次返回第一次找到的字符串 findall：返回整个text的所有的字符串 字符分类字符表达式 字符分类 表达式 \\d 0到9的任何数字 \\D 除0到9的任何数字 \\w 任何字母、数字、下划线字符 \\W 除字母、数字、下划线字符外的任意字符 \\s 空格、制表符、换行符 \\S 除空格、制表符、换行符以外的任意字符 . 匹配除换行以外所有字符 .* 匹配所有字符 建立自己的字符分类 [quit]表达可以匹配quit里面的任意一个字符 [ ^quit ]表达非quit里面任意一个字符的字符可以通过短横来表达字母或数字的范围[a-zA-Z0-9]将匹配所有字母和数字 文本替换正则表达式不仅能找到文本模式，而且能够用新的文本替换掉这些模式。$Regex$对象的 $sub()$方法需要传入两个参数。第一个参数是一个字符串，用于取代发现的匹 配。第二个参数是一个字符串，即 正则表达式。$ sub()$方法返回替换完成后的字符串。举个例子： &gt;&gt;&gt; namesRegex = re.compile(r&#39;Agent \\w+&#39;) &gt;&gt;&gt; namesRegex.sub(&#39;CENSORED&#39;, &#39;Agent Alice gave the secret documents to Agent Bob.&#39;) &#39;CENSORED gave the secret documents to CENSORED.&#39;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python刷题","slug":"python刷题","date":"2020-02-04T05:47:10.000Z","updated":"2020-02-04T05:55:22.525Z","comments":true,"path":"2020/02/04/python刷题/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/python%E5%88%B7%E9%A2%98/","excerpt":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划","text":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划 一行内多次输入1n,m=int(input.slipt()) 这样就可以一行输入两个数了，hhh(抄的) 一行多输出1print(&apos; &apos;.join(map(str,a))) 这个能把一个数组中间加入空格并输出。 看题目现在来看$Nod51$题目：冒办法，我找了半天就只有$codeforce$和$Nod51$支持$python3$了 全排列题面很好懂，解法很好想，就是被输出卡了。。。12345678910111213a = []n,m=map(int,input().split())def dfs(l,r): if m==r: print(&apos; &apos;.join(map(str,a))) return else : for i in range(l+1,n+1,1): a.insert(r,i) dfs(i,r+1) a.pop(r) return dfs(0,0) a序列放前面一点就能被后面函数调用了，hhh，强行全局","categories":[{"name":"python刷题","slug":"python刷题","permalink":"https://www.dream-ak.top/categories/python%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"map与reduce","slug":"map与reduce","date":"2020-02-04T03:19:31.000Z","updated":"2020-02-04T03:21:46.520Z","comments":true,"path":"2020/02/04/map与reduce/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/map%E4%B8%8Ereduce/","excerpt":"","text":"","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"函数","slug":"函数","date":"2020-02-03T09:04:38.000Z","updated":"2020-02-04T02:37:43.781Z","comments":true,"path":"2020/02/03/函数/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E5%87%BD%E6%95%B0/","excerpt":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh","text":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh 函数定义$def$定义一个函数要使用$def$语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。拿一个从$l$加到$r$的和的函数来讲12345678def sum(l,r): sum = 0 for i in range(l,r+1,1): sum += i return suml = int(input(&quot;l=&quot;))r = int(input(&quot;r=&quot;))print(sum(l,r)) $output$l=1r=1005050 位置参数比如上面的参数就叫做位置参数，调用$sum$函数时，必须给予两个固定参数 默认参数看一个代码 1234def mul(a,b = 3): print(a*b)mul(2)mul(2,4) $output$68 这个和上面的参数比较不同点在于，在定义参数的时候对一个参数赋值，这种写法叫做默认参数 特性我们调用函数时，对于默认参数可以选择性增加调用值。更大的符合了用户的情况 注意 对于默认参数我们一般默认，变化大的在前，变化小的在后 且对于默认参数放在位置参数以后 对于默认参数赋值必须赋为不变对象 可变参数可变参数：调用时，输入的长度可以是任意个。在传入以后自动组成一个$tuple$比如我们要对一个$list$或$tuple$进行和运算，由于每一个$list$的长度不定。所以我们需要一个可变参数。来看一个代码 123456789def sum1(*lis): sum = 0 for i in lis: sum += i return suma = [1,2,5,7]b = [5,9,8]print(sum1(*a))print(sum1(*b)) $output$1522 可以发现，好像就是C语言传入指针了，对的，C语言遮掩好像也可以，就是长度问题而已。下面这些要用的时候再补充吧，暂时请参考廖雪峰 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。他的功能，给与用户想给的一些多余的信息，也可以进行收集。 命名关键字参数对于关键字参数进行一定的限制","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"dict和set","slug":"dict和set","date":"2020-02-03T07:01:13.000Z","updated":"2020-02-22T06:45:45.189Z","comments":true,"path":"2020/02/03/dict和set/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/dict%E5%92%8Cset/","excerpt":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧","text":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧 $dict$$dict$的结构这里按照廖雪峰的介绍给出两种方式 按照字典树的方式建立一棵字典树，优点不会出现冲突，可直接使用，缺点相较于哈希来说，查找较慢 直接建立一个哈希表，每一次按照$key$直接哈希地址然后得到答案，优点，查找方便。缺点：容易出现哈希冲突。 $dict$是第二种建立方式，因此$key$的值是唯一的，不可重复，如果重复了那么就会将前面得到的数据丢失冲掉。 $dict$的建立首先来看一段代码 1234a=&#123;&#125;a[&apos;peng&apos;] = 4a[&apos;我&apos;] = 5print(a[&apos;我&apos;]) $output$5 可以看到我们是通过大括号{}来定义一个空$dict$然后添加直接赋值就好了。调用直接访问$key$就行了，但是一定要保证这个$key$存在。判断$key$存在性的办法： $print(‘我’\\ in\\ a) $如果存在，返回$true$。不存在返回false。 $print(a.get( ‘我’,x))$当不存在‘我’时返回$x$值 $dict$的删除这个的删除我们前提是$key$存在,如果存在，我们就可以像$list$一样删除它。 12a.pop(&apos;peng&apos;)print(a.get(&apos;peng&apos;,777)) $output$777 注意$dict$可以用在需要高速查找的很多地方，在$Python$代码中几乎无处不在，正确使用$dict$非常重要，需要牢记的第一条就是$dict$的key必须是不可变对象。 这是因为$dict$根据$key$来计算$value$的存储位置，如果每次计算相同的$key$得出的结果不同，那$dict$内部就完全混乱了。这个通过$key$计算位置的算法称为哈希算法$（Hash）$。 要保证$hash$的正确性，作为$key$的对象就不能变。在$Python$中，字符串、整数等都是不可变的，因此，可以放心地作为$key$。而$list$是可变的，就不能作为$key$ $set$$set$一般用于去重和集合操作，它可以对集合进行”与”、”或”操作. 创建创建一个空$set$1a = set() 创建一个$set$我们一般是要一个$list$做输入集合看一段代码123l = [1,1,5,9,3,8,9]a = set(l)print(a) $output${1, 3, 5, 8, 9} 很明显它自己去重了，同时不要被表面所迷惑$set$是无序的 $set$怎么添加元素？答案下行揭晓$a.add(x)$参数$x$是你要添加的$key$12a.add(2)print(a) $output${1, 2, 3, 5, 8, 9} 删除元素我们一般通过$a.remove(x)$删除,$x$是你要删除的$key$12a.remove(2)print(a) $output${1, 3, 5, 8, 9} 集合操作直接&amp;或者|就好了123b=set([1,2])print(a&amp;b)print(a|b) $output${1}{1, 2, 3, 5, 8, 9} 不可变变量字符串属于不可变变量，同时$list$是一个可变变量。123a = &quot;abc&quot;print(a.replace(&apos;a&apos;,&apos;A&apos;))print(a)","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"条件与循环","slug":"条件与循环","date":"2020-02-03T06:31:15.000Z","updated":"2020-02-04T02:12:54.899Z","comments":true,"path":"2020/02/03/条件与循环/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/","excerpt":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进","text":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进 $if$判断首先我们来看一段代码12345socre=int(input())if score&gt;=60: print(&quot;pass\\n&quot;)else : print(&quot;No pass\\n&quot;)这个就可以把你的分数转化成过和没过了，挂科了没，一目了然！对于这段代码的解释我就对他与C语言的比较了。没有C语言的小括号，$if$后面全是判断一直到$’:’$对于else 我们也需要$’:’$如果进行多次判断由C语言的$else if$ $\\rightarrow$ $elif 判断:$ 循环$for$ … $in$循环这种循环我们一般是用一个变量每一次迭代$in$里面的内容(可以是$list,tuple$等数据结构)，比如 123456789101112131415161718x=(5,2,0)for i in x: print(i)``` &gt; $output$520## $for$ ... $in$ $range(x,y,z)$循环我们看这个循环 其中省略号代表变量，我们假设为$i$现在来解释一下参数1. $x$代表$i$的初始值2. $y$代表$i$的上界或下界,**不得小于等于$y$**3. $z$代表$i$的步进大小每一次加上多少来看一段代码 for i in range(3,1,-1): print(i)``` $output$32","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"list和tuple","slug":"list和tuple","date":"2020-02-02T13:34:09.000Z","updated":"2020-02-03T06:52:06.529Z","comments":true,"path":"2020/02/02/list和tuple/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/list%E5%92%8Ctuple/","excerpt":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。","text":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。 $list$这种数据类型使列表 $list$是一种有序的集合，可以随时添加和删除其中的元素。对于这个我们可以看下面这个例子12a=[&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;]print(a) $ output$:$[‘s’, ‘a’, ‘r’, ‘s’]$ 而一个$list$的长度怎么看？还记得看字符串长度的$len$函数吗？我们就是通过$len$来查看list的长度1print(len(a)) $output:$4 同时我们还可以通过像C语言一样的手法访问下标来查看元素，同样不能越上界123print(a[0])print(a[3])print(a[-1]) $output$sss应该发现了，可以有负数，-1的意思就是倒数第一个咯。但是也不能超过$list$的长度 $list$包含的数据类型$list$里面包含的数据类型可以混合加入例如我们可以在一个list里面放入数字、字符串甚至是一个$list$也行！ $list$的操作删除123a.pop(0)print(a)print(a[0]) $output:$$[‘a’, ‘r’, ‘s’]$$a$ 我们可以看到，要删除第i个数字就是直接$pop(i)$，同时会把后面的往前面移动 插入123a.insert(0,a)print(a)print(a[0]) $output:$$[‘s’, ‘a’, ‘r’, ‘s’]$$s$每一次插入，我们都是把第$i$个元素之后往后移动，然后插入 增加$a.append(strr)$默认从尾部增加元素 $tuple$$tuple$也是一种有序列表，它的特点是一旦初始化成功后就不得修改 定义12a = (&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;);print(a) $output$(‘s’, ‘a’, ‘r’, ‘s’) 大家可能发现了，$list$的定义时中括号$[]$而$tuple$是$()$注意我们定义空$tuple$时我们是$a=()$,但是如果定义一个元素时例如$a=(1,)$时，我们注意要打逗号，不然会被误解为$a=1$为$int$型变量 意义$tuple$因其不可修改的性质所以从安全角度上来说比$list$更加安全，我们一般能用$tuple$绝不用$list$ 一个“可变的”$tuple$首先注意引号，他还是不可变的，可为什么又可以变呢？我们尝试如下定义 $a=(‘a’,’b’,[‘a’,’b’])$ 可以发现这一个$tuple$所指向的内容含有字符和一个$list$$tuple$里面的内容的确不可以变，但$list$改变了之后list的地址还是不变的，所以就改了撒，看不懂可评论。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python字符串和数组元组","slug":"python字符串","date":"2020-02-02T12:21:42.000Z","updated":"2020-02-04T03:26:12.993Z","comments":true,"path":"2020/02/02/python字符串/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记","text":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记 字符串对于$python3$的编码格式是一个$Unicode$编码 $unicode$编码粗略解释一下，详情请访问廖雪峰的笔记： $Unicode$解决了各国语言的编码冲突，利用两个字节。$UTF-8$编码是因为$Unicode$对于空间来说浪费高，所以折中出现了utf-8编码 应用场景在计算机内存中，统一使用$Unicode$编码，当需要保存到硬盘或者需要传输的时候，就转换为$UTF-8$编码。 用记事本编辑的时候，从文件读取的$UTF-8$字符被转换为$Unicode$字符到内存里，编辑完成后，保存的时候再把$Unicode$转换为$UTF-8$保存到文件。 浏览网页的时候，服务器会把动态生成的$Unicode$内容转换为$UTF-8$再传输到浏览器：正文$python3$的字符串是$Unicode$编码，也就是适合各种语言啦 对于单个字符来说，我们支持$ord()$获得字符整数表示，$chr()$把编码转为 12print(chr(20320))print(ord(&apos;你&apos;)) 输出你20320 $len$计算字符串的字符数$len(str)$返回一个整数，表示$str$所含有的字符数12strr=&quot;我爱你&quot;print(len(strr)) $output:$3 格式化输出$python$的格式化和C语言的大致相同|占位符|替换内容||:-:|:-:||%s|字符串||%d|整数||%f|浮点数||%x|16进制整数|不过有个区别我表示的重点提醒：print(“%s” % strr),不像C语言中间用逗号分隔顺带一个妙招，当你忘了要用什么的时候可以使用%s哦，他会自动转字符串，hhh1print(&quot;%s %s&quot; % (520,False)) 注意事项 对于$python$里的字符中不能直接相加，需要先把它用$ord$转成数字然后再用$chr$转回来！ 对于字符串里面字符修改必须使用$repalce(old,new,count)$进行生成新的字符串对象！ 12345678def index(head): head=str(head) if head[0]&gt;=&apos;a&apos;and head[0]&lt;=&apos;z&apos;: return head.replace(head[0],chr(ord(head[0])-32),1)#返回一个新的字符串对象 return headL1 = [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;]L2 = map(index,L1)print(list(L2))","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python启动","slug":"python启动","date":"2020-02-02T08:27:48.000Z","updated":"2020-02-02T12:38:36.259Z","comments":true,"path":"2020/02/02/python启动/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%90%AF%E5%8A%A8/","excerpt":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭","text":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭 python基础python编码格式python的编码格式是按照缩进方式，代码就像下面这个一样：12345a = 100if a &gt;= 0: print(a)else: print(-a)和C语言的差别是c语言用大括号等价于这里的缩进 python的注释 python的注释是通过#,以#开头全部注释掉每遇到一个’$:$’号都会进行自动缩进，视为一个代码块python大小写敏感。 数据类型int范围和C语言的$longlong$一致，应用方式和C语言用法一致 string字符串，他的用法和C语言的字符串用法类似，但是增加了$a[-x]$表示从后开始第x个字符，一般是由’或者”组成。 转换在一个字符串(仅包含数字)前加上int则会自动转换为int型数据类型,如下代码检测1234a = &apos;123456&apos;print(type(a))a=int(a)print(type(a)) 输入python的输入使input();在输入的时候加上提示的话就是在input(“hello world”);12a = input(&quot;please input a math:&quot;)print(a)注意input输入的东西为字符串,以下验证12a=input()print(type(a));对于这种情况我们一般直接在input前面加上一个int就好了12a=int(input())print(type(a)) 换行与C语言相似的是我们一样可以采用”\\n”换行，但增加了一个…换行的方式1print(&quot;hhh...hhh...hhh&quot;)今日份复习到此结束，hhh，晚上在介绍一下其他的基础。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"迪杰斯特拉堆优化","slug":"迪杰斯特拉堆优化","date":"2020-02-01T06:53:49.000Z","updated":"2020-02-02T08:29:07.601Z","comments":true,"path":"2020/02/01/迪杰斯特拉堆优化/","link":"","permalink":"https://www.dream-ak.top/2020/02/01/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%A0%86%E4%BC%98%E5%8C%96/","excerpt":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃","text":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃 原理来说原理的话我建议可以讲一下迪杰斯特拉的算法思想，利用贪心，每一次走距离当前点$u$最近的点$v$，那么我们由原点到$v$一定会是最近的，因为$u$一开始就是最近的，那么dis[u]+min(u\\rightarrow v)\\leq dis[u]+!min(u\\rightarrow v)根据这个我们可以知道我们只需 维护一个最小堆来得到当前最小的$dis[u]$得到$u$的位置，然后找到$u$能到的点$v$的最短路径，得到$dis[v]$然后加入堆 循环1操作直到堆为空就好了。代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=0,dis[N],vis[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij_heap(int x)&#123; int i; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(i=head[u];i;i=ed[i].pre)&#123; if(dis[u]+ed[i].w&lt;=dis[ed[i].id])&#123; dis[ed[i].id]=dis[u]+w; q.push(-dis[ed[i].id],ed[i].id);//这里用负数使最大堆变最小堆 &#125; &#125; &#125;&#125;int main()&#123; dij_heap(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束","slug":"差分约束","date":"2020-01-30T13:33:49.000Z","updated":"2020-02-29T08:45:34.596Z","comments":true,"path":"2020/01/30/差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh","text":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh 一般形式差分约束题一般是给出大量的一些不等式 a_i-b_i\\leq x \\rightarrow a_i\\leq x + b_i由上面这个不等式我们应该可以联想到最短路的不等式 dis[u]\\leq dis[v] + x(u \\rightarrow v)因此，我们可以将差分约束化成一个最短路来求，我们的$dis[u]$保存由远点到$u$的可以选择的最大范围!==为什么是最大范围？==我们每一次选择的是$min(u \\rightarrow v)$，那么一开始我们就会选择一个从原点$s$最小的范围，且没有其他路径会是她变得更小(三角形)，那么这个由原点出发的范围将会是$s \\rightarrow u$的范围，选择最大的话，就是这个范围啦。 求最长路当求最大的范围时是最短路，已经说过了，但是如果求最小范围呢？看一下基本形式 a_i-b_i\\geq x \\rightarrow a_i \\geq x + b_i这个又是什么意思呢？试着把$a_i，b_i$也当作两个点，那么这就是 dis[a_i]\\geq dis[b_i] + x也就是最长路的样子啦 最长路实现最长路的办法，我们试着用最短路的办法去试 floyd $O(n^3)$很明显暴力枚举下面肯定是可以的，但是复杂度实在太高，放弃 dijstra基于贪心的算法，我们最长路的贪心是做不到的，从三角形来看是很明显的，遂继续放弃 bellman_ford差不多就是暴力对所有的边进行n-1次遍历了==一条最长路最多经过$n-1$次松弛==，在这里最长路也是这样啊，时间复杂度的话，我们可以考虑已经死了的 spfa呀，死了不要紧我们可以优化spfa玄学优化 双端队列优化，一个非常常见的优化，当边权小于队首时从队首加入，否则队尾！ 双端慢了？没事我们可以数组模拟，强行加速！ 啊，还是tle？淡定加容错优化，我们首先把所有边权加起来开个根号后加上一个容错值$x$然后当当前边权小于队首边权加上容错时从队首加入，否则队尾，继续强行加速！ 听说还是tle？emmm，等死吧","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"vscode背景配置","slug":"vscode背景配置","date":"2020-01-30T13:00:23.000Z","updated":"2020-03-11T05:14:21.987Z","comments":true,"path":"2020/01/30/vscode背景配置/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/vscode%E8%83%8C%E6%99%AF%E9%85%8D%E7%BD%AE/","excerpt":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！","text":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！ 安装background扩展商店安装就好了这里会弹出code损坏，莫急，往下看 下载 Fix vscode checksum扩展商店下载好以后按下ctrl+shift+p输入 Fix checksum 选择apply就行了 配置插件管理员运行vscode，打开以后按如下图操作打开setting.json 编辑setting.json1234567891011121314151617181920&#123; &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;file:///E:background/vscode.png&quot;//你的图片的绝对路径 ], &quot;background.style&quot;: &#123; &quot;content&quot;: &quot;&apos;&apos;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;background-position&quot;: &quot;50% 50%&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 &#125;, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;&#125; 接下来可能会要求你重启就完成了","categories":[{"name":"vscode","slug":"vscode","permalink":"https://www.dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://www.dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"vscode配置c","slug":"vscode配置c","date":"2020-01-28T16:45:47.000Z","updated":"2020-02-21T13:01:22.668Z","comments":true,"path":"2020/01/29/vscode配置c/","link":"","permalink":"https://www.dream-ak.top/2020/01/29/vscode%E9%85%8D%E7%BD%AEc/","excerpt":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。","text":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。 1.下载DEV也许有人会问不是vscode嘛？为啥下载这个，因为vscode是编辑器我们需要下载一个编译器，我们就把DEV里面的mingw单独拿出来添加环境变量，提供编译环境。下载网址：1https://dl.pconline.com.cn/download/908942-1.html进入后点击普通下载，安装好。 2.配置环境变量1.右击电脑属性后2.进入高级设置点击环境变量3.在系统变量Path里面增加mingw64/bin的路径声明一下mingw64/bin就在之前下的DEV文件里面，桌面右击快捷方式打开文件所在地址就可以找到该文件了从左至右逐一执行后点击确定。打开cmd输入gcc如果返回的是gcc: fatal error: no input filescompilation terminated.那么环境就配好了，否则重启一下电脑再试一下，再不行的话就是环境配置失败，再来吧 3.下载vscode下载地址1https://code.visualstudio.com/Download下载过程中一路确定就好了。声明：安装路径不得含有中文！不然之后的操作会有玄学错误，gdb退出代码为-3 汉化chinese 汉化工具打开vscode工具，使用快捷键组合【command+Shift+p】，在搜索框中输入“configure display language”，点击确定后；修改locale.json文件下的属性“locale”为“zh-CN”; 重启vscode工具 安装插件c/c++ c配置必须的vscode-icons美化图标工具chinese 汉化工具Bracket Pair Colorizer 一起安装算了beautify 美化工具 4.文件配置1.我们首先写一个test.cpp文件代码里面必须含有一个输入getchar或者scanf都行,不然后面看不到输出效果，直接说返回值为1 launch文件2.从左到右操作，创建launch.json文件3.使用gdb创建之后点击gcc.exe生成一个文件，在该文件里面添加下面这段代码1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gdb.exe&quot;,//gdb.exe的文件地址 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;//与task.json一致 &#125; ]&#125;两个要注意的地方1.miDebuggerPath这是你的gdb.exe文件地址，注意要修改正确！（好像还有一个gdb32.exe你看那一个成功用那个吧）2.externalConsole这里是true！ tasks.json文件这个文件我们手动添加，在.vscode文件里面创建tasks.json注意别打错了添加如下代码12345678910111213141516171819&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++.exe build active file&quot;, &quot;command&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe&quot;,//g++.exe的位置 &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot;//bin文件夹位置 &#125; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;上面代码两个地方需要修改，请仔细看！ “command”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe”,//g++.exe的位置 “cwd”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin”//bin文件夹位置此时再回到test.cpp里面按F5运行一下，应该能输出了。到此环境安装结束！撒花","categories":[{"name":"vscode","slug":"vscode","permalink":"https://www.dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://www.dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2020-01-28T03:19:55.000Z","updated":"2020-02-07T13:28:07.421Z","comments":true,"path":"2020/01/28/欧拉函数/","link":"","permalink":"https://www.dream-ak.top/2020/01/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数","text":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数 欧拉函数的性质 公式 解释 $φ(x y) = φ(x) φ(y)$ 当且(x,y)==1 $φ(x) = x - 1$ 当且仅当x为质数时 $φ(n) = (p-1) * p^{k-1}$ $φ(n)=n∗∏(1−1/p_i)$ pi是n的质因子 $a^{φ(m)}==1%m$ 当且仅当(a,m)==1 $s = n * (φ(n)/2)$ s：小于n且与n互质的数之和 $φ(n p)=φ(n) p$ 当p为质数且n%p==0 $φ(n p)=φ(n) (p-1)$ 当p为质数且n%p!=0 计算欧拉值的打表代码,时间复杂度O(n)123456789101112phi[1]=1; for(int i=2;i&lt;n;i++)&#123; if(vis[i]==0) pri[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;1ll*i*pri[j]&lt;n;j++)&#123; vis[i*pri[j]]=1;//标记此点经过非质数 if(i%pri[j]==0) &#123; phi[i*pri[j]]=phi[i]*pri[j];//性质7 break; &#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1);//性质8 &#125; &#125; 用性质4计算单个欧拉值1234567891011121314int ph(int n)&#123; int res=n,i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; res=res-res/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) res=res-res/n; return res;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[]},{"title":"割点与割边","slug":"割点","date":"2020-01-20T14:21:29.000Z","updated":"2020-02-28T15:37:11.655Z","comments":true,"path":"2020/01/20/割点/","link":"","permalink":"https://www.dream-ak.top/2020/01/20/%E5%89%B2%E7%82%B9/","excerpt":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。","text":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。易得割点是2号点。 具体操作：121.用dfs给每一个点打上一个时间戳，把每一个点的时间戳保存至num【】里面；2.通过dfs来统计每一个点能到达的最小的时间戳。&lt;br&gt; 割点的判定方式： 如果存在一个点他的子节点能到达的最小时间戳大于等于父节点的时间戳那么这个点是一个割点。(也就是不能回到祖先，那么当前点就是割点咯) 假设一个点存在两个子节点，那么该点就是割点。我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。更新 low 的伪代码如下：1234如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);否则low[u] = min(low[u], num[v]);//这里是num[v]而不是low[v]的原因是如下图//按照节点编号从小到大遍历，4节点先到1，如果是low[v]的话，节点6的low值等于1，很明显是不可以的，所以是num 例题板子题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;const int N=2e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=1,cnt=0;int vis[N],num[N],low[N],inde,res,flag[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void tarjan(int u,int fa)&#123; vis[u]=1; low[u]=num[u]=++inde; int ch=0,i; for(i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(!vis[v])&#123; ch++; tarjan(v,u); low[u]=min(low[u],low[v]); if(fa!=u&amp;&amp;low[v]&gt;=num[u]&amp;&amp;!flag[u]) flag[u]=1,res++; &#125; else if(v!=fa)&#123; low[u]=min(low[u],num[v]);//这里非常关键，如果写成low[u]=min(low[u],low[v])在题目里面会wa &#125; &#125; if(ch&gt;= 2&amp;&amp;fa==u&amp;&amp;!flag[u])&#123; flag[u]=1; res++; &#125;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) head[i]=0,vis[i]=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; for(i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; inde=0; tarjan(i,i); &#125; &#125; printf(&quot;%d\\n&quot;,res); for(i=1;i&lt;=n;i++)&#123; if(flag[i]) printf(&quot;%d &quot;,i); &#125; return 0;&#125; 割边对于割边其实与割点差不多只有判断条件变了一丢丢，也就是$low[v]&gt;dfn[u]$时边$$一定是割边。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2020-01-14T11:59:52.000Z","updated":"2020-02-15T04:09:06.300Z","comments":true,"path":"2020/01/14/扩展欧几里得/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"扩展欧几里得应用：计算逆元，解方程","text":"扩展欧几里得应用：计算逆元，解方程 证明方式：首先贝祖原理我大概就不解释了，直接照搬结论： $ax+by=(a,b)$;贝祖原理 $ax+by=(b,a \\% b) $;辗转相除法 假设解为$x1$,$y1$则有$a * x1+b * y1=(b,a\\%b)$ 由3式从右往左代替可得$b * x1+(a\\%b) * y1=(b,a\\%b)$;$b * x1 + (a-(a/b) * b) * y1 = (b,a\\%b)$;$a * y1 +b * (x1 - (a/b) * y1) = a * x + b * y$由上可知$x = y1,y = x1 - (a/b) * y1$。 对于上式，我们可以比较一下欧几里得求最大公约数的算法： $(a,b)=(b,a\\%b)$，一直到b等于0时结束递归，而当b等于0时的x=1,y=0; 然后又可以通过上面代数式4回退时计算出x与y的值！ 代码123456789101112ll x,y;ll ex_gcd(ll a,ll b)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll ans=ex_gcd(b,a%b); ll t=x; x=y; y=t-a/b * y; return ans;&#125; 应用逆元当求一个数字x对于p的逆元时，我们将其写成代数式将是如下形式： a * x=1%p; 对其进行化简可得a * x+y * p=1，已知x,p求a就好了化简成这样以后再看，简直就是扩展欧几里得板子！","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-02-07T13:16:21.688Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"欧拉筛欧拉函数打表简单版！","text":"欧拉筛欧拉函数打表简单版！ 欧拉筛证明：首先介绍一下算术基本原理：$x=p_1^{e1} p_2^{e_2} p_3^{e_3}$…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道任意一个合数都是由一个质数乘以一个其他数字组成！所以我们可以通过枚举一个质数和一个其他非$1$的正整数来判断来其他合数。但是为了提高其运算速率，我们想要对于任意一个合数仅判断一次时我们可以考虑，采用其最小的质数就行了，因为最小的质数只有一个且另一个非$1$正整数数仅用一次，那么任意一个合数只会判断一次咯 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;枚举非1正整数 if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123;//枚举素数 vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;//原因在下注明 &#125; &#125;&#125; break的原因是如果该循环继续下去的话(i*pri[j]的最小素数其实不是pri[j]，而是之前能被整除的那个素数，不break的话，一个合数的判断次数就会增加)","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2020-02-03T06:52:06.528Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://www.dream-ak.top/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.983Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；","text":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}