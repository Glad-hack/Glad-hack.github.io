{"meta":{"title":"孤独行者","subtitle":"心有不甘，却无以为继","description":"屡败屡战，终有一胜！","author":"无向秃","url":"https://www.dream-ak.top","root":"/"},"pages":[{"title":"折腾&自闭","date":"2019-11-26T10:37:58.000Z","updated":"2020-02-02T12:35:36.651Z","comments":true,"path":"categories/index.html","permalink":"https://www.dream-ak.top/categories/index.html","excerpt":"","text":""},{"title":"折腾&自闭","date":"2019-11-26T11:57:02.000Z","updated":"2020-02-02T12:29:03.898Z","comments":true,"path":"tags/index.html","permalink":"https://www.dream-ak.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"最短路和次短路的数量","slug":"最短路和次短路的数量","date":"2020-02-29T09:54:30.000Z","updated":"2020-02-29T14:00:46.271Z","comments":true,"path":"2020/02/29/最短路和次短路的数量/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF%E7%9A%84%E6%95%B0%E9%87%8F/","excerpt":"","text":"题目链接题意：给一个图，求1到n的最短路径和比最短路径短一个单位的路径数量有多少 思想和解法首先看到这个题目，我们第一时间就会想到最短路径数量，直接就暴力跑迪杰斯特拉然后统计一下就完事了，最多加个次短路而已，我们就按照次短路生成的方式，跑迪杰斯特拉，然后记录到达每个点的最短路数量和次短路数量。 优化最短路时就把当前次短路的数量赋值给最短路， 通过次短路优化次短路时就把前一个点的次短路数量赋值给下一个点的数量 操作想法很简单，但是这题如果大量使用空间则会爆优先队列，因此我们要注意对优先队列进行节省空间，对于每一个点能让它少入队，则少让他入队。把优化最短路时最短路和次短路的这两次入队归为一次，就会节省很多空间！所以写法再次修改为如下，分为4个步骤： 优化最短路 等于最短路 优化次短路 等于次短路代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],dis[N],dis2[N],tot=0,num1[N],num2[N];void init()&#123; memset(head,-1,sizeof head); memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); memset(num1,0,sizeof num1); memset(num2,0,sizeof num2); tot=2;&#125;void add(int u,int v,int w)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij(int x)&#123; dis[x]=0; num1[x]=1; q.push(make_pair(0,x)); while(q.size())&#123; int x=q.top().second,w = -q.top().first; //printf(&quot;%d %d\\n&quot;,x,w); q.pop(); int cnt; if(w&gt;dis2[x]) continue; if(w == dis[x]) cnt=num1[x]; else if(w==dis2[x]) cnt=num2[x]; for(int i=head[x];~i;i=ed[i].pre)&#123; int v = ed[i].id,s=ed[i].w; int cost = w + s,d=cnt; if(dis[v]&gt;cost)&#123; dis2[v]=dis[v]; num2[v]=num1[v]; dis[v]=cost; num1[v]=d; //swap(dis[v],cost); //swap(d,num1[v]); q.push(make_pair(-dis[v],v)); //printf(&quot;%d %d sss\\n&quot;,v,num1[v]); &#125; else if(dis[v]==cost)&#123; num1[v]+=d; &#125; else if(dis2[v]==cost)&#123; num2[v]+=d; &#125; else if(dis2[v]&gt;cost)&#123; dis2[v]=cost; num2[v]=d; q.push(make_pair(-cost,v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); init(); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); &#125; int p,q; scanf(&quot;%d %d&quot;,&amp;p,&amp;q); dij(p); int ans=num1[q]; if(dis[q]==dis2[q]-1) ans+=num2[q]; printf(&quot;%d\\n&quot;,ans); &#125; &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj3694-tarjan","slug":"poj3694-tarjan","date":"2020-02-29T09:28:47.000Z","updated":"2020-02-29T09:53:47.873Z","comments":true,"path":"2020/02/29/poj3694-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj3694-tarjan/","excerpt":"","text":"题目链接题意给一个连通图，问每一次加边以后还有多少条桥！ 思想和解法很明显把连通图缩点成$DAG$图，(对DAG图操作)然后每一次加边后$DAG$图里强连通分量继续缩点！桥的数量就是加边前的数量减去缩掉的边的数量。 操作问题1：缩点想法很简单，操作异想天开，如果用染色法对图进行缩点，最坏情况就是一棵N个结点的树，N-1条边每一次添加一条邻边，复杂度卡到$(1+n)* \\frac{n}{2}$。所以采用并查集动态缩点！ 问题2：路径路径寻找也是一个问题，我们已经$tarjan$缩过一次点了，我们接下来是新建一个图继续跑$tarjan$离线$LCA$吗？注意对于tarjan的LCA算法精髓在于哪里？他那么写的原因是经过了tarjan算法以后每个节点其实都有一个时间戳！而两个点$$之间的$LCA$他们有一个共同的特点，那就是: $LCA$的左子树上的所有点的时间戳都小于右子树的时间戳！ 根据这个特点我们可以直接用记录当前点的父节点然后爬到$LCA$上去。看下代码123456789101112void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--;//缩点成功则桥减一 x=get(pre[x]);//爬向缩点后的父节点 &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--;//缩点成功则桥减一 y=get(pre[y]);//爬向缩点后的父节点 &#125;&#125; 代码282ms123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 5e5+5;struct ED&#123; int pre,id;&#125;ed[N];int head[N],pre[N],fa[N],dfn[N],low[N],sta[N];int tot=0,edge=0,tim=0;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int vis[N];int get(int x)&#123; if(fa[x]!=x) return fa[x]=get(fa[x]); else return x;&#125;bool join(int x,int y)&#123; int p=get(x),q=get(y); if(p!=q)&#123; fa[p]=q;//指向父节点 return true; &#125; return false;&#125;int num=1;void tarjan(int x,int fath)&#123; low[x]=dfn[x]=++tim; vis[x]=1; int flag=1; for(int i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(v==fath&amp;&amp;flag) &#123;flag=0;continue;&#125; if(!vis[v])&#123; pre[v]=x; tarjan(v,x); low[x]=min(low[v],low[x]); if(low[v]&gt;dfn[x])&#123; edge++; &#125; else&#123; join(v,x); &#125; &#125; else&#123; low[x]=min(low[x],dfn[v]); &#125; &#125;&#125;void lca(int x,int y)&#123; if(dfn[x]&lt;dfn[y]) swap(x,y); if(get(x)==get(y)) return ; while(dfn[x]&gt;dfn[y])&#123; if(join(x,pre[x])) edge--; x=get(pre[x]); &#125; while(x!=y)&#123; if(join(y,pre[y])) edge--; y=get(pre[y]); &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)&amp;&amp;(n||m))&#123; for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++) head[i]=-1,vis[i]=0,dfn[i]=0; tim=edge=tot=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; tarjan(1,1); pre[1]=1; int q; scanf(&quot;%d&quot;,&amp;q); printf(&quot;Case %d:\\n&quot;,num++); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); lca(u,v); printf(&quot;%d\\n&quot;,edge); &#125; puts(&quot;&quot;); &#125;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"poj2763,tarjan","slug":"poj2763-tarjan","date":"2020-02-29T08:44:56.000Z","updated":"2020-02-29T09:26:55.068Z","comments":true,"path":"2020/02/29/poj2763-tarjan/","link":"","permalink":"https://www.dream-ak.top/2020/02/29/poj2763-tarjan/","excerpt":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问","text":"题目链接题意：给定一个N个节点的树，1&lt;=N&lt;=50000 每个节点都有一个权值，代表商品在这个节点的价格。商人从某个节点a移动到节点b，且只能购买并出售一次商品，问最多可以产生多大的利润。Q次询问 思想与解法 首先最暴力的想法就是去找到路径然后判断，找路径的办法就是先找到$LCA$然后暴力就完事了，很明显时间复杂度$O(N*Q)$绝对$tle$ 我们思考得到最大利润的方式，首先对于$u \\rightarrow v$可以分解为$u \\rightarrow LCA \\rightarrow v$那么最大利润将会如下三条路径中产生：1.$u \\rightarrow LCA$2.$LCA \\rightarrow v$3.$u \\rightarrow v$这时候可能有很多人会想为什么要把路径3分为路径1与路径2，明显路径3包含1和2啊。 在这里解释一下，如果只观察路径3的话，那么答案就是路径上最大的权值减最小权值，但是，无法记录访问顺序！但是这样分开以后以LCA为参考，获得每个点到$LCA$路径的最大利润，如果$u \\rightarrow v$的最大利润不在点到$LCA$的路径而是穿过路径的时，那么商人一定在$u \\rightarrow LCA$进货，在$LCA \\rightarrow v$出售。直接记录两个路径中的最大最小值然后计算就好了 操作根据分析我们需要四个数组！一个储存路径1的最大利润$up$，一个储存路径2的最大利润$down$，第三个储存路径的最大值$ma$，第四个存储最小值$mi$。然后并查集，把每一个点并到$LCA$上并更新所有数据。最后统计答案，据说卡vector。。并查集的合并操作 12345678910int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125; 卡vector我们就是用链式前向星寸询问，继而离线！$add1$函数由于我们要在合并完以后才能得到答案，所以我的办法是每一次计算完$LCA$，用链式前向星保存在$LCA上(add2)！$访问到时在计算ans。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N = 3e5+5;struct ED&#123; int pre,id;&#125;ed[N],ed1[N];int head[N],head1[N],tot,tot1,ans[N],fa[N],ma[N],mi[N],vis[N],up[N],down[N],head2[N],tot2=1;struct NUM&#123; int x,y,id,pre;&#125;num[N];void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;void add1(int u,int v)&#123; ed1[++tot1].pre=head1[u]; ed1[tot1].id=v; head1[u]=tot1;&#125;void add2(int u,int x,int y,int id)&#123; num[++tot2].id=id; num[tot2].x=x,num[tot2].y=y; num[tot2].pre=head2[u]; head2[u]=tot2;&#125;int get(int x)&#123; if(fa[x]==x) return x; int root = fa[x]; fa[x]=get(fa[x]); up[x]=max(up[x],max(up[root],ma[root]-mi[x])); down[x]=max(down[x],max(down[root],ma[x]-mi[root])); mi[x]=min(mi[x],mi[root]); ma[x]=max(ma[x],ma[root]); return fa[x];&#125;void LCA(int x)&#123; vis[x]=1; int i; for(i=head[x];~i;i=ed[i].pre)&#123; int v=ed[i].id; if(vis[v]) continue; else &#123; LCA(v); fa[v]=x; &#125; &#125; for(i=head1[x];~i;i=ed1[i].pre)&#123; int v=ed1[i].id; if(vis[v]) &#123; add2(get(v),x,v,i); &#125; &#125; for(i=head2[x];~i;i=num[i].pre)&#123; int u = num[i].x,v=num[i].y,d=num[i].id; get(u),get(v); if(d%2)&#123; ans[d]=ans[d^1]=max(up[v],max(down[u],ma[u]-mi[v])); &#125; else&#123; ans[d]=ans[d^1]=max(down[v],max(up[u],ma[v]-mi[u])); &#125; &#125;&#125;void init()&#123; memset(head,-1,sizeof head); memset(head1,-1,sizeof head1); memset(head2,-1,sizeof head2); memset(vis,0,sizeof vis); tot=tot1=tot2=1;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d&quot;,&amp;n)==1)&#123; int u,v,w; init(); for(i=1;i&lt;=n;i++) fa[i]=i; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;w); down[i]=up[i]=0; ma[i]=mi[i]=w; &#125; for(i=1;i&lt;n;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; int q; scanf(&quot;%d&quot;,&amp;q); for(i=1;i&lt;=q;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add1(u,v); add1(v,u); &#125; LCA(1); for(i=2;i&lt;=2*q;i+=2)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; &#125;&#125; 总结完美的考察对于并查集，$tarjan$的理解，对于扩展域的使用在这里像极了$dp$，也让我发现自己对于tarjan的不足。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"强连通分量","slug":"强连通分量","date":"2020-02-28T15:36:16.000Z","updated":"2020-02-28T15:59:21.225Z","comments":true,"path":"2020/02/28/强连通分量/","link":"","permalink":"https://www.dream-ak.top/2020/02/28/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/","excerpt":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。","text":"强连通分量一般用来对于整个图进行缩点，把一个有向图变成DAG图，这是强连通的一般用途，问题一般是询问要加多少条边能使整个图变成强连通图。 tarjan算法这个算法十分强大，广泛应用于$LCA$，强连通缩点等问题，他的主要思想是给每一个点打上一个时间戳，然后$dfs$去寻找每一个点$u$所能回到的最小时间戳$v$，在这个区间$$内的点是一个连通分量，然后进行缩点，这里的缩点有两种方式。 通过数组映射缩点，同一个连通分量映射同一个值 并查集缩点，同一个连通分量指向同一个根 练习题目hdu1239求加多少条边使整个图变为强连通图 思路：首先缩点，把图变成DAG图以后去看如何加最少的边使图变为强连通！很明显，对于入度为0的点必须加一条边使他能到达，出度为0的边也要加边使得到了他的边能回去，要加的最少的边就是$max(入度为0,出度为0)$； 题解代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N =2e5+5;struct ED&#123; int pre,id;&#125;ed[N*2];int head[N],tot=1;void add(int u,int v)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; head[u]=tot;&#125;int dfn[N],low[N],vis[N],dfp,sta[N],cnt=0,siz=0,col[N],in[N],out[N];void tarjan(int x)&#123; dfn[x]=++dfp; low[x]=dfp; vis[x]=1; sta[++cnt]=x; for(int i=head[x];i;i=ed[i].pre)&#123; int u=ed[i].id; if(!dfn[u])&#123; tarjan(u); low[x]=min(low[u],low[x]); &#125; else if(vis[u])&#123; low[x]=min(low[x],dfn[u]); &#125; &#125; if(dfn[x]==low[x])&#123; col[x]=++siz; vis[x]=0; while(sta[cnt]!=x)&#123; vis[sta[cnt]]=0; col[sta[cnt--]]=siz; &#125; cnt--; &#125;&#125;int main()&#123; int n,m,i,j,k,t; while(scanf(&quot;%d&quot;,&amp;t)==1)&#123; while(t--)&#123; tot=1; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); memset(head,0,sizeof head); memset(dfn,0,sizeof dfn); memset(in,0,sizeof in); memset(out,0,sizeof out); memset(low,0,sizeof low); memset(col,0,sizeof col); for(i=1;i&lt;=m;i++)&#123; int u,v; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); &#125; dfp=0,cnt=0,siz=0; for(i=1;i&lt;=n;i++)&#123; if(dfn[i]==0)&#123; tarjan(i); &#125; &#125; for(i=1;i&lt;=n;i++)&#123; for(j=head[i];j;j=ed[j].pre)&#123; if(col[i]!=col[ed[j].id])&#123; out[col[i]]++; in[col[ed[j].id]]++; &#125; &#125; &#125; int ans1=0,ans2=0; for(i=1;i&lt;=siz;i++)&#123; if(in[i]==0) ans1++; if(out[i]==0) ans2++; &#125; printf(&quot;%d\\n&quot;,max(ans1,ans2)==1?0:max(ans1,ans2)); &#125; &#125;&#125; 总结对于$tarjan$应该灵活使用并查集对其进行各种点集的合并。对于$DAG$来说我们要注意的是要实现强连通只需要计算$max$(出度0，入度0)；关于tarjan的题目之后还会找几个好题再写几次。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"分层图和次短路","slug":"分层图和次短路","date":"2020-02-16T14:34:03.000Z","updated":"2020-02-22T13:30:33.690Z","comments":true,"path":"2020/02/16/分层图和次短路/","link":"","permalink":"https://www.dream-ak.top/2020/02/16/%E5%88%86%E5%B1%82%E5%9B%BE%E5%92%8C%E6%AC%A1%E7%9F%AD%E8%B7%AF/","excerpt":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。","text":"搞了这么久，我终于感觉最短路到头了，快要结束了，来总结一下最短路。 分层图简介分层图是一个最短路的应用，他一般用来计算在一个连通图里面在可以省K条路的情况下，我们能从S到T的最短距离！做法有两种： dp 建分层图 在这里我只介绍做法2 建图我们建立k层图，两层图之间的边免费，图里面的连通情况一致。解释一下：对于k层图，如果由S走到T的话，不管是到达哪一个点，他最多经过K次免费！在这个图上面跑迪杰斯特拉，最后找最小值就好了 讲的抽象，在这里我推荐推荐一篇博客 缺陷空间占用太大，跑了两个题目差不多都是$40M$左右，dp版本会低一些，但时间复杂度不变。计算边的数组大小： 一条边要往连向下一层图同时还要连向本层图，所以一条边实际上要有$(k*2)$条边 代码题目地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;typedef long long ll;const int N = 5e5+5;struct ED&#123; int pre,id,w;&#125;ed[N*10];int head[N],tot=1,dis[N];bool vis[N];int s,t;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij()&#123; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[s]=0; q.push(make_pair(0,s)); while(q.size())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; //printf(&quot;%d %d\\n&quot;,u,v); if(dis[v]&gt;dis[u]+w)&#123; dis[v]=dis[u]+w; q.push(make_pair(-dis[v],v)); &#125; &#125; &#125;&#125;int main()&#123; int n,m,i,j,k; while(scanf(&quot;%d %d %d&quot;,&amp;n,&amp;m,&amp;k)==3)&#123; s=1,t=n; for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); for(j=1;j&lt;=k;j++)&#123; add(u+j*n,v+j*n,w); add(v+j*n,u+j*n,w); add(u+j*n-n,v+j*n,0); add(v+j*n-n,u+j*n,0); &#125; &#125; dij(); int ans=2e9+9; for(i=0;i&lt;=k;i++)&#123; ans=min(ans,dis[t+i*n]); //printf(&quot;%d\\n&quot;,dis[t+i*n]); &#125; printf(&quot;%d\\n&quot;,ans); &#125;&#125; 次短路解法 通过最短路来求 通过K短路来求 在这里我只讲通过最短路来求得解法我们得到次短路的过程分为两种 最短路更新得来得来,在更新dis[u]时，原来的$dis[u]$将会是次短路 次短路自身延申得来,在次短路$dis2[u]+min(u \\rightarrow v)$,借此更新最短路 对于这两种情况来看，1与最短路有关，2的更新方式也与迪杰斯特拉很像！所以我们这里就直接跑最短路！用优先队列维护两条路径，最短路和次短路，每一次取里面最短的。无论是最短路上的点，还是次短路上的点，因为次短路影响不了最短路，而最短路影响次短路本身就是需要的 题目：POJ3255123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=1,dis[N],dis2[N],n,m;priority_queue&lt;pair&lt;int,int&gt; &gt; q;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;void dij(int x)&#123; memset(dis,0x3f,sizeof dis); memset(dis2,0x3f,sizeof dis2); dis[x]=0; q.push(make_pair(-dis[x],x)); while(q.size())&#123; int u=q.top().second,w=-q.top().first; q.pop(); if(dis2[u]&lt;w) continue;//这里是剪枝，看注释一。 for(int i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id,d=w+ed[i].w; if(d&lt;dis[v])&#123; swap(d,dis[v]);//这里只能是交换，因为dis[v]还要给次短路用 q.push(make_pair(-dis[v],v)); &#125; if(d&lt;dis2[v]&amp;&amp;d&gt;dis[v])&#123; dis2[v]=d; q.push(make_pair(-dis2[v],v)); &#125; &#125; &#125; printf(&quot;%d\\n&quot;,dis2[n]);&#125;int main()&#123; int i,j,k; while(scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2)&#123; memset(head,0,sizeof head); for(i=1;i&lt;=m;i++)&#123; int u,v,w; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u,v,w); add(v,u,w); &#125; dij(1); &#125;&#125; 注释一：因为对于次短路的更新，我们会在优先队列里面增加一些无用边，就像最短路时的vis数组一样的性质，把那些多余的边全部去掉，而这里只需要路径长度小于等于次短路的，所以大于的直接continue！","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"双调欧几里得旅行商问题","slug":"双调欧几里得旅行商问题","date":"2020-02-11T15:37:49.000Z","updated":"2020-02-12T05:31:41.933Z","comments":true,"path":"2020/02/11/双调欧几里得旅行商问题/","link":"","permalink":"https://www.dream-ak.top/2020/02/11/%E5%8F%8C%E8%B0%83%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/","excerpt":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl","text":"刷最短路刷着刷着怎么老遇神题，太玄学了，tcl 题目链接题意，给予n个点的坐标，要求从第1个点走到第n个点然后再走回来且去的时候点的序号单调递增，回来的时候单调递减！ 思路说句实在的我第一眼居然是弗洛伊德然后掉坑底怕都没爬出来。正解是$dp$,怎么$dp$呢 我们假设$dp[i][j]$中$i$为从第i个点回到1号点，$j$为从1号点回到$j$号点，而$dp[i][j]$则是这个过程的最短距离。 按着这个定义来看，$dp[i][j]=dp[j][i]$。解释一下：我们对于这个问题来说$i \\rightarrow 1 \\rightarrow j \\Leftrightarrow j \\rightarrow 1 \\rightarrow i$ 那么首先假设$i&lt;j$的dp方程： $i=j$ 时则有$dp[i][j]=dp[i-1][j]+dis(i-1,j)$解释：i \\rightarrow 1 \\rightarrow j \\Leftrightarrow i \\rightarrow (i-1) \\rightarrow 1 \\rightarrow j $i+1 &lt; j $时，则有$dp[i][j]=dp[i][j-1]$解释：i < j(i只能连小于i的边) \\Rightarrow (j-1) \\rightarrow j $i+1=j$则$dp[i][j]=min(dp[i][j],dp[k][j-1]+dis(k,j))(k=1,2···,j-2 $解释：因为这个时候就是相当于在路径$k \\rightarrow 1 \\rightarrow i$中加一条边$j\\rightarrow k$则会得到$j\\rightarrow 1 \\rightarrow i$且$k!=j-1$因为$(j-1) \\rightarrow 1 \\rightarrow (j-1) \\rightarrow j$一定不会是最短路径，因为$j-1$点重复一次的话，假设是$x \\rightarrow j-1 \\rightarrow j$的长度按照三角形边长来看会发现$x\\rightarrow j$的边长一定小于等于前一条边。 由上三种状态可以发现我们要得到$dp[i][j]$首先就要知道$dp[i][j-1]$和$dp[i-1][j]$那么我们可以先对$j$进行遍历得到$dp[i][j-1]$，然后再从小到大遍历$i$就会得到$dp[i][j]$。 代码12345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;const int N = 300;double dp[N][N];struct ed&#123; double x,y;&#125;a[N];double dis(int i,int j)&#123; return sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d&quot;,&amp;n)==1) &#123; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%lf %lf&quot;,&amp;a[i].x,&amp;a[i].y); &#125; dp[1][2]=dis(1,2); for(j=3;j&lt;=n;j++)&#123; for(i=1;i&lt;j-1;i++) dp[i][j]=dp[i][j-1]+dis(j,j-1); dp[j-1][j]=2e9+9; for(i=1;i&lt;j-1;i++) dp[j-1][j]=min(dp[j-1][j],dp[i][j-1]+dis(i,j)); dp[j][j]=dp[j-1][j]+dis(j-1,j); &#125; printf(&quot;%.2lf\\n&quot;,dp[n][n]); &#125; &#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束系统复习","slug":"差分约束系统复习","date":"2020-02-09T15:08:02.000Z","updated":"2020-02-10T03:34:32.817Z","comments":true,"path":"2020/02/09/差分约束系统复习/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/","excerpt":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。","text":"spfa对于模拟队列时，队列数组要开的尽量大！ spfa对于记录一个点的松弛次数应该是入队次数，而不是松弛次数。 来个板子：12345678910111213141516171819bool spfa(int t)&#123; int l=1,r=0; que[++r]=0; dis[0]=0; while(l&lt;=r)&#123; int u=que[l++]; int i; vis[u]=0; for(i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].id,w=ed[i].w; if(dis[u]+w&gt;=dis[v])&#123; dis[v]=dis[u]+w; if(num[v]&gt;t) return false; if(vis[v]==0) que[++r]=v,vis[v]=1,num[v]++;//(num在这里重点注意); &#125; &#125; &#125; return true;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展域","slug":"扩展域","date":"2020-02-09T11:07:38.000Z","updated":"2020-02-10T03:34:07.113Z","comments":true,"path":"2020/02/09/扩展域/","link":"","permalink":"https://www.dream-ak.top/2020/02/09/%E6%89%A9%E5%B1%95%E5%9F%9F/","excerpt":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！","text":"看到学弟们都不会，那我就给个题解吧，免得一直不会，留漏洞！ 题目链接题意题意明显就是给$[l,r]$中有奇数个1还是偶数个1，然后看它第一次在哪里自相矛盾了，输出第一次自相矛盾的位置！ 思路首先离散化这个我就不说了，你们百度一下什么原理。假设$[l,r]$中奇数个1表示为1，偶数个1表示为0。那么我们每一次合并$(l-1,r]$这个区间，这样就可以把所有数据都联系起来。合并并查集：如何合并？我们那么我们就可以通过 $x \\rightarrow root1$(根节点)的值$d[x]$ $y \\rightarrow root2$(根节点)的值$d[y]$ 得出$root1 \\rightarrow root2$的值。假设$root1$和$root2$相同则判断一下去看这组数据是否正确。判断方法： $x \\rightarrow root1 = d[x]$ $y \\rightarrow root1 = d[y]$ $x \\rightarrow y = x \\rightarrow root1 \\rightarrow y = d[x]$^$d[y]$ 不同则是： $root1 \\rightarrow root2$的值是 $d[x]$ ^ $d[y]$ ^ $n$（$n$为$x \\rightarrow y$）这个就会得到关系的值 解释$x \\rightarrow y = n$$x \\rightarrow root1 = d[x]$$y \\rightarrow root2 = d[y]$则$root1 \\rightarrow root2 = root1 \\rightarrow x \\rightarrow y\\rightarrow root2 = d[x]$ ^ $d[y]$ ^ $n$ 怎么压缩路径 $x \\rightarrow y = d[x]$$y \\rightarrow root = d[y]$那么 $x \\rightarrow root = d[x]$^$d[y]$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;const int N = 5e3+5;int fa[2*N],d[2*N];int get(int x)&#123; if(fa[x]==x) return x; int root = get(fa[x]); d[x]^=d[fa[x]]; return fa[x] = root;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d&quot;,&amp;m); scanf(&quot;%d&quot;,&amp;n); int l[N],r[N],c[N],a[N*2],b[N*2]; char s[5]; int cnt=0; for(i=1; i&lt;=n; i++) &#123; scanf(&quot;%d %d %s&quot;,&amp;l[i],&amp;r[i],s); if(s[0]==&apos;o&apos;) c[i]=1; else c[i]=0; a[++cnt]=--l[i],a[++cnt]=r[i]; &#125; sort(a+1,a+1+cnt); int cnt1=0; for(i=1; i&lt;=cnt; i++) &#123; if(i==1||a[i]!=a[i-1]) b[++cnt1]=a[i]; &#125;//离散化操作，我就不说了 for(i=0; i&lt;=cnt1; i++) fa[i]=i,d[i]=0;//初始化操作 for(i=1; i&lt;=n; i++) &#123; int l1=lower_bound(b+1,b+1+cnt1,l[i])-b; int r1=lower_bound(b+1,b+1+cnt1,r[i])-b; int fl=get(l1),fr=get(r1); if(fl!=fr)//不在同一个集合，不会冲突 &#123; fa[fr]=fl; d[fr]=c[i]^d[r1]^d[l1]; &#125; else//在同一个集合，可能冲突！ &#123; if(d[r1]^d[l1]!=c[i]) &#123; printf(&quot;%d\\n&quot;,i-1); return 0; &#125; &#125; &#125; printf(&quot;%d\\n&quot;,n);//如果全部没错，就输出最后一个答案&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"爬虫","slug":"爬虫","date":"2020-02-08T12:12:03.000Z","updated":"2020-02-11T14:16:08.118Z","comments":true,"path":"2020/02/08/爬虫/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%88%AC%E8%99%AB/","excerpt":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧)","text":"爬了几个网站以后感觉自己还有好多不会的，先来看一下爬虫的基础，在复习复习，emmm，没有需求就没有学习的动力啊(或许这就是我菜的原因吧) 爬虫的四个步骤 获取数据：爬虫根据我们的输入的网址进行访问，让后返回一系列的数据 解析数据：对于数据我们需要把返回的数据进行解析成我们能读懂的表达式 提取数据：从我们需要的地方，我们需要对这些数据进行提炼，获取我们所需要的数据。 保存数据：把我们已经获得的数据保存起来，方便阅读！ 爬虫的原理一般都是这样，而反爬虫一般都是利用js等各种诡异的框架来妨碍我们获取需要的数据，当然还有通过直接封IP的，但是他的误伤率很高，因为IP换人的速度太快，不知道封多久。（等以后真正确定了，再把删除线叉掉） 获取数据我们一般是通过$requests$模块来获取数据。这里说明一下$requests$的功能： 发起get(‘url’,**kw)请求，这是常用的获取数据的方法，kw一共是12个参数！在后面有介绍。 post()提交请求，对应于HTTP的post部分 put()请求，对应于HTTP的PUT部分 patch()，向html网页提交局部修改请求，对应于HTTP的patch delete()，向html网页提交删除请求，对应于HTTP的delete head(),获取头信息的方法，对应于HTTP的get requests()，构造请求，支撑以下所有基础方法 requests的get调用$get(‘url’,params=None,**kwargs)$其中$kwargs$一共有12个参数： $response$对象在对于一个请求后返回的对象就是$response$对象，这种对象支持4种操作 首先编码response.status_code()返回一个状态值，其中200为获取成功 response.context()获取的数据返回。 response.encoding定义了编码，我们可以使用response.apparent_encoding来自动获取编码，也可以自己从网站自己找编码方式 response.text()返回一个字符串 通过headers来模拟浏览器向网站发起请求我们先获得自己的代理然后添加headerget(‘url’,headers = user-agent) 通过修改params参数提交我们在获取网页时加上一个自己想要访问的参数，kw=’want’get(“url”,kw)就会在网页上获得自己想要的数据了哟 解析数据我们获取了一个数据要怎么解析呢？这里我用的是$beautifulsoup$解析的网页。首先$beautifulsoup$不是标准库，所以我们先安装： pip install beautifulsoup4 使用简单我们直接调用就好了text = BeautifulSoup(str,’html.parser’)这样子我们就会把text变成一个BeautifulSoup对象，这样操作的原因BeautifulSoup对象在后面的提取数据中成了必要条件，所以必须要转对象同时str必须为字符串！ 提取数据emmm，这里用beatifulsoup提取数据。这里提取是通过find与find_all来提取他俩的功能是匹配html的标签和属性，把BeautifulSoup对象里符合要求的数据都提取出来。区别在于，find()只提取首个满足要求的数据，而find_all()提取出的是所有满足要求的数据。示例中是class_的原因是与类(class)区别，除了对class属性的匹配以外，还可以与其他的例如style进行匹配哦。这个函数返回的值是一个Tag对象！Tag属性请参考：首先Tag的find和find_all返回的也是Tag对象！Tag.attrs生成一个字典[‘id’:key] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestsfrom bs4 import BeautifulSoupimport osimport reimport timedef get(id): headers = &#123;&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&apos;&#125; url = &apos;https://movie.douban.com/top250?start=&apos; + str(id) + &apos;&amp;filter=&apos; rem = requests.get(url,headers = headers) rem.encoding = &quot;utf-8&quot; print(rem.status_code) html = rem.text path = os.path.abspath(&apos;.&apos;) #with open(path+&apos;/豆瓣电影/html1.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: # f.write(html) link = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot; class=&quot;&quot;&gt;&apos;,html) num=0 for x in link: time.sleep(1) num+=1 rem = requests.get(x,headers = headers) rem.encoding=&apos;utf-8&apos; html2 = BeautifulSoup(rem.text,&apos;html.parser&apos;) title = html2.find_all(&apos;span&apos;,property=&quot;v:itemreviewed&quot;) print(title[0].text) post = html2.find_all(&apos;span&apos;,class_ = &apos;all hidden&apos;) #print(post) if not post: post=html2.find_all(&apos;span&apos;,property=&quot;v:summary&quot;) playvideo = html2.find_all(&apos;a&apos;,class_=&quot;playBtn&quot;) free = html2.find_all(&apos;span&apos;,class_=&quot;buylink-price&quot;) flag = &apos;￥&apos; for i in free: s = str(i.text) if len(s)==50: flag=&apos;@&apos; with open(path+&apos;/豆瓣电影/&apos;+str(num)+str(flag+title[0].text)+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f: for i in post: f.write(str(i.text)+&apos;\\n&apos;) for i in playvideo: i.attrs//生成一个字典[&apos;id&apos;:&quot;key&quot;] f.write(str(i[&apos;data-cn&apos;])) f.write(str(i[&apos;href&apos;])+&apos;\\n&apos;) #print(i[&apos;data-cn&apos;],i[&apos;href&apos;])if __name__ == &quot;__main__&quot;: get(0) 爬虫伦理任何一个领域都有一些公约，那么爬虫也是如此，对于一个网站我们的公约是在网站后面添加一个$robots.txt$，你就可以查阅了。 总结爬虫过程find适用对象最后感谢大佬带我入坑","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"类的学习","slug":"类的学习","date":"2020-02-08T05:33:36.000Z","updated":"2020-02-08T12:09:19.350Z","comments":true,"path":"2020/02/08/类的学习/","link":"","permalink":"https://www.dream-ak.top/2020/02/08/%E7%B1%BB%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！","text":"本来打算继续学习爬虫的，但是看了一下好多对象的东西要用，就还是决定先学一下$python$的类与对象算了。也算是我第一次接触对象和类了。大学一年多了，都没碰过对象和类，我真的菜！ 类什么是类？类就是一种抽象的模板，就像月饼的模具一样，我们要做月饼，那么就有一个模具，在这里我们称之为类。 类的定义类的定义是由一个class定义的，一般应用时我们如下面代码一般定义1234class Cat(object): # 类的属性 # 类的行为 一个类的命名通常采用大驼峰式，也就是第一个字母大写。 对于一个类来说，我们通常定义两种类别的东西，一个叫做类的属性，一个叫做类的行为。既然是一个类那么一定有自己的属性，例如：颜色，外观，味道等等。也会有自己的行为，例如：跑，运，发霉，生锈等等动作。 我们对于一个类定义时后面的参数是类的父类，当没有父类时，我们选择放上$object(python3)$ 类的属性对于一个类的属性写法在这里我们了解下面这个函数$def$ $init$($self$,自定义参数):这个函数的用途从单词词义来看就知道叫做初始化。我们在声明对象时，我们会默认运行此函数，那么我们就可以用这个来定义默认类的属性，对于$self$这里暂时不解释，提醒一下，类的所有函数都必须含有此参数。 类的行为我们对于这个类的行为可以看成我们要这个类的所有的东西可以做什么，比如我们要月饼都运往安徽，那么我们只需要在模板里面写上一个行为“运往安徽”，那么按照这个模板生成的月饼都会运往安徽咯！写法：12def 函数名(self,自定义参数): xxxxx下面xxx代表具体行为，看上去除了$self$以外和其他的函数没有什么差别了。这样就会产生一个简单的类 对象说了那么久的类，那么对象又是什么呢？那就是一个由月饼模板做的月饼了，直接由模板复制出来的。那么对象有是怎么定义的呢？我们一般采用：对象名 = 类()注意后面有个括号哟。我们对于这个对象有些什么操作呢？因为$python$是动态语言，其实我们可以随时对这个对象进行增加属性！ 看代码1234567891011class Moon(object): def __init__(self): self.price = &quot;10￥&quot; self.to = &quot;安徽&quot; def sold(self,price1): print(&quot;原价：%s&quot; % self.price) print(&quot;售价：%s&quot; % price1) returnif __name__ == &quot;__main__&quot;: moon = Moon() moon.sold(&quot;12￥&quot;) 这样$init$就是定义属性,$sold$就是一个行为函数了 数据封装看了一下廖雪峰大神的博客，封装就是执行操作时，不需要对一个类里面的数据进行访问，直接把操作放在类里面，以后调用时就不用考虑类里面的行为咯，像极了我的行为函数啊。hhh","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"zoj2770差分约束","slug":"zoj2770差分约束","date":"2020-02-07T12:54:48.000Z","updated":"2020-02-07T12:57:37.371Z","comments":true,"path":"2020/02/07/zoj2770差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/02/07/zoj2770%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"emmm,好久没刷题，手感都快没了，先来养下手感","text":"emmm,好久没刷题，手感都快没了，先来养下手感 题目链接题意大概就是给我们$n$个营地，$c[i]$表示第$i$个营地最多的人数，第$u$-第$v$个营地一共有$w$个人。问最少有多少人。对于这种题型，我们一般做法是首先确定一个数组表示前面$i$个营地的总人数 挖掘隐藏条件，每一个营地的人数不可能为负数，所以$a[i]-a[i-1]\\geq0$每个营地最多有$i$人，我们可以知道，$a[i]-a[i-1]\\leq c[i]$$u-v$一共最少有$w$人，我们可以得出，$a[u]-a[v-1]\\geq w$ 我们可以把第二个条件化简为 a[i]-a[i-1]\\leq a[i] \\rightarrow a[i-1]-a[i] \\geq -c[i]由上化简，我们就把所有的代数式换成了大于等于的形式，开始建图了题目要求的是最小的人数，那么也就是$min(a[n]-a[0])$那么我们就可以这么建图： 我们按照从被减数向减数建一条边，边权为右边的值。 这样建图有什么好处？因为我们要求的是$min(a[n]-a[0])$，而我们这么建图就会使源点$0$到达的任意一个$v$最长路长度都是最少的人数，为什么是最长路？大于等于符号决定的呀，当大于等于时，只有最长路不会和其他方向的边冲突，小于等于时，我们只有最短路不会和其他方式的边冲突。接下来看代码，spfa版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;//#include&lt;windows.h&gt;using namespace std;const int N = 2e5+5;int deq[N*2],a[N],head[N],tot=0;struct ED&#123; int pre,to,w;&#125;ed[2*N];int vis[N],dis[N],num[N];void spfa(int x)&#123; memset(dis,-1,sizeof dis); memset(vis,0,sizeof vis); memset(deq,0,sizeof deq); memset(num,0,sizeof num); dis[0]=0; int l=1,r=0; deq[++r]=0; while(l&lt;=r)&#123; int u=deq[l]; l++; vis[u]=0; //printf(&quot;%dsss\\n&quot;,u); for(int i=head[u];~i;i=ed[i].pre)&#123; int v=ed[i].to; //printf(&quot;%d %d %d %d %d\\n&quot;,u,v,dis[u],ed[i].w,dis[v]); if(dis[v]&lt;dis[u]+ed[i].w) &#123; dis[v]=dis[u]+ed[i].w; if(vis[v]) continue; deq[++r]=v; num[v]++; if(num[v]&gt;=x) &#123; printf(&quot;Bad Estimations\\n&quot;); return ; &#125; vis[v]=1; //printf(&quot;%d %d\\n&quot;,u,v); &#125; &#125; &#125; if(dis[x]==-1)&#123; printf(&quot;Bad Estimations\\n&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;,dis[x]); &#125;&#125;void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].to=v; ed[tot].w=w; head[u]=tot;&#125;int main()&#123; int n,m,i,j,k; while (scanf(&quot;%d %d&quot;,&amp;n,&amp;m)==2) &#123; tot=0; for(i=0;i&lt;=n;i++)&#123; head[i]=-1; &#125; for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); add(i-1,i,0); add(i,i-1,-a[i]); &#125; int u,v,w; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); add(u-1,v,w); &#125; spfa(n); &#125; //system(&quot;pause&quot;);&#125;不用队列，方便优化","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"python爬取王者数据","slug":"python爬取王者数据","date":"2020-02-06T10:24:34.000Z","updated":"2020-02-08T13:29:30.494Z","comments":true,"path":"2020/02/06/python爬取王者数据/","link":"","permalink":"https://www.dream-ak.top/2020/02/06/python%E7%88%AC%E5%8F%96%E7%8E%8B%E8%80%85%E6%95%B0%E6%8D%AE/","excerpt":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧","text":"正则已经学完了，就要开始玩爬虫了呀，我们首先爬一个王者的数据，来好好看看吧 $requests$首先我们安装这一个requests模块，在终端输入 pip install requests 利用$r=requests.get()$来进行对一个网页的获取，返回一个二进制字符串，为了不把字符转乱码，我们一般使用正确的编码格式，这个编码格式一般在网页上写着！或者使用$r.apparent_encoding$的函数自动获取，不过不保证完全准确！转字符串时可以使用$html=r.text$返回字符串，详情请看爬虫这篇博客 强行爬虫在爬https://www.vmgirls.com 时会发现不允许爬取，那么有一个玄学的爬取方法，这个网站是通过判断代理服务来判断是不是爬虫，在requests时会发送一个爬虫请求，该网站如果发现是爬虫时，那么我们就可以把requests发送的代理服务改掉,通过在$requests(‘https://vmgirls.com/&#39;,headers=&quot;本地代理&quot;)$。本地代理可以在网页上查看！ $re.findall()$我们一般使用这个来获取自己需要的信息。 ()括号内表示需要的信息，没有括号则表示不需要的信息 []匹配时我们需要写一个自己的字符分类，然后去选择自己的信息 findall(r’’,txt)是格式,r后跟着自己的匹配方式。 os文件读写： 对于文件读写我们一般是使用$with$ $open(“文件路径”,’读写方式’,’encoding=编码规则’) as f:$ 对于文件路径可以使用绝对路径，编码规则须和字符串的编码规则相同。 time为了网站的稳定性能我们一般要去使用$time.sleep()$来控制爬取速度。 最后来看一下我们是如何爬取王者的：1234567891011121314151617181920212223242526272829303132import requestsimport reimport osimport timer = requests.get(&apos;https://pvp.qq.com/web201605/herolist.shtml&apos;)r.encoding=&quot;gbk&quot;html = r.texthttp = &quot;https://pvp.qq.com/web201605/&quot;dirs = os.path.abspath(&apos;.&apos;)dir_name = re.findall(r&apos;&lt;li&gt;&lt;a href=&quot;([a-z0-9/.]*)&quot; target=&quot;_blank&quot;&gt;&lt;img+\\s&apos;,html)for i in dir_name: time.sleep(1) r = requests.get(http+i) r.encoding=&apos;gbk&apos; html1=r.text hero = re.findall(r&apos;&lt;h2 class=&quot;cover-name&quot;&gt;(.*?)&lt;/h2&gt;&apos;,html1) print(hero) skin = re.findall(r&apos;&lt;ul class=&quot;pic-pf-list pic-pf-list3&quot; data-imgname=&quot;([\\S]*)&quot;&gt;&apos;,html1) skill_name = re.findall(r&apos;&lt;p class=&quot;skill-name&quot;&gt;&lt;b&gt;(.*?)&lt;/b&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;span&gt;(.*?)&lt;/span&gt;&lt;/p&gt;&apos;,html1) skill_decs = re.findall(r&apos;&lt;p class=&quot;skill-desc&quot;&gt;(.*?)&lt;/p&gt;&apos;,html1) skill_tips = re.findall(r&apos; &lt;div class=&quot;skill-tips&quot;&gt;(.*?)&lt;/div&gt;&apos;,html1) lens = len(skill_tips) with open(dirs+&apos;/&apos;+&apos;王者荣耀&apos;+&apos;/&apos;+hero[0]+&apos;.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;) as f: f.write(&quot;英雄名称：&quot;+hero[0]+&apos;\\n&apos;) f.write(&quot;皮肤：&quot;+skin[0]+&apos;\\n\\n&apos;) for j in range(0,lens,1): f.write(&quot;技能名称：&quot;+skill_name[j][0]+&apos;\\n&apos;) f.write(&quot;技能冷却：&quot;+skill_name[j][1]+&apos;\\n&apos;) f.write(&quot;技能消耗：&quot;+skill_name[j][2]+&apos;\\n&apos;) f.write(&quot;技能描述：&quot;+skill_decs[j]+&apos;\\n&apos;) f.write(&quot;技能用途：&quot;+skill_tips[j]+&apos;\\n&apos;) f.write(&apos;\\n&apos;) 还是有点不会写文件的保存格式，呜呜呜，只会狂写编码了。。。最后来看一下效果：","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2020-02-05T10:48:23.000Z","updated":"2020-02-06T13:01:44.067Z","comments":true,"path":"2020/02/05/正则表达式/","link":"","permalink":"https://www.dream-ak.top/2020/02/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$","text":"$emmmm$，开始来学一些能够飘得的玩意了，虽然以前我玩过这个$python$的爬虫，但是今天来系统学习一下，$hhh$ 正则表达式匹配方式 字符表达 意义 例子 例子解释 \\d 匹配一个数字 \\d{3} 匹配三个数字 \\w 匹配一个字母 \\w{3} 匹配三个字母 ? 可选匹配，前面括号内符号可以匹配一次或者零次 (wo)?man 匹配man或者woman * 匹配零次或多次 (wo)*man 代表可以匹配man、wowoman等等 + 匹配一次或多次 ((wo)+man) 代表可以匹配woman、wowoman等等 {} 指定匹配次数 (wo){2,5}man 可以匹配wo重复2到5遍的此类字符串 1 管道，指定多种字符模式，返回第一次出现的文本它是一竖 ‘Batman 1 Tina Fey’ 表示查找Batman和Tina Fey的第一次出现的字符 ^ 直接从头开始匹配 ^hello 从头开始匹配hello $ 必须以该字符结束 3$ 必须以3结尾 正则匹配是一种贪心匹配(能长则长)，而花括号的匹配是一种非贪心匹配(能短则短) search：每一次返回第一次找到的字符串 findall：返回整个text的所有的字符串 字符分类字符表达式 字符分类 表达式 \\d 0到9的任何数字 \\D 除0到9的任何数字 \\w 任何字母、数字、下划线字符 \\W 除字母、数字、下划线字符外的任意字符 \\s 空格、制表符、换行符 \\S 除空格、制表符、换行符以外的任意字符 . 匹配除换行以外所有字符 .* 匹配所有字符 建立自己的字符分类 [quit]表达可以匹配quit里面的任意一个字符 [ ^quit ]表达非quit里面任意一个字符的字符可以通过短横来表达字母或数字的范围[a-zA-Z0-9]将匹配所有字母和数字 文本替换正则表达式不仅能找到文本模式，而且能够用新的文本替换掉这些模式。$Regex$对象的 $sub()$方法需要传入两个参数。第一个参数是一个字符串，用于取代发现的匹 配。第二个参数是一个字符串，即 正则表达式。$ sub()$方法返回替换完成后的字符串。举个例子： &gt;&gt;&gt; namesRegex = re.compile(r&#39;Agent \\w+&#39;) &gt;&gt;&gt; namesRegex.sub(&#39;CENSORED&#39;, &#39;Agent Alice gave the secret documents to Agent Bob.&#39;) &#39;CENSORED gave the secret documents to CENSORED.&#39;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://www.dream-ak.top/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python刷题","slug":"python刷题","date":"2020-02-04T05:47:10.000Z","updated":"2020-02-04T05:55:22.525Z","comments":true,"path":"2020/02/04/python刷题/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/python%E5%88%B7%E9%A2%98/","excerpt":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划","text":"终于$python$有点上道了，开始我的磕磕绊绊刷题计划 一行内多次输入1n,m=int(input.slipt()) 这样就可以一行输入两个数了，hhh(抄的) 一行多输出1print(&apos; &apos;.join(map(str,a))) 这个能把一个数组中间加入空格并输出。 看题目现在来看$Nod51$题目：冒办法，我找了半天就只有$codeforce$和$Nod51$支持$python3$了 全排列题面很好懂，解法很好想，就是被输出卡了。。。12345678910111213a = []n,m=map(int,input().split())def dfs(l,r): if m==r: print(&apos; &apos;.join(map(str,a))) return else : for i in range(l+1,n+1,1): a.insert(r,i) dfs(i,r+1) a.pop(r) return dfs(0,0) a序列放前面一点就能被后面函数调用了，hhh，强行全局","categories":[{"name":"python刷题","slug":"python刷题","permalink":"https://www.dream-ak.top/categories/python%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"map与reduce","slug":"map与reduce","date":"2020-02-04T03:19:31.000Z","updated":"2020-02-04T03:21:46.520Z","comments":true,"path":"2020/02/04/map与reduce/","link":"","permalink":"https://www.dream-ak.top/2020/02/04/map%E4%B8%8Ereduce/","excerpt":"","text":"","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"函数","slug":"函数","date":"2020-02-03T09:04:38.000Z","updated":"2020-02-04T02:37:43.781Z","comments":true,"path":"2020/02/03/函数/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E5%87%BD%E6%95%B0/","excerpt":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh","text":"终于到激动人心的时刻了，我们开始学习$python$函数了，有点小快啊，hhh 函数定义$def$定义一个函数要使用$def$语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。拿一个从$l$加到$r$的和的函数来讲12345678def sum(l,r): sum = 0 for i in range(l,r+1,1): sum += i return suml = int(input(&quot;l=&quot;))r = int(input(&quot;r=&quot;))print(sum(l,r)) $output$l=1r=1005050 位置参数比如上面的参数就叫做位置参数，调用$sum$函数时，必须给予两个固定参数 默认参数看一个代码 1234def mul(a,b = 3): print(a*b)mul(2)mul(2,4) $output$68 这个和上面的参数比较不同点在于，在定义参数的时候对一个参数赋值，这种写法叫做默认参数 特性我们调用函数时，对于默认参数可以选择性增加调用值。更大的符合了用户的情况 注意 对于默认参数我们一般默认，变化大的在前，变化小的在后 且对于默认参数放在位置参数以后 对于默认参数赋值必须赋为不变对象 可变参数可变参数：调用时，输入的长度可以是任意个。在传入以后自动组成一个$tuple$比如我们要对一个$list$或$tuple$进行和运算，由于每一个$list$的长度不定。所以我们需要一个可变参数。来看一个代码 123456789def sum1(*lis): sum = 0 for i in lis: sum += i return suma = [1,2,5,7]b = [5,9,8]print(sum1(*a))print(sum1(*b)) $output$1522 可以发现，好像就是C语言传入指针了，对的，C语言遮掩好像也可以，就是长度问题而已。下面这些要用的时候再补充吧，暂时请参考廖雪峰 关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。他的功能，给与用户想给的一些多余的信息，也可以进行收集。 命名关键字参数对于关键字参数进行一定的限制","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"dict和set","slug":"dict和set","date":"2020-02-03T07:01:13.000Z","updated":"2020-02-22T06:45:45.189Z","comments":true,"path":"2020/02/03/dict和set/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/dict%E5%92%8Cset/","excerpt":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧","text":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧 $dict$$dict$的结构这里按照廖雪峰的介绍给出两种方式 按照字典树的方式建立一棵字典树，优点不会出现冲突，可直接使用，缺点相较于哈希来说，查找较慢 直接建立一个哈希表，每一次按照$key$直接哈希地址然后得到答案，优点，查找方便。缺点：容易出现哈希冲突。 $dict$是第二种建立方式，因此$key$的值是唯一的，不可重复，如果重复了那么就会将前面得到的数据丢失冲掉。 $dict$的建立首先来看一段代码 1234a=&#123;&#125;a[&apos;peng&apos;] = 4a[&apos;我&apos;] = 5print(a[&apos;我&apos;]) $output$5 可以看到我们是通过大括号{}来定义一个空$dict$然后添加直接赋值就好了。调用直接访问$key$就行了，但是一定要保证这个$key$存在。判断$key$存在性的办法： $print(‘我’\\ in\\ a) $如果存在，返回$true$。不存在返回false。 $print(a.get( ‘我’,x))$当不存在‘我’时返回$x$值 $dict$的删除这个的删除我们前提是$key$存在,如果存在，我们就可以像$list$一样删除它。 12a.pop(&apos;peng&apos;)print(a.get(&apos;peng&apos;,777)) $output$777 注意$dict$可以用在需要高速查找的很多地方，在$Python$代码中几乎无处不在，正确使用$dict$非常重要，需要牢记的第一条就是$dict$的key必须是不可变对象。 这是因为$dict$根据$key$来计算$value$的存储位置，如果每次计算相同的$key$得出的结果不同，那$dict$内部就完全混乱了。这个通过$key$计算位置的算法称为哈希算法$（Hash）$。 要保证$hash$的正确性，作为$key$的对象就不能变。在$Python$中，字符串、整数等都是不可变的，因此，可以放心地作为$key$。而$list$是可变的，就不能作为$key$ $set$$set$一般用于去重和集合操作，它可以对集合进行”与”、”或”操作. 创建创建一个空$set$1a = set() 创建一个$set$我们一般是要一个$list$做输入集合看一段代码123l = [1,1,5,9,3,8,9]a = set(l)print(a) $output${1, 3, 5, 8, 9} 很明显它自己去重了，同时不要被表面所迷惑$set$是无序的 $set$怎么添加元素？答案下行揭晓$a.add(x)$参数$x$是你要添加的$key$12a.add(2)print(a) $output${1, 2, 3, 5, 8, 9} 删除元素我们一般通过$a.remove(x)$删除,$x$是你要删除的$key$12a.remove(2)print(a) $output${1, 3, 5, 8, 9} 集合操作直接&amp;或者|就好了123b=set([1,2])print(a&amp;b)print(a|b) $output${1}{1, 2, 3, 5, 8, 9} 不可变变量字符串属于不可变变量，同时$list$是一个可变变量。123a = &quot;abc&quot;print(a.replace(&apos;a&apos;,&apos;A&apos;))print(a)","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"条件与循环","slug":"条件与循环","date":"2020-02-03T06:31:15.000Z","updated":"2020-02-04T02:12:54.899Z","comments":true,"path":"2020/02/03/条件与循环/","link":"","permalink":"https://www.dream-ak.top/2020/02/03/%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/","excerpt":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进","text":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进 $if$判断首先我们来看一段代码12345socre=int(input())if score&gt;=60: print(&quot;pass\\n&quot;)else : print(&quot;No pass\\n&quot;)这个就可以把你的分数转化成过和没过了，挂科了没，一目了然！对于这段代码的解释我就对他与C语言的比较了。没有C语言的小括号，$if$后面全是判断一直到$’:’$对于else 我们也需要$’:’$如果进行多次判断由C语言的$else if$ $\\rightarrow$ $elif 判断:$ 循环$for$ … $in$循环这种循环我们一般是用一个变量每一次迭代$in$里面的内容(可以是$list,tuple$等数据结构)，比如 123456789101112131415161718x=(5,2,0)for i in x: print(i)``` &gt; $output$520## $for$ ... $in$ $range(x,y,z)$循环我们看这个循环 其中省略号代表变量，我们假设为$i$现在来解释一下参数1. $x$代表$i$的初始值2. $y$代表$i$的上界或下界,**不得小于等于$y$**3. $z$代表$i$的步进大小每一次加上多少来看一段代码 for i in range(3,1,-1): print(i)``` $output$32","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"list和tuple","slug":"list和tuple","date":"2020-02-02T13:34:09.000Z","updated":"2020-02-03T06:52:06.529Z","comments":true,"path":"2020/02/02/list和tuple/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/list%E5%92%8Ctuple/","excerpt":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。","text":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。 $list$这种数据类型使列表 $list$是一种有序的集合，可以随时添加和删除其中的元素。对于这个我们可以看下面这个例子12a=[&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;]print(a) $ output$:$[‘s’, ‘a’, ‘r’, ‘s’]$ 而一个$list$的长度怎么看？还记得看字符串长度的$len$函数吗？我们就是通过$len$来查看list的长度1print(len(a)) $output:$4 同时我们还可以通过像C语言一样的手法访问下标来查看元素，同样不能越上界123print(a[0])print(a[3])print(a[-1]) $output$sss应该发现了，可以有负数，-1的意思就是倒数第一个咯。但是也不能超过$list$的长度 $list$包含的数据类型$list$里面包含的数据类型可以混合加入例如我们可以在一个list里面放入数字、字符串甚至是一个$list$也行！ $list$的操作删除123a.pop(0)print(a)print(a[0]) $output:$$[‘a’, ‘r’, ‘s’]$$a$ 我们可以看到，要删除第i个数字就是直接$pop(i)$，同时会把后面的往前面移动 插入123a.insert(0,a)print(a)print(a[0]) $output:$$[‘s’, ‘a’, ‘r’, ‘s’]$$s$每一次插入，我们都是把第$i$个元素之后往后移动，然后插入 增加$a.append(strr)$默认从尾部增加元素 $tuple$$tuple$也是一种有序列表，它的特点是一旦初始化成功后就不得修改 定义12a = (&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;);print(a) $output$(‘s’, ‘a’, ‘r’, ‘s’) 大家可能发现了，$list$的定义时中括号$[]$而$tuple$是$()$注意我们定义空$tuple$时我们是$a=()$,但是如果定义一个元素时例如$a=(1,)$时，我们注意要打逗号，不然会被误解为$a=1$为$int$型变量 意义$tuple$因其不可修改的性质所以从安全角度上来说比$list$更加安全，我们一般能用$tuple$绝不用$list$ 一个“可变的”$tuple$首先注意引号，他还是不可变的，可为什么又可以变呢？我们尝试如下定义 $a=(‘a’,’b’,[‘a’,’b’])$ 可以发现这一个$tuple$所指向的内容含有字符和一个$list$$tuple$里面的内容的确不可以变，但$list$改变了之后list的地址还是不变的，所以就改了撒，看不懂可评论。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python字符串和数组元组","slug":"python字符串","date":"2020-02-02T12:21:42.000Z","updated":"2020-02-04T03:26:12.993Z","comments":true,"path":"2020/02/02/python字符串/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记","text":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记 字符串对于$python3$的编码格式是一个$Unicode$编码 $unicode$编码粗略解释一下，详情请访问廖雪峰的笔记： $Unicode$解决了各国语言的编码冲突，利用两个字节。$UTF-8$编码是因为$Unicode$对于空间来说浪费高，所以折中出现了utf-8编码 应用场景在计算机内存中，统一使用$Unicode$编码，当需要保存到硬盘或者需要传输的时候，就转换为$UTF-8$编码。 用记事本编辑的时候，从文件读取的$UTF-8$字符被转换为$Unicode$字符到内存里，编辑完成后，保存的时候再把$Unicode$转换为$UTF-8$保存到文件。 浏览网页的时候，服务器会把动态生成的$Unicode$内容转换为$UTF-8$再传输到浏览器：正文$python3$的字符串是$Unicode$编码，也就是适合各种语言啦 对于单个字符来说，我们支持$ord()$获得字符整数表示，$chr()$把编码转为 12print(chr(20320))print(ord(&apos;你&apos;)) 输出你20320 $len$计算字符串的字符数$len(str)$返回一个整数，表示$str$所含有的字符数12strr=&quot;我爱你&quot;print(len(strr)) $output:$3 格式化输出$python$的格式化和C语言的大致相同|占位符|替换内容||:-:|:-:||%s|字符串||%d|整数||%f|浮点数||%x|16进制整数|不过有个区别我表示的重点提醒：print(“%s” % strr),不像C语言中间用逗号分隔顺带一个妙招，当你忘了要用什么的时候可以使用%s哦，他会自动转字符串，hhh1print(&quot;%s %s&quot; % (520,False)) 注意事项 对于$python$里的字符中不能直接相加，需要先把它用$ord$转成数字然后再用$chr$转回来！ 对于字符串里面字符修改必须使用$repalce(old,new,count)$进行生成新的字符串对象！ 12345678def index(head): head=str(head) if head[0]&gt;=&apos;a&apos;and head[0]&lt;=&apos;z&apos;: return head.replace(head[0],chr(ord(head[0])-32),1)#返回一个新的字符串对象 return headL1 = [&apos;adam&apos;, &apos;LISA&apos;, &apos;barT&apos;]L2 = map(index,L1)print(list(L2))","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"python启动","slug":"python启动","date":"2020-02-02T08:27:48.000Z","updated":"2020-02-02T12:38:36.259Z","comments":true,"path":"2020/02/02/python启动/","link":"","permalink":"https://www.dream-ak.top/2020/02/02/python%E5%90%AF%E5%8A%A8/","excerpt":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭","text":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭 python基础python编码格式python的编码格式是按照缩进方式，代码就像下面这个一样：12345a = 100if a &gt;= 0: print(a)else: print(-a)和C语言的差别是c语言用大括号等价于这里的缩进 python的注释 python的注释是通过#,以#开头全部注释掉每遇到一个’$:$’号都会进行自动缩进，视为一个代码块python大小写敏感。 数据类型int范围和C语言的$longlong$一致，应用方式和C语言用法一致 string字符串，他的用法和C语言的字符串用法类似，但是增加了$a[-x]$表示从后开始第x个字符，一般是由’或者”组成。 转换在一个字符串(仅包含数字)前加上int则会自动转换为int型数据类型,如下代码检测1234a = &apos;123456&apos;print(type(a))a=int(a)print(type(a)) 输入python的输入使input();在输入的时候加上提示的话就是在input(“hello world”);12a = input(&quot;please input a math:&quot;)print(a)注意input输入的东西为字符串,以下验证12a=input()print(type(a));对于这种情况我们一般直接在input前面加上一个int就好了12a=int(input())print(type(a)) 换行与C语言相似的是我们一样可以采用”\\n”换行，但增加了一个…换行的方式1print(&quot;hhh...hhh...hhh&quot;)今日份复习到此结束，hhh，晚上在介绍一下其他的基础。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://www.dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.dream-ak.top/tags/python/"}]},{"title":"迪杰斯特拉堆优化","slug":"迪杰斯特拉堆优化","date":"2020-02-01T06:53:49.000Z","updated":"2020-02-02T08:29:07.601Z","comments":true,"path":"2020/02/01/迪杰斯特拉堆优化/","link":"","permalink":"https://www.dream-ak.top/2020/02/01/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%A0%86%E4%BC%98%E5%8C%96/","excerpt":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃","text":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃 原理来说原理的话我建议可以讲一下迪杰斯特拉的算法思想，利用贪心，每一次走距离当前点$u$最近的点$v$，那么我们由原点到$v$一定会是最近的，因为$u$一开始就是最近的，那么dis[u]+min(u\\rightarrow v)\\leq dis[u]+!min(u\\rightarrow v)根据这个我们可以知道我们只需 维护一个最小堆来得到当前最小的$dis[u]$得到$u$的位置，然后找到$u$能到的点$v$的最短路径，得到$dis[v]$然后加入堆 循环1操作直到堆为空就好了。代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=0,dis[N],vis[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij_heap(int x)&#123; int i; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(i=head[u];i;i=ed[i].pre)&#123; if(dis[u]+ed[i].w&lt;=dis[ed[i].id])&#123; dis[ed[i].id]=dis[u]+w; q.push(-dis[ed[i].id],ed[i].id);//这里用负数使最大堆变最小堆 &#125; &#125; &#125;&#125;int main()&#123; dij_heap(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分约束","slug":"差分约束","date":"2020-01-30T13:33:49.000Z","updated":"2020-02-29T08:45:34.596Z","comments":true,"path":"2020/01/30/差分约束/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh","text":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh 一般形式差分约束题一般是给出大量的一些不等式 a_i-b_i\\leq x \\rightarrow a_i\\leq x + b_i由上面这个不等式我们应该可以联想到最短路的不等式 dis[u]\\leq dis[v] + x(u \\rightarrow v)因此，我们可以将差分约束化成一个最短路来求，我们的$dis[u]$保存由远点到$u$的可以选择的最大范围!==为什么是最大范围？==我们每一次选择的是$min(u \\rightarrow v)$，那么一开始我们就会选择一个从原点$s$最小的范围，且没有其他路径会是她变得更小(三角形)，那么这个由原点出发的范围将会是$s \\rightarrow u$的范围，选择最大的话，就是这个范围啦。 求最长路当求最大的范围时是最短路，已经说过了，但是如果求最小范围呢？看一下基本形式 a_i-b_i\\geq x \\rightarrow a_i \\geq x + b_i这个又是什么意思呢？试着把$a_i，b_i$也当作两个点，那么这就是 dis[a_i]\\geq dis[b_i] + x也就是最长路的样子啦 最长路实现最长路的办法，我们试着用最短路的办法去试 floyd $O(n^3)$很明显暴力枚举下面肯定是可以的，但是复杂度实在太高，放弃 dijstra基于贪心的算法，我们最长路的贪心是做不到的，从三角形来看是很明显的，遂继续放弃 bellman_ford差不多就是暴力对所有的边进行n-1次遍历了==一条最长路最多经过$n-1$次松弛==，在这里最长路也是这样啊，时间复杂度的话，我们可以考虑已经死了的 spfa呀，死了不要紧我们可以优化spfa玄学优化 双端队列优化，一个非常常见的优化，当边权小于队首时从队首加入，否则队尾！ 双端慢了？没事我们可以数组模拟，强行加速！ 啊，还是tle？淡定加容错优化，我们首先把所有边权加起来开个根号后加上一个容错值$x$然后当当前边权小于队首边权加上容错时从队首加入，否则队尾，继续强行加速！ 听说还是tle？emmm，等死吧","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"vscode背景配置","slug":"vscode背景配置","date":"2020-01-30T13:00:23.000Z","updated":"2020-02-03T08:01:28.667Z","comments":true,"path":"2020/01/30/vscode背景配置/","link":"","permalink":"https://www.dream-ak.top/2020/01/30/vscode%E8%83%8C%E6%99%AF%E9%85%8D%E7%BD%AE/","excerpt":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！","text":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！ 安装background扩展商店安装就好了这里会弹出code损坏，莫急，往下看 下载 Fix vscode checksum扩展商店下载好以后按下ctrl+shift+p输入 Fix checksum 选择apply就行了 配置插件管理员运行vscode，打开以后按如下图操作打开setting.json 编辑setting.json1234567891011121314151617181920&#123; &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;file:///E:background/vscode.png&quot;//你的图片的绝对路径 ], &quot;background.style&quot;: &#123; &quot;content&quot;: &quot;&apos;&apos;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;background-position&quot;: &quot;50% 50%&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 &#125;, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;&#125; 接下来可能会要求你重启就完成了","categories":[{"name":"vscode","slug":"vscode","permalink":"https://www.dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://www.dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"vscode配置c","slug":"vscode配置c","date":"2020-01-28T16:45:47.000Z","updated":"2020-02-21T13:01:22.668Z","comments":true,"path":"2020/01/29/vscode配置c/","link":"","permalink":"https://www.dream-ak.top/2020/01/29/vscode%E9%85%8D%E7%BD%AEc/","excerpt":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。","text":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。 1.下载DEV也许有人会问不是vscode嘛？为啥下载这个，因为vscode是编辑器我们需要下载一个编译器，我们就把DEV里面的mingw单独拿出来添加环境变量，提供编译环境。下载网址：1https://dl.pconline.com.cn/download/908942-1.html进入后点击普通下载，安装好。 2.配置环境变量1.右击电脑属性后2.进入高级设置点击环境变量3.在系统变量Path里面增加mingw64/bin的路径声明一下mingw64/bin就在之前下的DEV文件里面，桌面右击快捷方式打开文件所在地址就可以找到该文件了从左至右逐一执行后点击确定。打开cmd输入gcc如果返回的是gcc: fatal error: no input filescompilation terminated.那么环境就配好了，否则重启一下电脑再试一下，再不行的话就是环境配置失败，再来吧 3.下载vscode下载地址1https://code.visualstudio.com/Download下载过程中一路确定就好了。声明：安装路径不得含有中文！不然之后的操作会有玄学错误，gdb退出代码为-3 汉化chinese 汉化工具打开vscode工具，使用快捷键组合【command+Shift+p】，在搜索框中输入“configure display language”，点击确定后；修改locale.json文件下的属性“locale”为“zh-CN”; 重启vscode工具 安装插件c/c++ c配置必须的vscode-icons美化图标工具chinese 汉化工具Bracket Pair Colorizer 一起安装算了beautify 美化工具 4.文件配置1.我们首先写一个test.cpp文件代码里面必须含有一个输入getchar或者scanf都行,不然后面看不到输出效果，直接说返回值为1 launch文件2.从左到右操作，创建launch.json文件3.使用gdb创建之后点击gcc.exe生成一个文件，在该文件里面添加下面这段代码1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;g++.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gdb.exe&quot;,//gdb.exe的文件地址 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;g++.exe build active file&quot;//与task.json一致 &#125; ]&#125;两个要注意的地方1.miDebuggerPath这是你的gdb.exe文件地址，注意要修改正确！（好像还有一个gdb32.exe你看那一个成功用那个吧）2.externalConsole这里是true！ tasks.json文件这个文件我们手动添加，在.vscode文件里面创建tasks.json注意别打错了添加如下代码12345678910111213141516171819&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;g++.exe build active file&quot;, &quot;command&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe&quot;,//g++.exe的位置 &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot;//bin文件夹位置 &#125; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;上面代码两个地方需要修改，请仔细看！ “command”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\g++.exe”,//g++.exe的位置 “cwd”: “D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin”//bin文件夹位置此时再回到test.cpp里面按F5运行一下，应该能输出了。到此环境安装结束！撒花","categories":[{"name":"vscode","slug":"vscode","permalink":"https://www.dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://www.dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2020-01-28T03:19:55.000Z","updated":"2020-02-07T13:28:07.421Z","comments":true,"path":"2020/01/28/欧拉函数/","link":"","permalink":"https://www.dream-ak.top/2020/01/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数","text":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数 欧拉函数的性质 公式 解释 $φ(x y) = φ(x) φ(y)$ 当且(x,y)==1 $φ(x) = x - 1$ 当且仅当x为质数时 $φ(n) = (p-1) * p^{k-1}$ $φ(n)=n∗∏(1−1/p_i)$ pi是n的质因子 $a^{φ(m)}==1%m$ 当且仅当(a,m)==1 $s = n * (φ(n)/2)$ s：小于n且与n互质的数之和 $φ(n p)=φ(n) p$ 当p为质数且n%p==0 $φ(n p)=φ(n) (p-1)$ 当p为质数且n%p!=0 计算欧拉值的打表代码,时间复杂度O(n)123456789101112phi[1]=1; for(int i=2;i&lt;n;i++)&#123; if(vis[i]==0) pri[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;1ll*i*pri[j]&lt;n;j++)&#123; vis[i*pri[j]]=1;//标记此点经过非质数 if(i%pri[j]==0) &#123; phi[i*pri[j]]=phi[i]*pri[j];//性质7 break; &#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1);//性质8 &#125; &#125; 用性质4计算单个欧拉值1234567891011121314int ph(int n)&#123; int res=n,i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; res=res-res/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) res=res-res/n; return res;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[]},{"title":"割点与割边","slug":"割点","date":"2020-01-20T14:21:29.000Z","updated":"2020-02-28T15:37:11.655Z","comments":true,"path":"2020/01/20/割点/","link":"","permalink":"https://www.dream-ak.top/2020/01/20/%E5%89%B2%E7%82%B9/","excerpt":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。","text":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。易得割点是2号点。 具体操作：121.用dfs给每一个点打上一个时间戳，把每一个点的时间戳保存至num【】里面；2.通过dfs来统计每一个点能到达的最小的时间戳。&lt;br&gt; 割点的判定方式： 如果存在一个点他的子节点能到达的最小时间戳大于等于父节点的时间戳那么这个点是一个割点。(也就是不能回到祖先，那么当前点就是割点咯) 假设一个点存在两个子节点，那么该点就是割点。我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。更新 low 的伪代码如下：1234如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);否则low[u] = min(low[u], num[v]);//这里是num[v]而不是low[v]的原因是如下图//按照节点编号从小到大遍历，4节点先到1，如果是low[v]的话，节点6的low值等于1，很明显是不可以的，所以是num 例题板子题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;const int N=2e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=1,cnt=0;int vis[N],num[N],low[N],inde,res,flag[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void tarjan(int u,int fa)&#123; vis[u]=1; low[u]=num[u]=++inde; int ch=0,i; for(i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(!vis[v])&#123; ch++; tarjan(v,u); low[u]=min(low[u],low[v]); if(fa!=u&amp;&amp;low[v]&gt;=num[u]&amp;&amp;!flag[u]) flag[u]=1,res++; &#125; else if(v!=fa)&#123; low[u]=min(low[u],num[v]);//这里非常关键，如果写成low[u]=min(low[u],low[v])在题目里面会wa &#125; &#125; if(ch&gt;= 2&amp;&amp;fa==u&amp;&amp;!flag[u])&#123; flag[u]=1; res++; &#125;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) head[i]=0,vis[i]=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; for(i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; inde=0; tarjan(i,i); &#125; &#125; printf(&quot;%d\\n&quot;,res); for(i=1;i&lt;=n;i++)&#123; if(flag[i]) printf(&quot;%d &quot;,i); &#125; return 0;&#125; 割边对于割边其实与割点差不多只有判断条件变了一丢丢，也就是$low[v]&gt;dfn[u]$时边$$一定是割边。","categories":[{"name":"图论","slug":"图论","permalink":"https://www.dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2020-01-14T11:59:52.000Z","updated":"2020-02-15T04:09:06.300Z","comments":true,"path":"2020/01/14/扩展欧几里得/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"扩展欧几里得应用：计算逆元，解方程","text":"扩展欧几里得应用：计算逆元，解方程 证明方式：首先贝祖原理我大概就不解释了，直接照搬结论： $ax+by=(a,b)$;贝祖原理 $ax+by=(b,a \\% b) $;辗转相除法 假设解为$x1$,$y1$则有$a * x1+b * y1=(b,a\\%b)$ 由3式从右往左代替可得$b * x1+(a\\%b) * y1=(b,a\\%b)$;$b * x1 + (a-(a/b) * b) * y1 = (b,a\\%b)$;$a * y1 +b * (x1 - (a/b) * y1) = a * x + b * y$由上可知$x = y1,y = x1 - (a/b) * y1$。 对于上式，我们可以比较一下欧几里得求最大公约数的算法： $(a,b)=(b,a\\%b)$，一直到b等于0时结束递归，而当b等于0时的x=1,y=0; 然后又可以通过上面代数式4回退时计算出x与y的值！ 代码123456789101112ll x,y;ll ex_gcd(ll a,ll b)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll ans=ex_gcd(b,a%b); ll t=x; x=y; y=t-a/b * y; return ans;&#125; 应用逆元当求一个数字x对于p的逆元时，我们将其写成代数式将是如下形式： a * x=1%p; 对其进行化简可得a * x+y * p=1，已知x,p求a就好了化简成这样以后再看，简直就是扩展欧几里得板子！","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-02-07T13:16:21.688Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"https://www.dream-ak.top/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"欧拉筛欧拉函数打表简单版！","text":"欧拉筛欧拉函数打表简单版！ 欧拉筛证明：首先介绍一下算术基本原理：$x=p_1^{e1} p_2^{e_2} p_3^{e_3}$…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道任意一个合数都是由一个质数乘以一个其他数字组成！所以我们可以通过枚举一个质数和一个其他非$1$的正整数来判断来其他合数。但是为了提高其运算速率，我们想要对于任意一个合数仅判断一次时我们可以考虑，采用其最小的质数就行了，因为最小的质数只有一个且另一个非$1$正整数数仅用一次，那么任意一个合数只会判断一次咯 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;枚举非1正整数 if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123;//枚举素数 vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;//原因在下注明 &#125; &#125;&#125; break的原因是如果该循环继续下去的话(i*pri[j]的最小素数其实不是pri[j]，而是之前能被整除的那个素数，不break的话，一个合数的判断次数就会增加)","categories":[{"name":"数论","slug":"数论","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2020-02-03T06:52:06.528Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://www.dream-ak.top/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://www.dream-ak.top/tags/ACM/"}]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.983Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"https://www.dream-ak.top/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；","text":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://www.dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}