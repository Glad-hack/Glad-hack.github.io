{"meta":{"title":"Hexo","subtitle":"","description":"飞蛾扑火也许仅仅是因为那一丝的温暖吧","author":"无向秃","url":"https://dream-ak.top","root":"/"},"pages":[{"title":"折腾&自闭","date":"2019-11-26T10:37:58.000Z","updated":"2020-02-02T12:35:36.651Z","comments":true,"path":"categories/index.html","permalink":"https://dream-ak.top/categories/index.html","excerpt":"","text":""},{"title":"折腾&自闭","date":"2019-11-26T11:57:02.000Z","updated":"2020-02-02T12:29:03.898Z","comments":true,"path":"tags/index.html","permalink":"https://dream-ak.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"dict和set","slug":"dict和set","date":"2020-02-03T07:01:13.000Z","updated":"2020-02-03T08:58:19.114Z","comments":true,"path":"2020/02/03/dict和set/","link":"","permalink":"https://dream-ak.top/2020/02/03/dict%E5%92%8Cset/","excerpt":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧","text":"$dict$我发现与$c++$的$map$十分相似,而$set$好像名字都没变，由于$c++$只学皮毛，就不瞎说了，慢慢学吧 $dict$$dict$的结构这里按照廖雪峰的介绍给出两种方式 按照字典树的方式建立一棵字典树，优点不会出现冲突，可直接使用，缺点相较于哈希来说，查找较慢 直接建立一个哈希表，每一次按照$key$直接哈希地址然后得到答案，优点，查找方便。缺点：容易出现哈希冲突。 $dict$是第二种建立方式，因此$key$的值是唯一的，不可重复，如果重复了那么就会将前面得到的数据丢失冲掉。 $dict$的建立首先来看一段代码 1234a=&#123;&#125;a[&apos;peng&apos;] = 4a[&apos;我&apos;] = 5print(a[&apos;我&apos;]) $output$5 可以看到我们是通过大括号{}来定义一个空$dict$然后添加直接赋值就好了。调用直接访问$key$就行了，但是一定要保证这个$key$存在。判断$key$存在性的办法： $print(‘我’ in a)$ $print(a.get(‘我’,x))$ 解释一下$x$的作用，当不存在$key$的时候返回$x$ 对于第一种，如果存在，返回$true$。不存在返回false。 $dict$的删除这个的删除我们前提是$key$存在,如果存在，我们就可以像$list$一样删除它。 12a.pop(&apos;peng&apos;)print(a.get(&apos;peng&apos;,777)) $output$777 注意$dict$可以用在需要高速查找的很多地方，在$Python$代码中几乎无处不在，正确使用$dict$非常重要，需要牢记的第一条就是$dict$的key必须是不可变对象。 这是因为$dict$根据$key$来计算$value$的存储位置，如果每次计算相同的$key$得出的结果不同，那$dict$内部就完全混乱了。这个通过$key$计算位置的算法称为哈希算法$（Hash）$。 要保证$hash$的正确性，作为$key$的对象就不能变。在$Python$中，字符串、整数等都是不可变的，因此，可以放心地作为$key$。而$list$是可变的，就不能作为$key$ $set$$set$一般用于去重和集合操作，它可以对集合进行”与”、”或”操作. 创建创建一个$set$我们一般是要一个$list$做输入集合看一段代码123l = [1,1,5,9,3,8,9]a = set(l)print(a) $output${1, 3, 5, 8, 9} 很明显它自己去重了，同时不要被表面所迷惑$set$是无序的 $set$怎么添加元素？答案下行揭晓$a.add(x)$参数$x$是你要添加的$key$12a.add(2)print(a) $output${1, 2, 3, 5, 8, 9} 删除元素我们一般通过$a.remove(x)$删除,$x$是你要删除的$key$12a.remove(2)print(a) $output${1, 3, 5, 8, 9} 集合操作直接&amp;或者|就好了123b=set([1,2])print(a&amp;b)print(a|b) $output${1}{1, 2, 3, 5, 8, 9} 不可变变量字符串属于不可变变量，同时$list$是一个可变变量。123a = &quot;abc&quot;print(a.replace(&apos;a&apos;,&apos;A&apos;))print(a)","categories":[{"name":"python基础","slug":"python基础","permalink":"https://dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dream-ak.top/tags/python/"}]},{"title":"条件与循环","slug":"条件与循环","date":"2020-02-03T06:31:15.000Z","updated":"2020-02-03T06:59:02.630Z","comments":true,"path":"2020/02/03/条件与循环/","link":"","permalink":"https://dream-ak.top/2020/02/03/%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/","excerpt":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进","text":"$hhh$还记得我之前说的$python$是如何将区分作用域划分代码块吗？没错就是$’:’$这个，他会自动缩进 $if$判断首先我们来看一段代码12345socre=int(input())if score&gt;=60: print(&quot;pass\\n&quot;)else : print(&quot;No pass\\n&quot;)这个就可以把你的分数转化成过和没过了，挂科了没，一目了然！对于这段代码的解释我就对他与C语言的比较了。没有C语言的小括号，$if$后面全是判断一直到$’:’$对于else 我们也需要$’:’$如果进行多次判断由C语言的$else if$ $\\rightarrow$ $elif 判断:$ 循环$for$ … $in$循环这种循环我们一般是用一个变量每一次迭代$in$里面的内容(可以是$list,tuple$等数据结构)，比如1234567891011121314151617x=(5,2,0)for i in x: print(i)``` &gt; $output$520## $for$ ... $in$ $range(x,y,z)$循环我们看这个循环 其中省略号代表变量，我们假设为$i$现在来解释一下参数1. $x$代表$i$的初始值2. $y$代表$i$的上界或下界,**不得小于等于$y$**3. $z$代表$i$的步进大小每一次加上多少来看一段代码for i in range(3,1,-1): print(i)``` $output$32","categories":[{"name":"python基础","slug":"python基础","permalink":"https://dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dream-ak.top/tags/python/"}]},{"title":"list和tuple","slug":"list和tuple","date":"2020-02-02T13:34:09.000Z","updated":"2020-02-03T06:52:06.529Z","comments":true,"path":"2020/02/02/list和tuple/","link":"","permalink":"https://dream-ak.top/2020/02/02/list%E5%92%8Ctuple/","excerpt":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。","text":"对于这个list的了解我一直感觉就和C语言数组一样，但是仔细看了一下，到底不同，就让本蒟蒻带您去看看那些地方不同吧。 $list$这种数据类型使列表 $list$是一种有序的集合，可以随时添加和删除其中的元素。对于这个我们可以看下面这个例子12a=[&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;]print(a) $ output$:$[‘s’, ‘a’, ‘r’, ‘s’]$ 而一个$list$的长度怎么看？还记得看字符串长度的$len$函数吗？我们就是通过$len$来查看list的长度1print(len(a)) $output:$4 同时我们还可以通过像C语言一样的手法访问下标来查看元素，同样不能越上界123print(a[0])print(a[3])print(a[-1]) $output$sss应该发现了，可以有负数，-1的意思就是倒数第一个咯。但是也不能超过$list$的长度 $list$包含的数据类型$list$里面包含的数据类型可以混合加入例如我们可以在一个list里面放入数字、字符串甚至是一个$list$也行！ $list$的操作删除123a.pop(0)print(a)print(a[0]) $output:$$[‘a’, ‘r’, ‘s’]$$a$ 我们可以看到，要删除第i个数字就是直接$pop(i)$，同时会把后面的往前面移动 插入123a.insert(0,a)print(a)print(a[0]) $output:$$[‘s’, ‘a’, ‘r’, ‘s’]$$s$每一次插入，我们都是把第$i$个元素之后往后移动，然后插入 增加$a.append(strr)$默认从尾部增加元素 $tuple$$tuple$也是一种有序列表，它的特点是一旦初始化成功后就不得修改 定义12a = (&apos;s&apos;,&apos;a&apos;,&apos;r&apos;,&apos;s&apos;);print(a) $output$(‘s’, ‘a’, ‘r’, ‘s’) 大家可能发现了，$list$的定义时中括号$[]$而$tuple$是$()$注意我们定义空$tuple$时我们是$a=()$,但是如果定义一个元素时例如$a=(1,)$时，我们注意要打逗号，不然会被误解为$a=1$为$int$型变量 意义$tuple$因其不可修改的性质所以从安全角度上来说比$list$更加安全，我们一般能用$tuple$绝不用$list$ 一个“可变的”$tuple$首先注意引号，他还是不可变的，可为什么又可以变呢？我们尝试如下定义 $a=(‘a’,’b’,[‘a’,’b’])$ 可以发现这一个$tuple$所指向的内容含有字符和一个$list$$tuple$里面的内容的确不可以变，但$list$改变了之后list的地址还是不变的，所以就改了撒，看不懂可评论。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dream-ak.top/tags/python/"}]},{"title":"python字符串和数组元组","slug":"python字符串","date":"2020-02-02T12:21:42.000Z","updated":"2020-02-03T06:52:06.529Z","comments":true,"path":"2020/02/02/python字符串/","link":"","permalink":"https://dream-ak.top/2020/02/02/python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记","text":"首先我得说一句，这里得字符串编码有点玄学，如果讲开了有点可怕，所以我就在最开始得地方放一个大佬的链接算了，方便以后查阅廖雪峰的笔记 字符串对于$python3$的编码格式是一个$Unicode$编码 unicode编码粗略解释一下，详情请访问廖雪峰的笔记： $Unicode$解决了各国语言的编码冲突，利用两个字节。$UTF-8$编码是因为$Unicode$对于空间来说浪费高，所以折中出现了utf-8编码 应用场景在计算机内存中，统一使用$Unicode$编码，当需要保存到硬盘或者需要传输的时候，就转换为$UTF-8$编码。 用记事本编辑的时候，从文件读取的$UTF-8$字符被转换为$Unicode$字符到内存里，编辑完成后，保存的时候再把$Unicode$转换为$UTF-8$保存到文件。 浏览网页的时候，服务器会把动态生成的$Unicode$内容转换为$UTF-8$再传输到浏览器：正文$python3$的字符串是$Unicode$编码，也就是适合各种语言啦 对于单个字符来说，我们支持$ord()$获得字符整数表示，$chr()$把编码转为 12print(chr(20320))print(ord(&apos;你&apos;)) 输出你20320 $len$计算字符串的字符数$len(str)$返回一个整数，表示$str$所含有的字符数12strr=&quot;我爱你&quot;print(len(strr)) $output:$3 格式化输出$python$的格式化和C语言的大致相同|占位符|替换内容||:-:|:-:||%s|字符串||%d|整数||%f|浮点数||%x|16进制整数|不过有个区别我表示的重点提醒：print(“%s” % strr),不像C语言中间用逗号分隔顺带一个妙招，当你忘了要用什么的时候可以使用%s哦，他会自动转字符串，hhh1print(&quot;%s %s&quot; % (520,False))","categories":[{"name":"python基础","slug":"python基础","permalink":"https://dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dream-ak.top/tags/python/"}]},{"title":"python启动","slug":"python启动","date":"2020-02-02T08:27:48.000Z","updated":"2020-02-02T12:38:36.259Z","comments":true,"path":"2020/02/02/python启动/","link":"","permalink":"https://dream-ak.top/2020/02/02/python%E5%90%AF%E5%8A%A8/","excerpt":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭","text":"在家无聊，想到python貌似挺好玩的，我就来试试，hhh，祝病毒早日被消灭 python基础python编码格式python的编码格式是按照缩进方式，代码就像下面这个一样：12345a = 100if a &gt;= 0: print(a)else: print(-a)和C语言的差别是c语言用大括号等价于这里的缩进 python的注释 python的注释是通过#,以#开头全部注释掉每遇到一个’$:$’号都会进行自动缩进，视为一个代码块python大小写敏感。 数据类型int范围和C语言的$longlong$一致，应用方式和C语言用法一致 string字符串，他的用法和C语言的字符串用法类似，但是增加了$a[-x]$表示从后开始第x个字符，一般是由’或者”组成。 转换在一个字符串(仅包含数字)前加上int则会自动转换为int型数据类型,如下代码检测1234a = &apos;123456&apos;print(type(a))a=int(a)print(type(a)) 输入python的输入使input();在输入的时候加上提示的话就是在input(“hello world”);12a = input(&quot;please input a math:&quot;)print(a)注意input输入的东西为字符串,以下验证12a=input()print(type(a));对于这种情况我们一般直接在input前面加上一个int就好了12a=int(input())print(type(a)) 换行与C语言相似的是我们一样可以采用”\\n”换行，但增加了一个…换行的方式1print(&quot;hhh...hhh...hhh&quot;)今日份复习到此结束，hhh，晚上在介绍一下其他的基础。","categories":[{"name":"python基础","slug":"python基础","permalink":"https://dream-ak.top/categories/python%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"python","slug":"python","permalink":"https://dream-ak.top/tags/python/"}]},{"title":"迪杰斯特拉堆优化","slug":"迪杰斯特拉堆优化","date":"2020-02-01T06:53:49.000Z","updated":"2020-02-02T08:29:07.601Z","comments":true,"path":"2020/02/01/迪杰斯特拉堆优化/","link":"","permalink":"https://dream-ak.top/2020/02/01/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E5%A0%86%E4%BC%98%E5%8C%96/","excerpt":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃","text":"迪杰斯特拉算法的堆优化性能使得最短路算法时间复杂度再次加快了一个档次变成了$n*\\log_2 n$，让人更加头秃 原理来说原理的话我建议可以讲一下迪杰斯特拉的算法思想，利用贪心，每一次走距离当前点$u$最近的点$v$，那么我们由原点到$v$一定会是最近的，因为$u$一开始就是最近的，那么dis[u]+min(u\\rightarrow v)\\leq dis[u]+!min(u\\rightarrow v)根据这个我们可以知道我们只需 维护一个最小堆来得到当前最小的$dis[u]$得到$u$的位置，然后找到$u$能到的点$v$的最短路径，得到$dis[v]$然后加入堆 循环1操作直到堆为空就好了。代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;stdio.h&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int N = 2e+5;struct ED&#123; int pre,id,w;&#125;ed[N];int head[N],tot=0,dis[N],vis[N];void add(int u,int v,int w)&#123; ed[++tot].pre=head[u]; ed[tot].id=v; ed[tot].w=w; head[u]=tot;&#125;priority_queue&lt;pair&lt;int,int&gt; &gt;q;void dij_heap(int x)&#123; int i; memset(dis,0x3f,sizeof dis); memset(vis,0,sizeof vis); dis[x]=0; q.push(make_pair(0,x)); while(!q.empty())&#123; int u=q.top().second; q.pop(); if(vis[u]) continue; vis[u]=1; for(i=head[u];i;i=ed[i].pre)&#123; if(dis[u]+ed[i].w&lt;=dis[ed[i].id])&#123; dis[ed[i].id]=dis[u]+w; q.push(-dis[ed[i].id],ed[i].id);//这里用负数使最大堆变最小堆 &#125; &#125; &#125;&#125;int main()&#123; dij_heap(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"差分约束","slug":"差分约束","date":"2020-01-30T13:33:49.000Z","updated":"2020-02-02T10:33:15.688Z","comments":true,"path":"2020/01/30/差分约束/","link":"","permalink":"https://dream-ak.top/2020/01/30/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/","excerpt":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh","text":"差分约束hhh，这几天病毒感染，真的不敢乱溜达，干脆狂写blog算了，hhh 一般形式差分约束题一般是给出大量的一些不 等式 a_i-b_i\\leq x \\rightarrow a_i\\leq x + b_i由上面这个不等式我们应该可以联想到最短路的不等式 dis[u]\\leq dis[v] + x(u \\rightarrow v)因此，我们可以将差分约束化成一个最短路来求，我们的$dis[u]$保存由远点到$u$的可以选择的最大范围!==为什么是最大范围？==我们每一次选择的是$min(u \\rightarrow v)$，那么一开始我们就会选择一个从原点$s$最小的范围，且没有其他路径会是她变得更小(三角形)，那么这个由原点出发的范围将会是$s \\rightarrow u$的范围，选择最大的话，就是这个范围啦。 求最长路当求最大的范围时是最短路，已经说过了，但是如果求最小范围呢？看一下基本形式 a_i-b_i\\geq x \\rightarrow a_i \\geq x + b_i这个又是什么意思呢？试着把$a_i，b_i$也当作两个点，那么这就是 dis[a_i]\\geq dis[b_i] + x也就是最长路的样子啦 最长路实现最长路的办法，我们试着用最短路的办法去试 floyd $O(n^3)$很明显暴力枚举下面肯定是可以的，但是复杂度实在太高，放弃 dijstra基于贪心的算法，我们最长路的贪心是做不到的，从三角形来看是很明显的，遂继续放弃 bellman_ford差不多就是暴力对所有的边进行n-1次遍历了==一条最长路最多经过$n-1$次松弛==，在这里最长路也是这样啊，时间复杂度的话，我们可以考虑已经死了的 spfa呀，死了不要紧我们可以优化spfa玄学优化 双端队列优化，一个非常常见的优化，当边权小于队首时从队首加入，否则队尾！ 双端慢了？没事我们可以数组模拟，强行加速！ 啊，还是tle？淡定加容错优化，我们首先把所有边权加起来开个根号后加上一个容错值$x$然后当当前边权小于队首边权加上容错时从队首加入，否则队尾，继续强行加速！ 听说还是tle？emmm，等死吧","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"vscode背景配置","slug":"vscode背景配置","date":"2020-01-30T13:00:23.000Z","updated":"2020-02-03T08:01:28.667Z","comments":true,"path":"2020/01/30/vscode背景配置/","link":"","permalink":"https://dream-ak.top/2020/01/30/vscode%E8%83%8C%E6%99%AF%E9%85%8D%E7%BD%AE/","excerpt":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！","text":"vscode背景vscode花里胡哨的背景怎么能却得了？我也来瞎搞俩！ 安装background扩展商店安装就好了这里会弹出code损坏，莫急，往下看 下载 Fix vscode checksum扩展商店下载好以后按下ctrl+shift+p输入 Fix checksum 选择apply就行了 配置插件管理员运行vscode，打开以后按如下图操作打开setting.json 编辑setting.json1234567891011121314151617181920&#123; &quot;background.enabled&quot;: true, &quot;background.useDefault&quot;: false, &quot;background.customImages&quot;: [ &quot;file:///E:background/vscode.png&quot;//你的图片的绝对路径 ], &quot;background.style&quot;: &#123; &quot;content&quot;: &quot;&apos;&apos;&quot;, &quot;pointer-events&quot;: &quot;none&quot;, &quot;position&quot;: &quot;absolute&quot;, &quot;z-index&quot;: &quot;99999&quot;, &quot;width&quot;: &quot;100%&quot;, &quot;height&quot;: &quot;100%&quot;, &quot;background-size&quot;: &quot;cover&quot;, &quot;background-position&quot;: &quot;50% 50%&quot;, &quot;background-repeat&quot;: &quot;no-repeat&quot;, &quot;opacity&quot;: 0.1 &#125;, &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;&#125; 接下来可能会要求你重启就完成了","categories":[{"name":"vscode","slug":"vscode","permalink":"https://dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"vscode配置c","slug":"vscode配置c","date":"2020-01-28T16:45:47.000Z","updated":"2020-01-30T13:31:33.843Z","comments":true,"path":"2020/01/29/vscode配置c/","link":"","permalink":"https://dream-ak.top/2020/01/29/vscode%E9%85%8D%E7%BD%AEc/","excerpt":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。","text":"vscodec/c++环境配置前言vscode编辑器比较强大，被朋友介绍以后感觉不错，至少不用一个语言就开一个编辑器了，省心，目录也看着挺方便的，我就捣鼓一会也弄了一个。 1.下载DEV也许有人会问不是vscode嘛？为啥下载这个，因为vscode是编辑器我们需要下载一个编译器，我们就把DEV里面的mingw单独拿出来添加环境变量，提供编译环境。下载网址：1https://dl.pconline.com.cn/download/908942-1.html进入后点击普通下载，安装好。 2.配置环境变量1.右击电脑属性后2.进入高级设置点击环境变量3.在系统变量Path里面增加mingw64/bin的路径声明一下mingw64/bin就在之前下的DEV文件里面，桌面右击快捷方式打开文件所在地址就可以找到该文件了从左至右逐一执行后点击确定。打开cmd输入gcc如果返回的是gcc: fatal error: no input filescompilation terminated.那么环境就配好了，否则重启一下电脑再试一下，再不行的话就是环境配置失败，再来吧 3.下载vscode下载地址1https://code.visualstudio.com/Download下载过程中一路确定就好了。声明：安装路径不得含有中文！不然之后的操作会有玄学错误，gdb退出代码为-3 汉化chinese 汉化工具打开vscode工具，使用快捷键组合【command+Shift+p】，在搜索框中输入“configure display language”，点击确定后；修改locale.json文件下的属性“locale”为“zh-CN”; 重启vscode工具 安装插件c/c++ c配置必须的vscode-icons美化图标工具chinese 汉化工具Bracket Pair Colorizer 一起安装算了beautify 美化工具 4.文件配置1.我们首先写一个test.cpp文件代码里面必须含有一个输入getchar或者scanf都行,不然后面看不到输出效果，直接说返回值为1 launch文件2.从左到右操作，创建launch.json文件3.使用gdb创建之后点击gcc.exe生成一个文件，在该文件里面添加下面这段代码1234567891011121314151617181920212223242526272829&#123; // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;gcc.exe build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, //这里是控制台时候打开运行一般是true！ &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gdb.exe&quot;, //你的环境gdb.exe文件地址，我这里是在DEV-cpp里面，如果你安装方式和我差不多的话，那你的也在dev里面。 &quot;setupCommands&quot;: [ &#123; &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true &#125; ], &quot;preLaunchTask&quot;: &quot;gcc.exe build active file&quot; &#125; ]&#125;两个要注意的地方1.miDebuggerPath这是你的gdb.exe文件地址，注意要修改正确！（好像还有一个gdb32.exe你看那一个成功用那个吧）2.externalConsole这里是true！ tasks.json文件这个文件我们手动添加，在.vscode文件里面创建tasks.json注意别打错了添加如下代码12345678910111213141516171819&#123; &quot;tasks&quot;: [ &#123; &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc.exe build active file&quot;, &quot;command&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin\\\\gcc.exe&quot;,//你的文件地址 &quot;args&quot;: [ &quot;-g&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;, &quot;$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot; ], &quot;options&quot;: &#123; &quot;cwd&quot;: &quot;D:\\\\progress\\\\Dev-Cpp\\\\MinGW64\\\\bin&quot;//你的文件地址 &#125; &#125; ], &quot;version&quot;: &quot;2.0.0&quot;&#125;上面代码两个地方需要修改，请仔细看！此时再回到test.cpp里面按F5运行一下，应该能输出了。 到此环境安装结束！撒花","categories":[{"name":"vscode","slug":"vscode","permalink":"https://dream-ak.top/categories/vscode/"}],"tags":[{"name":"安装指南","slug":"安装指南","permalink":"https://dream-ak.top/tags/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"}]},{"title":"欧拉函数","slug":"欧拉函数","date":"2020-01-28T03:19:55.000Z","updated":"2020-01-29T13:32:37.117Z","comments":true,"path":"2020/01/28/欧拉函数/","link":"","permalink":"https://dream-ak.top/2020/01/28/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/","excerpt":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数","text":"欧拉函数 欧拉函数是一个用于求1~n里面所有的与n互质数字的个数 欧拉函数的性质 φ(x y) = φ(x) φ(y) 当且(x,y)==1 φ(x) = x - 1 当且仅当x为质数时 φ(n) = (p-1) * p^(k-1) φ(n)=n∗∏(1−1/pi) pi是n的质因子 a^(φ(m))==1%m 当且仅当(a,m)==1 s = n (φ(n)/2) *s为小于n且与n互质的数之和 φ(n p)=φ(n) p 当p为质数且n%p==0 φ(n p)=φ(n) (p-1) 当p为质数且n%p!=0 计算欧拉值的打表代码,时间复杂度O(n)123456789101112phi[1]=1; for(int i=2;i&lt;n;i++)&#123; if(vis[i]==0) pri[++tot]=i,phi[i]=i-1; for(int j=1;j&lt;=tot&amp;&amp;1ll*i*pri[j]&lt;n;j++)&#123; vis[i*pri[j]]=1;//标记此点经过非质数 if(i%pri[j]==0) &#123; phi[i*pri[j]]=phi[i]*pri[j];//性质7 break; &#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1);//性质8 &#125; &#125; 用性质4计算单个欧拉值1234567891011121314int ph(int n)&#123; int res=n,i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) &#123; res=res-res/i; while(n%i==0) n/=i; &#125; &#125; if(n&gt;1) res=res-res/n; return res;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[]},{"title":"割点","slug":"割点","date":"2020-01-20T14:21:29.000Z","updated":"2020-01-29T13:32:39.699Z","comments":true,"path":"2020/01/20/割点/","link":"","permalink":"https://dream-ak.top/2020/01/20/%E5%89%B2%E7%82%B9/","excerpt":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。","text":"割点割点定义：对于一个无向图，如果把一个点删除后这个图的极大连通分量数增加了，那么这个点就是这个图的割点（又称割顶）。易得割点是2号点。 具体操作：121.用dfs给每一个点打上一个时间戳，把每一个点的时间戳保存至num【】里面；2.通过dfs来统计每一个点能到达的最小的时间戳。&lt;br&gt; 割点的判定方式： 如果存在一个点他的子节点能到达的最小时间戳大于等于父节点的时间戳那么这个点是一个割点。(也就是不能回到祖先，那么当前点就是割点咯) 假设一个点存在两个子节点，那么该点就是割点。我们在访问 1 的儿子时候，假设先 DFS 到了 2，然后标记用过，然后递归往下，来到了 4，4 又来到了 3，当递归回溯的时候，会发现 3 已经被访问过了，所以不是割点。更新 low 的伪代码如下：1234如果 v 是 u 的儿子 low[u] = min(low[u], low[v]);否则low[u] = min(low[u], num[v]);//这里是num[v]而不是low[v]的原因是如下图//按照节点编号从小到大遍历，4节点先到1，如果是low[v]的话，节点6的low值等于1，很明显是不可以的，所以是num 例题板子题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;stack&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;string.h&gt;using namespace std;const int N=2e5+5;typedef long long ll;struct ED&#123; int pre,id;&#125;ed[N];int head[N],tot=1,cnt=0;int vis[N],num[N],low[N],inde,res,flag[N];void add(int u,int v)&#123; ed[++tot].id=v; ed[tot].pre=head[u]; head[u]=tot;&#125;void tarjan(int u,int fa)&#123; vis[u]=1; low[u]=num[u]=++inde; int ch=0,i; for(i=head[u];i;i=ed[i].pre)&#123; int v=ed[i].id; if(!vis[v])&#123; ch++; tarjan(v,u); low[u]=min(low[u],low[v]); if(fa!=u&amp;&amp;low[v]&gt;=num[u]&amp;&amp;!flag[u]) flag[u]=1,res++; &#125; else if(v!=fa)&#123; low[u]=min(low[u],num[v]);//这里非常关键，如果写成low[u]=min(low[u],low[v])在题目里面会wa &#125; &#125; if(ch&gt;= 2&amp;&amp;fa==u&amp;&amp;!flag[u])&#123; flag[u]=1; res++; &#125;&#125;int main()&#123; int n,m,i,j,k; scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(i=1;i&lt;=n;i++) head[i]=0,vis[i]=0; int u,v; for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;u,&amp;v); add(u,v); add(v,u); &#125; for(i=1;i&lt;=n;i++)&#123; if(!vis[i])&#123; inde=0; tarjan(i,i); &#125; &#125; printf(&quot;%d\\n&quot;,res); for(i=1;i&lt;=n;i++)&#123; if(flag[i]) printf(&quot;%d &quot;,i); &#125; return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"https://dream-ak.top/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[]},{"title":"扩展欧几里得","slug":"扩展欧几里得","date":"2020-01-14T11:59:52.000Z","updated":"2020-01-29T13:32:38.328Z","comments":true,"path":"2020/01/14/扩展欧几里得/","link":"","permalink":"https://dream-ak.top/2020/01/14/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/","excerpt":"扩展欧几里得应用：计算逆元，解方程","text":"扩展欧几里得应用：计算逆元，解方程 证明方式：首先贝祖原理我大概就不解释了，直接照搬结论： ax+by=(a,b);贝祖原理 有ax+by=(b,a%b); 假设解为x1,y1则有a x1+b y1=(b,a%b) 由3式从右往左代替可得b x1+(a%b) y1 = (b,a%b);b x1 + (a-(a/b) b) y1 = (b,a%b);a y1 +b (x1 - (a/b) y1) = a x + b y由上可知x = y1,y = x1 - (a/b) * y1。 对于上式，我们可以比较一下欧几里得求最大公约数的算法： (a,b)=(b,a%b)，一直到b等于0时结束递归，而当b等于0时的x=1,y=0(); 然后又可以通过上面代数式4回退时计算出x与y的值！ 代码123456789101112ll x,y;ll ex_gcd(ll a,ll b)&#123; if(!b)&#123; x=1,y=0; return a; &#125; ll ans=ex_gcd(b,a%b); ll t=x; x=y; y=t-a/b*y; return ans;&#125; 应用逆元当求一个数字x对于p的逆元时，我们将其写成代数式将是如下形式： a*x=1%p; 对其进行化简可得a x+y p=1，已知x,p求a就好了化简成这样以后再看，简直就是扩展欧几里得板子！","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"欧拉筛","slug":"欧拉筛","date":"2020-01-14T07:33:59.000Z","updated":"2020-01-29T13:31:44.953Z","comments":true,"path":"2020/01/14/欧拉筛/","link":"","permalink":"https://dream-ak.top/2020/01/14/%E6%AC%A7%E6%8B%89%E7%AD%9B/","excerpt":"欧拉筛欧拉函数打表简单版！","text":"欧拉筛欧拉函数打表简单版！ 欧拉筛证明：首先介绍一下算术基本原理：x=p1^e1 p2^e2 p3^e3…(p为质数，e为正数，x为任意不为1的正整数)由上可以知道x=x1 p(min)，(p为组成x的最小质数)。所以每一个数一定可以变成一个最小质数乘上一个比这个数小的正整数；那么x将会在x1处被判断，同时也将判断比x j(j为比x最小质数小的所有质数)那么我们可以通过枚举x值来判断每一个数字是否为质数。 代码12345678910111213void erlu(int n)&#123; int i,j,k; for(i=1;i&lt;=n;i++) vis[i]=pri[i]=0; for(i=2;i&lt;=n;i++)&#123;//枚举x if(!vis[i])&#123; pri[++tot]=i; &#125; for(j=1;j&lt;=tot&amp;&amp;(i*pri[j]&lt;=n);j++)&#123; vis[i*pri[j]]=pri[j];//保存质数表，每一个空间表示该下标的最小质数！ if(i%pri[j]==0) break;第一个比x小的质数 &#125; &#125;&#125;","categories":[{"name":"数论","slug":"数论","permalink":"https://dream-ak.top/categories/%E6%95%B0%E8%AE%BA/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"差分数组实例","slug":"IncDec序列   差分数组","date":"2019-11-26T06:25:59.000Z","updated":"2020-02-03T06:52:06.528Z","comments":true,"path":"2019/11/26/IncDec序列   差分数组/","link":"","permalink":"https://dream-ak.top/2019/11/26/IncDec%E5%BA%8F%E5%88%97%20%20%20%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/","excerpt":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。","text":"题目链接请点击此处大致讲一下题意，给一个数组，让我用最少的次数将这个数组重置为相同的值，也就是数组内所有数字大小必须相同，而每一次操作仅允许对一个区间进行+1或者-1的操作。区间修改，而且是修改相同的值，就让我想到了差分数组，差分数组不熟悉的请点击让每一个值都相同其实就是让差分数组从第二个开始都为0！当从第二个开始都为0时那么整个数组都会变成第一个值的大小。那么首先就先将这一题所给原数组转化为差分数组，然后计算从第二个位置开始数组元素全部转化为0的步数。这里可以逆向思考，从0恢复到原数组元素的步数就是题目所问的最少步数，而恢复原数组的最快步数就是ans=max(正数之和，负数之和的绝对值)；解释一下：因为差分数组每一次变化都会产生一对相反数，而那么我只需要注意绝对值大的就行了，至于多出来的正数或者负数其实是可以放在最后的也就是n+1或者放到第一个位置(这里一开始没有运算!)的位置。至此步数就解决了！！！现在解决有多少种的问题：首先我之前说了一句，在经过最少次数变化以后，整个数组都会变成第一个数字的值，那么种类个数只需要考虑一下第一个数字有多少种可能就行了！在之前说过可以放第一个位置，为什么呢，因为放到这里可以改变整个数组的值，也就是中间可以放多少个，就可以改变多少次，所以答案就是（正数-负数）的绝对值+1 1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[100009],n,m,i,j,k; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++) &#123; scanf(&quot;%d&quot;,&amp;a[i]); &#125; int c[100009],ko=a[1]; for(i=2;i&lt;=n;i++) &#123; c[i]=a[i]-ko; ko=a[i]; &#125;//差分数组 long long sum2=0,sum1=0,maxx=0,minn=c[1]; for(i=2;i&lt;=n;i++) &#123; if(c[i]&gt;0) sum1+=c[i]; else sum2-=c[i]; &#125; printf(&quot;%lld\\n&quot;,max(sum1,sum2)); printf(&quot;%lld\\n&quot;,abs(sum1-sum2)+1);&#125;","categories":[{"name":"基础算法","slug":"基础算法","permalink":"https://dream-ak.top/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"ACM","slug":"ACM","permalink":"https://dream-ak.top/tags/ACM/"}]},{"title":"树状数组加二分维护区间第k大值","slug":"树状数组加二分维护区间第k大值","date":"2019-11-26T06:25:59.000Z","updated":"2020-01-29T13:32:35.983Z","comments":true,"path":"2019/11/26/树状数组加二分维护区间第k大值/","link":"","permalink":"https://dream-ak.top/2019/11/26/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8A%A0%E4%BA%8C%E5%88%86%E7%BB%B4%E6%8A%A4%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%A4%A7%E5%80%BC/","excerpt":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；","text":"题目链接&lt;/br&gt;按题意每一次查询和最大的p个数的最小字典序中第q个位置的数字；首先我们可以把所有数字的按从大到小进行一级排序，位置按从前往后进行二级排序，那么在排序以后p个数的最大和且最小字典序就是前p个数，那么我==只要输出前面按照位置从小到大的第q个数就行了==。显然，问题转化后就是求前p个数中的第q大值；树状数组维护数字x是第几大，然后在有单调性的情况下选择二分第q大值就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;const int N = 2e5+5;typedef long long ll;int a[N],ans[N],n,sum[N];struct ab&#123; int x,y;&#125;c[N];struct sc&#123; int x,y,z;&#125;b[N];bool cmp(ab p,ab q)&#123; if(p.x&gt;q.x) return true; if(p.x==q.x&amp;&amp;p.y&lt;q.y) return true; return false;&#125;bool cmp1(sc p,sc q)&#123; return p.x&lt;q.x;&#125;void add(int x)&#123; while(x&lt;=n)&#123; //printf(&quot;%dxxx\\n&quot;,x); sum[x]++; x+=(x&amp;(-x)); &#125;&#125;int get(int x)&#123; int ans=0; while(x)&#123; ans+=sum[x]; x-=(x&amp;(-x)); &#125; return ans;&#125;int main()&#123; int t,m,i,j; scanf(&quot;%d&quot;,&amp;n); for(i=1;i&lt;=n;i++)&#123; scanf(&quot;%d&quot;,&amp;a[i]); c[i].x=a[i]; c[i].y=i; &#125; sort(c+1,c+1+n,cmp); for(i=1;i&lt;=n;i++) sum[i]=0; scanf(&quot;%d&quot;,&amp;m); for(i=1;i&lt;=m;i++)&#123; scanf(&quot;%d %d&quot;,&amp;b[i].x,&amp;b[i].y); b[i].z=i; &#125; sort(b+1,b+1+m,cmp1); int p=b[m].x,q=1; for(i=1;i&lt;=p;i++)&#123; add(c[i].y); //printf(&quot;%dss\\n&quot;,c[i].y); while(b[q].x==i)&#123; int l=1,r=n,mid=0; while(l&lt;r)&#123; mid=(l+r)/2; //printf(&quot;%d %d\\n&quot;,mid,get(mid)); if(get(mid)&gt;=b[q].y) r=mid; else l=mid+1; &#125; ans[b[q].z]=a[r]; q++; &#125; &#125; for(i=1;i&lt;=m;i++)&#123; printf(&quot;%d\\n&quot;,ans[i]); &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://dream-ak.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}]}